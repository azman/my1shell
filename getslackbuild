#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.net
# - get/execute slackbuild scripts from SlackBuilds.org (supports dependencies)

MY1TOOL=`basename $0 .sh`
MY1PATH=`dirname $0`
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$MY1TOOL
	[ -r $config ] && source $config && break
done

# temporary path
MY1USER=`whoami`
MY1TEMP="/tmp/$MY1USER/$MY1TOOL"

# my1slack tool specific
MY1_TOOLNAME="my1 SlackBuilds.org Executor"
MY1_TOOLVERS="2017.03.04"
MY1_TOOLPDIR=`dirname $MY1PATH`
MY1_BUILDDIR=${MY1_BUILDDIR:="${MY1_TOOLPDIR}/slackbuilds"}
MY1_THISPATH=`pwd -P`
MY1_PACKPATH=""
MY1_LISTFILE=""
MY1_THISPACK=""
[ -z "$SLACKVERS" ] && [ -n "$RELEASE" ] && SLACKVERS=$RELEASE
SLACKVERS=${SLACKVERS:=""}
if [ "$SLACKVERS" == "" ]; then
	SLACKVERS=`cat /etc/slackware-version | sed 's/Slackware //'`
	SLACKVMAJ=`echo $SLACKVERS | cut -d. -f1`
	SLACKVMIN=`echo $SLACKVERS | cut -d. -f2`
	# just in case?
	SLACKVREL=`echo $SLACKVERS | cut -d. -f3`
fi
[ -z "$SLACKARCH" ] && [ -n "$ARCH" ] && SLACKARCH=$ARCH
SLACKARCH=${SLACKARCH:=""}
if [ "$SLACKARCH" == "" ]; then
	SLACKARCH=`find / -maxdepth 1 -name 'lib64' -type d 2>/dev/null`
	if [ "$SLACKARCH" == "/lib64" ] ; then SLACKARCH="x86_64"
	else SLACKARCH="" ; fi
fi

# global options & settings
OPT_INSTALL=""
OPT_DEPENDS="NO"
OPT_EXECUTE="NO"
OPT_CLEANUP="NO"
OPT_WARNOLD="NO"
OPT_ALL_NEW="NO"
OPT_CHK_SYS="NO"
OPT_BUILDUP="NO"
OPT_VERBOSE="NO"
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $MY1TOOL [options] <pkg_name>
Options:
  --path|-p </path/to/slackbuilds>
  --pack|-f </sub/path/to/package/group>
  --depends|-d : Check (and build) dependencies
  --update |-u : Fetch new build script if available
  --install|-i : Install when (and if) the build completes
  --execute|-x : Execute build (else, simply check @ dry-run)
  --buildup|-b : Force build even already installed
  --verbose|-v : Show more information (for --check-installed)
  --update-local|-a : Update all locally saved build scripts
  --check-installed|-c : Compare installed version against build script
SETHELPMSG`

function do_download()
{
	local fname="$1"
	local label="$2"
	local cpath=`pwd`
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -ne "\nDownloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!\n" && exit 1
	echo -e "\b\b\b\b DONE!\n"
}

function do_loadball()
{
	local pkg_path=$1
	local pkg_file=$2
	local pkg_ball=`basename $pkg_file`
	[ ! -d $pkg_path ] &&
		echo -e "[ERROR] Cannot find $pkg_path!\n" >&2 && exit 1
	# TODO! This has problems if redirected a lot (github source?)
	#wget --spider $pkg_file >/dev/null 2>&1
	#[ $? -ne 0 ] && echo -e "[ERROR] Cannot get $pkg_file!\n" >&2 && exit 1
	local chk_test=`curl -s -o /dev/null -w '%{http_code}' $pkg_file`
	[ $chk_test -ne 200 -a $chk_test -ne 301 \
			-a $chk_test -ne 302 -a $chk_test -ne 303 \
			-a $chk_test -ne 226 ] &&
		echo -e "[ERROR] Cannot get $pkg_file! ($chk_test)\n" >&2 && exit 1
	cd $pkg_path
	do_download $pkg_file $pkg_ball 2>/dev/null
	[ ! -r $pkg_ball ] &&
		echo -e "[ERROR] Cannot download $pkg_ball!\n" >&2 && exit 1
	cd - >/dev/null
	return 0
}

function get_userngrp()
{
	local chk_this=$1
	local chk_path=`pwd -P`
	local chk_user chk_grpn
	[ "$chk_this" == "." ] && chk_this=$chk_path
	[ "$chk_this" == ".." ] && chk_this=`dirname $chk_path`
	[ ! -r "$chk_this" ] && echo -e "Cannot read '$chk_this'!" 1>&2 && return
	chk_path=`dirname $chk_this`
	chk_path=`cd $chk_path;pwd`
	chk_this=`basename $chk_this`
	chk_user=`ls -l "${chk_path}/" | grep -e "${chk_this}$"`
	set -- $chk_user
	chk_user=$3
	chk_grpn=$4
	echo -n "$chk_user:$chk_grpn"
}

function get_buildinfo()
{
	local pkg_name=$1
	local pkg_path=$2
	local inf_file="${pkg_path}/${pkg_name}/${pkg_name}.info"
	[ ! -f ${inf_file} ] && return
	local pkg_info=`cat $inf_file`
	# get package version
	local pkg_vers=`echo "$pkg_info" | grep VERSION=`
	pkg_vers=`echo "$pkg_vers" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name
	local pkg_file=`echo "$pkg_info" | grep DOWNLOAD=`
	pkg_file=`echo "$pkg_file" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name x86_64
	local pkg_fil2=`echo "$pkg_info" | grep DOWNLOAD_x86_64=`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get dependencies
	pkg_deps=`echo "$pkg_info" | grep REQUIRES= | sed 's/^.*="\(.*\)".*$/\1/'`
	# format info
	echo -n "$pkg_name;$pkg_vers;$pkg_file;$pkg_fil2;$pkg_deps"
	return
}

function do_list_update()
{
	local pkg_temp="$MY1TEMP"
	local pkg_vers=${SLACKVERS}
	local pkg_root="http://slackbuilds.org/slackbuilds/$pkg_vers"
	local pkg_list="SLACKBUILDS.TXT"
	# prepare temp - get the list!
	mkdir -p $pkg_temp 2>/dev/null
	[ $? -ne 0 ] &&
		echo -e "[ERROR] Cannot create path '$pkg_temp'!\n" >&2 && exit 1
	# check if not found OR nothing modified last 120 minutes
	local chk_list=`find $pkg_temp -name $pkg_list -mmin -120 2>/dev/null`
	if [ "$chk_list" == "" ]; then
		cd $pkg_temp
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			rm -rf $pkg_list $pkg_list.gz # just in case, delete old one
			do_download ${pkg_root}/$pkg_list.gz $pkg_list.gz
			[ ! -r "$pkg_list.gz" ] &&
				echo -e "[ERROR] Cannot download $pkg_list.gz!\n" >&2 && exit 1
			gzip -d $pkg_list.gz
		else
			[ -r "$pkg_list" -a "$OPT_WARNOLD" = "YES" ] &&
				echo -e "[WARNING] NOT using latest $pkg_list!\n" >&2
		fi
		cd - >/dev/null
	fi
	# we must have it!
	local tmp_list="${pkg_temp}/$pkg_list"
	[ ! -r "$tmp_list" ] &&
		echo -e "[ERROR] File '$tmp_list' not found!\n" >&2 && exit 1
	MY1_LISTFILE="$pkg_root;$pkg_temp;$tmp_list"
}

function do_list_search()
{
	local pkg_list=$1
	local pkg_name=$2
	local pkg_root=$3
	# look for pkg_name
	local pkg_test="SLACKBUILD NAME: $pkg_name"
	local pkg_text=`cat $pkg_list|grep -e "${pkg_test}$" -A10`
	[ "$pkg_text" == "" ] &&
		echo -e "[ERROR] Cannot find script for '$pkg_name'!\n" >&2 && exit 1
	# extract info
	pkg_test=`echo "$pkg_text" | grep 'SLACKBUILD NAME'`
	pkg_test=`echo "$pkg_test" | sed 's/.*: \(.*\)$/\1/'`
	[ "$pkg_test" != "$pkg_name" ] &&
		echo -e "[ERROR] Name error? '$pkg_test'/'$pkg_name'!\n" >&2 && exit 1
	local pkg_load=`echo "$pkg_text" | grep 'SLACKBUILD LOCATION'`
	pkg_load=`echo "$pkg_load" | sed 's/.*: \.\(.*\)$/\1/'`
	pkg_load="${pkg_root}${pkg_load}.tar.gz"
	local pkg_vers=`echo "$pkg_text" | grep 'SLACKBUILD VERSION'`
	pkg_vers=`echo "$pkg_vers" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_file=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD:'`
	pkg_file=`echo "$pkg_file" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_fil2=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD_x86_64'`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_deps=`echo "$pkg_text" | grep 'SLACKBUILD REQUIRES'`
	pkg_deps=`echo "$pkg_deps" | sed 's/.*: \(.*\)$/\1/'`
	MY1_THISPACK="$pkg_load;$pkg_vers;$pkg_file;$pkg_fil2;$pkg_deps"
}

function do_fetch()
{
	local pkg_list=$1
	local pkg_name=$2
	local pkg_root=$3
	local pkg_path=$4
	local pkg_temp=$5
	local chk_skip=0
	# look for package in list
	do_list_search $pkg_list $pkg_name $pkg_root
	local pkg_info="$MY1_THISPACK"
	local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
	# check if local version is available
	local tmp_vers=""
	local tmp_info=`get_buildinfo $pkg_name $pkg_path`
	if [ "$tmp_info" != "" ] ; then
		tmp_vers=`echo "$tmp_info" | cut -d';' -f2`
	else
		# look within tree?
		local top_path=${MY1_BUILDDIR}
		local pkg_test=`find $top_path -name "$pkg_name" -type d`
		if [ -d "$pkg_test" ] ; then
			local tmp_path=`dirname $pkg_test`
			tmp_info=`get_buildinfo $pkg_name $tmp_path`
			if [ "$tmp_info" != "" ] ; then
				tmp_vers=`echo "$tmp_info" | cut -d';' -f2`
				pkg_path=${tmp_path}
			fi
		fi
	fi
	# do we need to fetch?
	if [ "$tmp_vers" != "$pkg_vers" ] ; then
		if [ "$tmp_vers" == "" -o "$OPT_CLEANUP" == "YES" ] ; then
			local pkg_load=`echo "$pkg_info" | cut -d';' -f1`
			local pkg_test=`dirname $pkg_load`
			local pkg_text=`basename $pkg_load`
			cd $pkg_temp
			wget --spider $pkg_test >/dev/null 2>&1
			[ $? -ne 0 ] &&
				echo -e "[ERROR] Cannot find $pkg_test!\n" >&2 && exit 1
			# remove old tarballs?
			rm -rf ${pkg_text}*
			do_download $pkg_load $pkg_text 2>/dev/null
			[ ! -r "$pkg_text" ] &&
				echo -e "[ERROR] Cannot download $pkg_load!\n" >&2 && exit 1
			cd - >/dev/null
			tmp_vers=$pkg_vers
			pkg_test=$pkg_temp/$pkg_text
			[ ! -d "$pkg_path" ] && mkdir -p $pkg_path
			cd $pkg_path
			# remove old?
			rm -rf ${pkg_name}
			# extract accordingly?
			tar xf $pkg_test 2>/dev/null
			[ $? -ne 0 ] &&
				echo -e "[ERROR] Cannot extract $pkg_test!\n" >&2 && exit 1
			cd - >/dev/null
		else
			# local version available - skip downloading tarball!
			chk_skip=1
		fi
	fi
	# true path!
	pkg_path=${pkg_path}/${pkg_name}
	# have we got the buildscript?
	local pkg_exec=${pkg_path}/${pkg_name}.SlackBuild
	[ ! -f "$pkg_exec" ] &&
		echo -e "Script '$pkg_exec' not found!\n" && exit 1
	# do we need to download?
	if [ $chk_skip -eq 0 ] ; then
		# check if tarball available?
		local pkg_file=`echo "$pkg_info" | cut -d';' -f3`
		local pkg_fil2=`echo "$pkg_info" | cut -d';' -f4`
		if [ "$pkg_file" != "${pkg_file#* }" ] ; then
			local tmp_file
			#echo -e "[ERROR] Multiple source files '$pkg_file'!\n" >&2 &&
			#exit 1
			for chk in $pkg_file ; do
				[ "$tmp_file" = "" ] && tmp_file=$chk && continue
				local tmp_ball=`basename $chk`
				[ ! -f "${pkg_path}/${tmp_ball}" ] &&
					do_loadball $pkg_path $chk
			done
			pkg_file=$tmp_file
		fi
		local pkg_ball=`basename $pkg_file`
		[ ! -f "${pkg_path}/${pkg_ball}" ] &&
			do_loadball $pkg_path $pkg_file
		if [ "$pkg_fil2" != "" ] ; then
			pkg_ball=`basename $pkg_fil2`
			[ ! -f "${pkg_path}/${pkg_ball}" ] &&
				do_loadball $pkg_path $pkg_fil2
		fi
	fi
	# some deps asks to refer to README
	local pkg_deps=`echo "$pkg_info" | cut -d';' -f5`
	[ "$pkg_deps" == "%README%" ] && pkg_deps=""
	# some external function need these info
	MY1_THISPACK="$pkg_path;$pkg_vers;$tmp_vers;$pkg_deps"
}

function do_build()
{
	local pkg_name=$1
	local pkg_vers=$2
	local pkg_path=$3
	local opt_temp=$4
	local opt_inst=$5
	# check if already installed? should check version as well?
	local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_root=`ls /var/log/packages | grep -e "$pkg_temp"`
	if [ "$pkg_root" != "" ] ; then
		# check version - stop if exactly the same!
		pkg_temp=`echo $pkg_root | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\2/'`
		if [ "$pkg_vers" == "$pkg_temp" ] ; then
			echo "Package ${pkg_root} installed."
			[ "$OPT_BUILDUP" == "NO" ] && return
		fi
		# continue, but do not install?
		opt_inst=""
	fi
	# only root can actually build!
	[ $UID -ne 0 ] &&
		echo -e "Must run as root! ($pkg_name-$pkg_vers)\n" && return
	# start build?
	local log_file=${opt_temp}/${pkg_name}.buildlog
	cd ${pkg_path}
	[ ! -f "${pkg_name}.SlackBuild" ] &&
		echo -e "Script '$pkg_exec' not found in $pkg_path!\n" && exit 1
	echo -n "Building '$pkg_name' ... "
	sh ${pkg_name}.SlackBuild >${log_file} 2>&1
	[ $? -ne 0 ] && echo -e "Error building '$pkg_name'!\n" && exit 1
	echo "done!"
	cd - >/dev/null
	local pkg_file=`cat ${log_file} | tail -n 2 | grep Slackware`
	pkg_file=`echo "$pkg_file" | sed 's/^.*package \(.*\) created.*$/\1/'`
	[ ! -f "$pkg_file" ] &&
		echo "Cannot find package '$pkg_file'!" && exit 1
	if [ "$opt_inst" == "--install" ] ; then
		# go install!
		echo -n "Installing '$pkg_file'... "
		installpkg $pkg_file >>${log_file} 2>&1
		[ $? -ne 0 ] &&
			echo -e "Error installing '$pkg_file'!\n" && exit 1
		echo "done!"
	else
		# copy built package & build log to chk_path (cwd)
		echo -n "Copying '$pkg_file' to '$chk_path'... "
		local chk_perm=`get_userngrp $chk_path`
		mv $pkg_file $chk_path
		pkg_file=${chk_path}/`basename $pkg_file`
		mv $log_file $chk_path
		log_file=${chk_path}/`basename $log_file`
		if [ "$chk_perm" != "" ] ; then
			chown $chk_perm $pkg_file $log_file
		fi
		echo "done!"
	fi
}

function do_build_this()
{
	local pkg_name=$1
	local pkg_path=$2
	local opt_inst=$3
	local chk_path=${MY1_THISPATH}
	local sav_path=${pkg_path}
	# update list
	do_list_update
	# get parameters
	local pkg_root=`echo "$MY1_LISTFILE" | cut -d';' -f1`
	local pkg_temp=`echo "$MY1_LISTFILE" | cut -d';' -f2`
	local pkg_list=`echo "$MY1_LISTFILE" | cut -d';' -f3`
	# fetch build
	do_fetch $pkg_list $pkg_name $pkg_root $pkg_path $pkg_temp
	# update path (in case in different path?)
	pkg_path=`echo "$MY1_THISPACK" | cut -d';' -f1`
	local pkg_vers=`echo "$MY1_THISPACK" | cut -d';' -f2`
	local tmp_vers=`echo "$MY1_THISPACK" | cut -d';' -f3`
	local pkg_deps=`echo "$MY1_THISPACK" | cut -d';' -f4`
	# show this before dependencies if not really building
	if [ "$OPT_EXECUTE" != "YES" ]; then
		echo -n "Package: $pkg_name ($pkg_vers)"
		[ "$tmp_vers" != "" -a "$tmp_vers" != "$pkg_vers" ] &&
			echo -n ", Local Version: {$tmp_vers}"
		[ "$pkg_deps" != "" ] && echo -n ", Requires: $pkg_deps" ; echo
	fi
	# iterate through dependencies, if requested
	if [ "$OPT_DEPENDS" == "YES" ]; then
		for pkg in $pkg_deps ; do
			do_build_this $pkg $sav_path --install
		done
	fi
	# build only if explicitly requested
	[ "$OPT_EXECUTE" == "YES" ] &&
		do_build $pkg_name $pkg_vers $pkg_path $pkg_temp $opt_inst
}

function do_update_all()
{
	local chk_path=$1
	local chk_list=`find $pkg_path -name "*.SlackBuild"`
	echo -e "Updating buildscripts in '$chk_path':\n"
	for pkg in $chk_list ; do
		local tmp_path=`dirname $pkg`
		local pkg_path=`dirname $tmp_path`
		local pkg_name=`basename $tmp_path`
		local pkg_info=`get_buildinfo $pkg_name $pkg_path`
		[ "$pkg_info" == "" ] &&
			echo -e "Error updating '$pkg_name'! Aborting!\n" && exit 1
		# update list
		do_list_update
		# get parameters
		local pkg_root=`echo "$MY1_LISTFILE" | cut -d';' -f1`
		local pkg_temp=`echo "$MY1_LISTFILE" | cut -d';' -f2`
		local pkg_list=`echo "$MY1_LISTFILE" | cut -d';' -f3`
		# fetch build
		do_fetch $pkg_list $pkg_name $pkg_root $pkg_path $pkg_temp
		# update path (in case in different path?)
		pkg_path=`echo "$MY1_THISPACK" | cut -d';' -f1`
		local pkg_vers=`echo "$MY1_THISPACK" | cut -d';' -f2`
		local tmp_vers=`echo "$MY1_THISPACK" | cut -d';' -f3`
		# show this before dependencies if not really building
		echo -n "Package: $pkg_name ($pkg_vers)"
		[ "$tmp_vers" != "" -a "$tmp_vers" != "$pkg_vers" ] &&
			echo -n ", Local Version: {$tmp_vers}"
		pkg_path=`echo $pkg_path | sed "s|$chk_path||"`
		echo " [Path: $pkg_path]"
	done ; echo
}

function do_check_installed()
{
	local chk_path=$1
	local chk_list=`find $pkg_path -name "*.SlackBuild"`
	for pkg in $chk_list ; do
		local tmp_path=`dirname $pkg`
		local pkg_path=`dirname $tmp_path`
		local pkg_name=`basename $tmp_path`
		local pkg_info=`get_buildinfo $pkg_name $pkg_path`
		[ "$pkg_info" == "" ] &&
			echo -e "Error updating '$pkg_name'! Aborting!\n" && exit 1
		local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
		# look for installed only!
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
		local pkg_root=`ls /var/log/packages | grep -e "$pkg_temp"`
		[ "$pkg_root" == "" ] && continue;
		# check version
		pkg_temp=`echo $pkg_root | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\2/'`
		[ "$pkg_temp" == "$pkg_vers" -a "$OPT_VERBOSE" != "YES" ] && continue;
		# show if not the same version
		echo -n "Installed: {$pkg_root}, "
		echo -n "Build: $pkg_name ($pkg_vers)"
		pkg_path=`echo $pkg_path | sed "s|$chk_path||"`
		echo " [Path: $pkg_path]"
	done ; echo
}

function process_command()
{
	local pkg_name pkg_path
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--install|-i)
				OPT_INSTALL="--install"
				;;
			--depends|-d)
				OPT_DEPENDS="YES"
				;;
			--execute|-x)
				OPT_EXECUTE="YES"
				;;
			--update|-u)
				OPT_CLEANUP="YES"
				OPT_WARNOLD="YES"
				;;
			--update-local|-a)
				OPT_ALL_NEW="YES"
				OPT_CLEANUP="YES"
				;;
			--check-installed|-c)
				OPT_CHK_SYS="YES"
				;;
			--verbose|-v)
				OPT_VERBOSE="YES"
				;;
			--buildup|-b)
				OPT_BUILDUP="YES"
				;;
			--path|-p)
				shift
				[ ! -d "$1" ] &&
					echo -e "[ERROR] Invalid path!? [$1]\n" && exit 1
				MY1_BUILDDIR=`cd $1;pwd`
				;;
			--pack|-f)
				shift
				MY1_PACKPATH="$1"
				;;
			-*)
				echo -e "$MSG_THISHELP\n"
				echo -e "[ERROR] Unknown option '$1'!\n" ; exit 1
				;;
			*)
				[ "$pkg_name" != "" ] &&
					echo -e "[ERROR] Multiple package? [$pkg_name]\n" && exit 1
				pkg_name="$1"
				;;
		esac
		shift
	done
	# check if path is valid?
	pkg_path=${MY1_BUILDDIR}
	[ ! -d "$pkg_path" ] &&
		echo -e "Path '$pkg_path' not found! Aborting!\n" && exit 1
	# check option to check installed build script(s)
	[ "$OPT_CHK_SYS" == "YES" ] && do_check_installed ${pkg_path} && exit 0
	# check option to update ALL build scripts found
	[ "$OPT_ALL_NEW" == "YES" ] && do_update_all ${pkg_path} && exit 0
	# check if name supplied
	[ "$pkg_name" == "" ] && echo -e "$MSG_THISHELP\n" && exit 0
	# check if package path supplied
	[ "$MY1_PACKPATH" != "" ] && pkg_path=${pkg_path}/${MY1_PACKPATH}
	# do your thing!
	do_build_this ${pkg_name} ${pkg_path} ${OPT_INSTALL}
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1TOOL - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
