#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.net
# - get/execute slackbuild scripts from SlackBuilds.org (supports dependencies)

TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$TOOL_NAME
	[ -r $config ] && source $config && break
done

# find libraries
[ ! -f $TOOL_PATH/libmy1slack ] &&
	echo "Cannot find libmy1slack!" && exit 1
. $TOOL_PATH/libmy1slack
must_have_file $TOOL_PATH/libmy1get
. $TOOL_PATH/libmy1get

# temporary path
TOOL_USER=`whoami`
TOOL_TEMP="/tmp/$TOOL_USER/$TOOL_NAME"

# tool specific
TOOL_DESC="my1 SlackBuilds.org Executor"
TOOL_VERS="2019.07.00"
TOOL_PDIR=`dirname $TOOL_PATH`
WORK_PATH="$TOOL_PDIR/slackbuilds"
CURR_PATH=`pwd -P`
PACK_PATH="test-pack" # default package path
[ -z "$SLACKNAME" ] && [ -n "$ARCH" ] && [ "$ARCH" = "x86_64" ] &&
	SLACKNAME="slackware64" || SLACKNAME="slackware"
[ -z "$SLACKVERS" ] && [ -n "$VERS" ] && SLACKVERS=$VERS || SLACKVERSE="current"
call_setup
BUILD_URL="http://slackbuilds.org/slackbuilds/$SLACKVERS"
BUILDLIST="SLACKBUILDS.TXT"
BUILDPATH="$TOOL_TEMP"
BUILDFULL="$BUILDPATH/$BUILDLIST"

# global options & settings
OPT_INSTALL="NO"
OPT_DEPENDS="NO"
OPT_EXECUTE="NO"
OPT_CLEANUP="NO"
OPT_WARNOLD="NO"
OPT_LISTOLD="NO"
OPT_LISTALL="NO"
OPT_ALL_NEW="NO"
OPT_CHK_SYS="NO"
OPT_BUILDUP="NO"
OPT_VERBOSE="NO"
OPT_REVDEPS="NO"
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $TOOL_NAME [options] <pkg_name>
Options:
  --path|-p </path/to/slackbuilds>
  --pack|-f </sub/path/to/package/group>
  --depends | -d : Check (and build) dependencies
  --update  | -u : Fetch new build script if available
  --install | -i : Install when (and if) the build completes
  --execute | -x : Execute build (else, simply check @ dry-run)
  --buildup | -b : Force build even already installed
  --verbose | -v : Show more information (for --check-installed)
              -l : List ALL local scripts (without updating)
              -s : Use existing package list (no internet update)
              -a : Update all locally saved build scripts
              -r : Check reverse dependencies
              -c : Compare installed version against build script
SETHELPMSG`

info_build()
{
	local fun_name="info_build()"
	local chk_file=$1 # full path name to SlackBuild
	local pkg_name=`basename $chk_file .SlackBuild`
	local pkg_path=`dirname $chk_file`
	local inf_file=$pkg_path/$pkg_name.info
	must_have_file $inf_file "$fun_name: Cannot find info '$inf_file'!"
	local chk_name=`basename $pkg_path`
	[ "$chk_name" != "$pkg_name" ] &&
		error_exit "$fun_name: Path mismatch? {$chk_name/$pkg_name}\n\n"
	local pkg_pack=`dirname $pkg_path`
	local pkg_info=`cat $inf_file`
	# get package version
	local pkg_vers=`echo "$pkg_info" | grep VERSION=`
	pkg_vers=`echo "$pkg_vers" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name
	local pkg_file=`echo "$pkg_info" | grep DOWNLOAD=`
	pkg_file=`echo "$pkg_file" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name x86_64
	local pkg_fil2=`echo "$pkg_info" | grep DOWNLOAD_x86_64=`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get dependencies
	pkg_deps=`echo "$pkg_info" | grep REQUIRES= | sed 's/^.*="\(.*\)".*$/\1/'`
	pkg_deps=`echo $pkg_deps | tr ' ' ','`
	# format info
	echo -n "$pkg_name;$pkg_vers;$pkg_pack;$pkg_file;$pkg_fil2;$pkg_deps"
}

find_build()
{
	local fun_name="find_build()"
	local pkg_name=$1
	local pkg_path=$WORK_PATH
	must_have_path $pkg_path "$fun_name: Cannot find path '$pkg_path'!"
	local chk_file=`find $pkg_path -type f -name "${pkg_name}.SlackBuild"`
	echo -n "$chk_file"
}

list_build()
{
	local fun_name="list_build()"
	local chk_path=$WORK_PATH
	must_have_path $chk_path "$fun_name: Cannot find path '$chk_path'!"
	local chk_list=`find $chk_path -type f -name "*.SlackBuild" | sort -u`
	echo -n "$chk_list"
}

search_list()
{
	local pkg_name=$1
	local pkg_list=$BUILDFULL
	local pkg_root=$BUILD_URL
	# look for pkg_name
	local pkg_test="SLACKBUILD NAME: $pkg_name"
	local pkg_text=`cat $pkg_list|grep -e "${pkg_test}$" -A10`
	[ "$pkg_text" == "" ] &&
		error_exit "Cannot find script for '$pkg_name'!\n\n"
	# extract info
	pkg_test=`echo "$pkg_text" | grep 'SLACKBUILD NAME'`
	pkg_test=`echo "$pkg_test" | sed 's/.*: \(.*\)$/\1/'`
	[ "$pkg_test" != "$pkg_name" ] &&
		error_exit "Name error? '$pkg_test'/'$pkg_name'!\n\n"
	local pkg_load=`echo "$pkg_text" | grep 'SLACKBUILD LOCATION'`
	pkg_load=`echo "$pkg_load" | sed 's/.*: \.\(.*\)$/\1/'`
	pkg_load="${pkg_root}${pkg_load}.tar.gz"
	local pkg_vers=`echo "$pkg_text" | grep 'SLACKBUILD VERSION'`
	pkg_vers=`echo "$pkg_vers" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_file=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD:'`
	pkg_file=`echo "$pkg_file" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_fil2=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD_x86_64'`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_deps=`echo "$pkg_text" | grep 'SLACKBUILD REQUIRES'`
	pkg_deps=`echo "$pkg_deps" | sed 's/.*: \(.*\)$/\1/'`
	pkg_deps=`echo $pkg_deps | tr ' ' ','`
	echo -n "$pkg_load;$pkg_vers;$pkg_file;$pkg_fil2;$pkg_deps"
}

show_build()
{
	local fun_name="show_build()"
	local chk_info=$1
	local chk_name=`echo "$chk_info" | cut -d';' -f1`
	local chk_vers=`echo "$chk_info" | cut -d';' -f2`
	local chk_pack=`echo "$chk_info" | cut -d';' -f3`
	chk_pack=`echo $chk_pack | sed "s|$WORK_PATH||"`
	local chk_deps=`echo "$chk_info" | cut -d';' -f6`
	# setup trap for search_list
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local lst_info=`search_list $chk_name`
	trap - ERR
	local lst_vers=`echo "$lst_info" | cut -d';' -f2`
	# show it!
	head_msg "Package: $chk_name ($lst_vers)"
	[ "$chk_pack" != "" ] && info_msg --no-tag " [Pack: $chk_pack]"
	[ "$chk_vers" != "" -a "$chk_vers" != "$lst_vers" ] &&
		head_msg ", Local Version: {$chk_vers}"
	echo ; [ "$chk_deps" != "" ] &&
		warn_msg --no-tag "-- Requires: $chk_deps\n"
}

do_list_local()
{
	local fun_name="do_list_local()"
	local chk_full=`list_build`
	[ -z "$chk_full" ] &&
		info_msg --no-tag "No scripts found!\n\n" && return
	info_msg --no-tag "List all buildscripts...\n\n"
	for that in $chk_full ; do
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		local chk_info=`info_build $that`
		trap - ERR
		show_build $chk_info
	done ; echo
}

update_list()
{
	local pkg_temp="$TOOL_TEMP"
	local pkg_root="$BUILD_URL"
	local pkg_list="$BUILDLIST"
	local cur_path=`pwd`
	# prepare path for list
	if [ ! -d $pkg_temp ] ; then
		mkdir -p $pkg_temp 2>/dev/null
		[ $? -ne 0 ] && error_exit "Cannot create path '$pkg_temp'!\n\n"
	fi
	# check if not found OR nothing modified last 120 minutes
	local new_list="-mmin -120"
	[ "$OPT_LISTOLD" = "YES" ] && new_list=""
	local chk_list=`find $pkg_temp -name $pkg_list $new_list 2>/dev/null`
	if [ "$chk_list" == "" ]; then
		cd $pkg_temp
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			rm -rf $pkg_list $pkg_list.gz # just in case, delete old one
			do_download ${pkg_root}/$pkg_list.gz $pkg_list.gz
			[ ! -r "$pkg_list.gz" ] &&
				error_exit "Cannot download $pkg_list.gz!\n\n"
			gzip -d $pkg_list.gz
		else
			[ -r "$pkg_list" -a "$OPT_WARNOLD" = "YES" ] &&
				warn_msg "NOT using latest $pkg_list!\n"
		fi
		cd $cur_path
	fi
	# we must have it!
	local tmp_list="$BUILDFULL"
	[ ! -r "$tmp_list" ] && error_exit "File '$tmp_list' not found!\n\n"
}

go_fetch_ware()
{
	local pkg_info=$1
	local pkg_load=`echo "$pkg_info" | cut -d';' -f1`
	local pkg_test=`dirname $pkg_load`
	local pkg_path=$2
	# check if tarball available?
	local pkg_file=`echo "$pkg_info" | cut -d';' -f3`
	local pkg_fil2=`echo "$pkg_info" | cut -d';' -f4`
	if [ "$pkg_file" != "${pkg_file#* }" ] ; then
		local tmp_file
		for chk in $pkg_file ; do
			[ "$tmp_file" = "" ] && tmp_file=$chk && continue
			local tmp_ball=`basename $chk`
			[ ! -f "${pkg_path}/${tmp_ball}" ] &&
				do_loadball $pkg_path $chk
		done
		pkg_file=$tmp_file
	fi
	local pkg_ball=`basename $pkg_file`
	[ ! -f "${pkg_path}/${pkg_ball}" ] &&
		do_loadball $pkg_path $pkg_file
	if [ "$pkg_fil2" != "" ] ; then
		pkg_ball=`basename $pkg_fil2`
		[ ! -f "${pkg_path}/${pkg_ball}" ] &&
			do_loadball $pkg_path $pkg_fil2
	fi
}

go_fetch_ball()
{
	local pkg_info=$1
	local pkg_load=`echo "$pkg_info" | cut -d';' -f1`
	local pkg_test=`dirname $pkg_load`
	local pkg_text=`basename $pkg_load`
	local pkg_temp="$TOOL_TEMP"
	local pkg_path=$2
	local cur_path=`pwd`
	cd $pkg_temp
	wget --spider $pkg_test >/dev/null 2>&1
	[ $? -ne 0 ] && error_exit "Cannot get $pkg_test!\n\n"
	# remove old tarballs?
	rm -rf ${pkg_text}*
	do_download $pkg_load $pkg_text 2>/dev/null
	[ ! -r "$pkg_text" ] && error_exit "Cannot download $pkg_load!\n\n"
	cd $cur_path
	local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
	pkg_test=$pkg_temp/$pkg_text
	[ ! -d "$pkg_path" ] && mkdir -p $pkg_path
	cd $pkg_path
	# remove old?
	rm -rf $pkg_name
	# extract accordingly?
	tar xf $pkg_test 2>/dev/null
	[ $? -ne 0 ] && error_exit "Cannot extract $pkg_test!\n\n"
	cd $cur_path
}

go_fetch()
{
	local fun_name="go_fetch()"
	local pkg_name=$1 # package name
	local pkg_path=$2 # storage path
	local top_path=$WORK_PATH
	# setup trap for search_list
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local chk_info=`search_list $pkg_name`
	trap - ERR
	local chk_vers=`echo "$chk_info" | cut -d';' -f2`
	# setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_info pkg_vers
	local pkg_file=`find_build $pkg_name`
	trap - ERR
	if [ "$pkg_file" != "" ] ; then
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		pkg_info=`info_build $pkg_file`
		trap - ERR
		if [ "$pkg_info" != "" ] ; then
			pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
			# we have one locally, use that path!
			pkg_path=`echo "$pkg_info" | cut -d';' -f3`
		fi
	fi
	# do we need to fetch?
	if [ "$pkg_vers" != "$chk_vers" ] ; then
		# if no local OR we want a clean one
		if [ "$pkg_vers" == "" -o "$OPT_CLEANUP" == "YES" ] ; then
			go_fetch_ball $chk_info $pkg_path
		fi
	fi
	# re-check script, setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	pkg_file=`find_build $pkg_name`
	trap - ERR
	[ "$pkg_file" = "" ] &&
		error_exit "$fun_name: Failed to fetch $pkg_name?\n\n"
	go_fetch_ware $chk_info `dirname $pkg_file`
}

do_update_all()
{
	local fun_name="do_update_all()"
	local chk_full=`list_build`
	[ -z "$chk_full" ] &&
		info_msg --no-tag "No scripts found!\n\n" && return
	# update list
	update_list
	info_msg --no-tag "Updating all buildscripts...\n\n"
	for that in $chk_full ; do
		# get name from script file name
		local pkg_name=`basename $that .SlackBuild`
		# go for it...
		go_fetch $pkg_name $WORK_PATH
		# setup trap for find_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		local pkg_file=`find_build $pkg_name`
		trap - ERR
		[ "$pkg_file" = "" ] &&
			error_exit "$fun_name: Failed to fetch $pkg_name?!\n\n"
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		local pkg_info=`info_build $pkg_file`
		trap - ERR
		# show it...
		show_build $pkg_info
	done ; echo
}

go_build()
{
	local pkg_file=$1
	must_have_file $pkg_file "Build script '$pkg_file' not found!"
	local pkg_name=`basename $pkg_file .SlackBuild`
	local pkg_path=`dirname $pkg_file`
	local pkg_vers=$2
	local opt_inst=$3
	local cur_path=`pwd`
	# check if already installed? should check version as well?
	local pkg_base=`find_install $pkg_name`
	if [ "$pkg_base" != "" ] ; then
		local chk_info=`get_pkg_info $pkg_base`
		local chk_vers=`echo "$chk_info" | cut -d' ' -f2`
		# check version - stop if exactly the same!
		if [ "$chk_vers" == "$pkg_vers" ] ; then
			echo "Package $pkg_base installed."
			[ "$OPT_BUILDUP" == "NO" ] && return
		fi
	fi
	# only root can actually build!
	must_be_root "Must run as root! ($pkg_name-$pkg_vers)"
	# start build?
	local log_file=$TOOL_TEMP/${pkg_name}.buildlog
	cd $pkg_path
	info_msg "Building '$pkg_name' ... "
	sh ${pkg_name}.SlackBuild >$log_file 2>&1
	[ $? -ne 0 ] && error_exit "Error building '$pkg_name'!\n\n"
	info_msg --no-tag "done!\n"
	cd $cur_path
	local pkg_ball=`cat $log_file | tail -n 2 | grep Slackware`
	pkg_ball=`echo "$pkg_ball" | sed 's/^.*package \(.*\) created.*$/\1/'`
	must_have_file $pkg_ball "Cannot find package '$pkg_ball'!"
	if [ "$opt_inst" == "--install" ] ; then
		if [ "$pkg_base" != "" ] ; then
			local chk_opts=""
			# upgrade existing?
			local chk_info=`get_pkg_info $pkg_base`
			local chk_vers=`echo "$chk_info" | cut -d' ' -f2`
			[ "$chk_vers" == "$pkg_vers" ] && chk_opts="--reinstall"
			# go upgrade!
			info_msg "Upgrading '$pkg_ball' ($chk_vers -> $pkg_vers)... "
			upgradepkg $chk_opts $pkg_ball >>$log_file 2>&1
			[ $? -ne 0 ] && error_exit "Error upgrading '$pkg_ball'!\n\n"
			info_msg --no-tag "done!\n"
		else
			# go install!
			info_msg "Installing '$pkg_ball'... "
			installpkg $pkg_ball >>$log_file 2>&1
			[ $? -ne 0 ] && error_exit "Error installing '$pkg_ball'!\n\n"
			info_msg --no-tag "done!\n"
		fi
	else
		# copy built package & build log to cur_path
		info_msg "Copying '$pkg_ball' to '$cur_path'... "
		mv $pkg_ball $cur_path
		pkg_ball=$cur_path/`basename $pkg_ball`
		mv $log_file $cur_path
		log_file=$cur_path/`basename $log_file`
		info_msg --no-tag "done!\n"
		# fix permission of built package & build log
		local ref_perm=`get_path_owner $cur_path`
		local chk_perm=`get_path_owner $pkg_ball`
		if [ "$chk_perm" != "" -a "$ref_perm" != "" ] ; then
			if [ "$chk_perm" != "$ref_perm" ] ; then
				info_msg "Fixing file permissions ... "
				chown $ref_perm $pkg_ball $log_file
				info_msg --no-tag "done!\n"
			fi
		fi
	fi
}

do_run_build()
{
	local fun_name="do_run_build()"
	local pkg_name=$1
	local pkg_path=$2
	local opt_inst=$3
	local sav_path=$pkg_path
	# fetch build
	go_fetch $pkg_name $pkg_path
	# setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_file=`find_build $pkg_name`
	trap - ERR
	[ "$pkg_file" = "" ] && error_exit "Failed to fetch $pkg_name?\n\n"
	# setup trap for info_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_info=`info_build $pkg_file`
	trap - ERR
	local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
	local pkg_deps=`echo "$pkg_info" | cut -d';' -f6`
	# show this before dependencies if not really building
	if [ "$OPT_EXECUTE" != "YES" ]; then
		show_build $pkg_info
	fi
	# iterate through dependencies, if requested
	if [ "$OPT_DEPENDS" == "YES" ]; then
		# some deps asks to refer to README
		[ "$pkg_deps" == "%README%" ] && pkg_deps=""
		pkg_deps=`echo $pkg_deps | tr ',' ' '`
		for pkg in $pkg_deps ; do
			do_run_build $pkg $sav_path --install
		done
	fi
	# build only if explicitly requested
	[ "$OPT_EXECUTE" == "YES" ] &&
		go_build $pkg_file $pkg_vers $opt_inst
}

do_check_installed()
{
	local fun_name="do_check_installed()"
	local chk_full=`list_build`
	[ -z "$chk_full" ] &&
		info_msg --no-tag "No scripts found!\n\n" && return
	for that in $chk_full ; do
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		local chk_info=`info_build $that`
		trap - ERR
		local chk_name=`echo "$chk_info" | cut -d';' -f1`
		local chk_vers=`echo "$chk_info" | cut -d';' -f2`
		local chk_pack=`echo "$chk_info" | cut -d';' -f3`
		chk_pack=`echo $chk_pack | sed "s|$WORK_PATH||"`
		# look for installed
		local pkg_base=`find_install $chk_name`
		[ "$pkg_base" == "" ] && continue;
		local pkg_info=`get_pkg_info $pkg_base`
		local pkg_vers=`echo "$pkg_info" | cut -d' ' -f2`
		# check version
		[ "$pkg_vers" == "$chk_vers" -a "$OPT_VERBOSE" != "YES" ] && continue;
		# show if not the same version
		head_msg "Installed: {$pkg_base}, "
		head_msg "Build: $chk_name ($chk_vers)"
		[ "$chk_pack" != "" ] && info_msg --no-tag " [Pack: $chk_pack]"
		echo
	done ; echo
}

do_check_reversedeps()
{
	local fun_name="do_check_reversedeps()"
	local pkg_name=$1
	local pkg_file=`find_build $pkg_name`
	[ $? -ne 0 ] && error_exit "Failed to find $pkg_name?\n\n"
	[ "$pkg_file" = "" ] &&
		error_exit "Cannot find '$pkg_name.SlackBuild'!\n\n"
	local pkg_info=`info_build $pkg_file`
	[ $? -ne 0 ] && error_exit "Failed to get $pkg_name info?\n\n"
	# get full list
	local pkg_dept
	for that in `list_build` ; do
		local chk_name=`basename $that .SlackBuild`
		[ "$chk_name" = "$pkg_name" ] && continue
		local chk_info=`info_build $that`
		[ $? -ne 0 ] && error_exit "Failed to get $chk_name info?\n\n"
		# get deps
		local chk_deps=`echo "$chk_info" | cut -d';' -f6`
		[ "$chk_deps" = "" ] && continue
		# some deps asks to refer to README
		[ "$chk_deps" == "%README%" ] && chk_deps=""
		chk_deps=`echo $chk_deps | tr ',' ' '`
		for what in $chk_deps ; do
			if [ "$what" = "$pkg_name" ] ; then
				pkg_dept="${pkg_dept}$chk_name "
				break
			fi
		done
	done
	[ -z "$pkg_dept" ] && pkg_dept="None"
	# show it
	show_build $pkg_info
	warn_msg --no-tag "-- Dependents: $pkg_dept\n\n"
}

process_command()
{
	local pkg_name pkg_path
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--install|-i)
				OPT_INSTALL="--install"
				;;
			--depends|-d)
				OPT_DEPENDS="YES"
				;;
			-r)
				OPT_REVDEPS="YES"
				;;
			--execute|-x)
				OPT_EXECUTE="YES"
				;;
			--update|-u)
				OPT_CLEANUP="YES"
				OPT_WARNOLD="YES"
				;;
			-a)
				OPT_ALL_NEW="YES"
				OPT_CLEANUP="YES"
				;;
			-c)
				OPT_CHK_SYS="YES"
				;;
			--verbose|-v)
				OPT_VERBOSE="YES"
				;;
			-l)
				OPT_LISTALL="YES"
				;;
			-s)
				OPT_LISTOLD="YES"
				;;
			--buildup|-b)
				OPT_BUILDUP="YES"
				;;
			--path|-p)
				shift
				must_have_path $1 "Invalid path '$1'!"
				WORK_PATH=`cd $1;pwd`
				;;
			--pack|-f)
				shift
				PACK_PATH="$1"
				;;
			-*)
				echo -e "$MSG_THISHELP\n"
				echo -e "[ERROR] Unknown option '$1'!\n" ; exit 1
				;;
			*)
				[ "$pkg_name" != "" ] &&
					echo -e "[ERROR] Multiple package? [$pkg_name]\n" && exit 1
				pkg_name="$1"
				;;
		esac
		shift
	done
	# check if path is valid?
	pkg_path=$WORK_PATH
	must_have_path $pkg_path "Path '$pkg_path' not found! Aborting!"
	info_msg --no-tag "Slackbuilds path: $WORK_PATH\n\n"
	# check option to list existing build script(s) against existing list
	[ "$OPT_LISTALL" == "YES" ] && do_list_local && exit 0
	# check option to update ALL build scripts found
	[ "$OPT_ALL_NEW" == "YES" ] && do_update_all && exit 0
	# check option to check installed build script(s)
	[ "$OPT_CHK_SYS" == "YES" ] && do_check_installed && exit 0
	# check if name supplied
	[ "$pkg_name" == "" ] && echo -e "$MSG_THISHELP\n" && exit 0
	# check option to check dependents
	[ "$OPT_REVDEPS" == "YES" ] && do_check_reversedeps $pkg_name && exit 0
	# check if package path supplied
	[ "$PACK_PATH" != "" ] && pkg_path=$pkg_path/$PACK_PATH
	# do your thing!
	update_list ; do_run_build $pkg_name $pkg_path $OPT_INSTALL
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
