#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.net
# - get/execute slackbuild scripts from SlackBuilds.org (supports dependencies)

TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$TOOL_NAME
	[ -r $config ] && source $config && break
done

# find libraries
[ ! -f $TOOL_PATH/libmy1slack ] &&
	echo "Cannot find libmy1slack!" && exit 1
. $TOOL_PATH/libmy1slack
must_have_file $TOOL_PATH/libmy1get
. $TOOL_PATH/libmy1get

# temporary path
TOOL_USER=`whoami`
TOOL_TEMP="/tmp/$TOOL_USER/$TOOL_NAME"

# tool specific
TOOL_DESC="my1 SlackBuilds.org Executor"
TOOL_VERS="2019.07.00"
TOOL_PDIR=`dirname $TOOL_PATH`
WORK_PATH="$TOOL_PDIR/slackbuilds"
CURR_PATH=`pwd -P`
PACK_PATH="test-pack" # default package path
[ -z "$SLACKNAME" ] && [ -n "$ARCH" ] && [ "$ARCH" = "x86_64" ] &&
	SLACKNAME="slackware64" || SLACKNAME="slackware"
[ -z "$SLACKVERS" ] && [ -n "$VERS" ] && SLACKVERS=$VERS || SLACKVERSE="current"
call_setup
BUILD_URL="http://slackbuilds.org/slackbuilds/$SLACKVERS"
BUILDLIST="SLACKBUILDS.TXT"
BUILDPATH="$TOOL_TEMP"
BUILDFULL="$BUILDPATH/$BUILDLIST"

# global options & settings
OPT_INSTALL="NO"
OPT_DEPENDS="NO"
OPT_EXECUTE="NO"
OPT_CLEANUP="NO"
OPT_WARNOLD="NO"
OPT_LISTOLD="NO"
OPT_ALL_NEW="NO"
OPT_CHK_SYS="NO"
OPT_BUILDUP="NO"
OPT_VERBOSE="NO"
OPT_REVDEPS="NO"
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $TOOL_NAME [options] <pkg_name>
Options:
  --path|-p </path/to/slackbuilds>
  --pack|-f </sub/path/to/package/group>
  --depends|-d : Check (and build) dependencies
  --update |-u : Fetch new build script if available
  --install|-i : Install when (and if) the build completes
  --execute|-x : Execute build (else, simply check @ dry-run)
  --buildup|-b : Force build even already installed
  --verbose|-v : Show more information (for --check-installed)
  --update-local|-a : Update all locally saved build scripts
  --reverse-deps|-r : Check reverse dependencies
  --check-installed|-c : Compare installed version against build script
SETHELPMSG`

info_build()
{
	local fun_name="info_build()"
	local chk_file=$1 # full path name to SlackBuild
	local pkg_name=`basename $chk_file .SlackBuild`
	local pkg_path=`dirname $chk_file`
	local inf_file=$pkg_path/$pkg_name.info
	must_have_file $inf_file "$fun_name: Cannot find info '$inf_file'!"
	local chk_name=`basename $pkg_path`
	[ "$chk_name" != "$pkg_name" ] &&
		error_exit "$fun_name: Path mismatch? {$chk_name/$pkg_name}\n\n"
	local pkg_pack=`dirname $pkg_path`
	local pkg_info=`cat $inf_file`
	# get package version
	local pkg_vers=`echo "$pkg_info" | grep VERSION=`
	pkg_vers=`echo "$pkg_vers" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name
	local pkg_file=`echo "$pkg_info" | grep DOWNLOAD=`
	pkg_file=`echo "$pkg_file" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name x86_64
	local pkg_fil2=`echo "$pkg_info" | grep DOWNLOAD_x86_64=`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get dependencies
	pkg_deps=`echo "$pkg_info" | grep REQUIRES= | sed 's/^.*="\(.*\)".*$/\1/'`
	pkg_deps=`echo $pkg_deps | tr ' ' ','`
	# format info
	echo -n "$pkg_name;$pkg_vers;$pkg_pack;$pkg_file;$pkg_fil2;$pkg_deps"
}

find_build()
{
	local fun_name="find_build()"
	local pkg_name=$1
	local pkg_path=$WORK_PATH
	must_have_path $pkg_path "$fun_name: Cannot find path '$pkg_path'!"
	local chk_file=`find $pkg_path -type f -name "${pkg_name}.SlackBuild"`
	echo -n "$chk_file"
}

list_build()
{
	local fun_name="list_build()"
	local chk_path=$WORK_PATH
	must_have_path $chk_path "$fun_name: Cannot find path '$chk_path'!"
	local chk_list=`find $chk_path -type f -name "*.SlackBuild"`
	echo -n "$chk_list"
}

do_list_local()
{
	local fun_name="do_list_local()"
	local chk_path=$1
	local chk_full=`list_build`
	[ -z "$chk_full" ] && info_msg --no-tag "No scripts found!\n\n" && return
	info_msg --no-tag "List all buildscripts in '$chk_path':\n\n"
	for that in $chk_full ; do
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		local chk_info=`info_build $that`
		trap - ERR
		show_build $chk_info
	done ; echo
}

do_list_update() #cleaned0
{
	local pkg_temp="$TOOL_TEMP"
	local pkg_root="$BUILD_URL"
	local pkg_list="$BUILDLIST"
	local cur_path=`pwd`
	# prepare path for list
	if [ ! -d $pkg_temp ] ; then
		mkdir -p $pkg_temp 2>/dev/null
		[ $? -ne 0 ] && error_exit "Cannot create path '$pkg_temp'!\n\n"
	fi
	# check if not found OR nothing modified last 120 minutes
	local new_list="-mmin -120"
	[ "$OPT_LISTOLD" = "YES" ] && new_list=""
	local chk_list=`find $pkg_temp -name $pkg_list $new_list 2>/dev/null`
	if [ "$chk_list" == "" ]; then
		cd $pkg_temp
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			rm -rf $pkg_list $pkg_list.gz # just in case, delete old one
			do_download ${pkg_root}/$pkg_list.gz $pkg_list.gz
			[ ! -r "$pkg_list.gz" ] &&
				error_exit "Cannot download $pkg_list.gz!\n\n"
			gzip -d $pkg_list.gz
		else
			[ -r "$pkg_list" -a "$OPT_WARNOLD" = "YES" ] &&
				warn_msg "NOT using latest $pkg_list!\n"
		fi
		cd $cur_path
	fi
	# we must have it!
	local tmp_list="$BUILDFULL"
	[ ! -r "$tmp_list" ] && error_exit "File '$tmp_list' not found!\n\n"
}

do_list_search() #cleaned0
{
	local pkg_name=$1
	local pkg_list=$BUILDFULL
	local pkg_root=$BUILD_URL
	# look for pkg_name
	local pkg_test="SLACKBUILD NAME: $pkg_name"
	local pkg_text=`cat $pkg_list|grep -e "${pkg_test}$" -A10`
	[ "$pkg_text" == "" ] &&
		error_exit "Cannot find script for '$pkg_name'!\n\n"
	# extract info
	pkg_test=`echo "$pkg_text" | grep 'SLACKBUILD NAME'`
	pkg_test=`echo "$pkg_test" | sed 's/.*: \(.*\)$/\1/'`
	[ "$pkg_test" != "$pkg_name" ] &&
		error_exit "Name error? '$pkg_test'/'$pkg_name'!\n\n"
	local pkg_load=`echo "$pkg_text" | grep 'SLACKBUILD LOCATION'`
	pkg_load=`echo "$pkg_load" | sed 's/.*: \.\(.*\)$/\1/'`
	pkg_load="${pkg_root}${pkg_load}.tar.gz"
	local pkg_vers=`echo "$pkg_text" | grep 'SLACKBUILD VERSION'`
	pkg_vers=`echo "$pkg_vers" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_file=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD:'`
	pkg_file=`echo "$pkg_file" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_fil2=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD_x86_64'`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_deps=`echo "$pkg_text" | grep 'SLACKBUILD REQUIRES'`
	pkg_deps=`echo "$pkg_deps" | sed 's/.*: \(.*\)$/\1/'`
	echo -n "$pkg_load;$pkg_vers;$pkg_file;$pkg_fil2;$pkg_deps"
}

show_build()
{
	local fun_name="show_build()"
	local chk_info=$1
	local chk_name=`echo "$chk_info" | cut -d';' -f1`
	local chk_vers=`echo "$chk_info" | cut -d';' -f2`
	local chk_pack=`echo "$chk_info" | cut -d';' -f3`
	chk_pack=`echo $chk_pack | sed "s|$WORK_PATH||"`
	local chk_deps=`echo "$chk_info" | cut -d';' -f6`
	# setup trap for do_list_search
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local lst_info=`do_list_search $chk_name`
	trap - ERR
	local lst_vers=`echo "$lst_info" | cut -d';' -f2`
	# show it!
	head_msg "Package: $chk_name ($lst_vers)"
	[ "$chk_pack" != "" ] && info_msg --no-tag " [Pack: $chk_pack]"
	[ "$chk_vers" != "" -a "$chk_vers" != "$lst_vers" ] &&
		head_msg ", Local Version: {$chk_vers}"
	echo ; [ "$chk_deps" != "" ] &&
		warn_msg --no-tag "-- Requires: $chk_deps\n"
}

do_fetch_ware() #cleaned0
{
	local pkg_info=$1
	local pkg_path=$2
	# check if tarball available?
	local pkg_file=`echo "$pkg_info" | cut -d';' -f3`
	local pkg_fil2=`echo "$pkg_info" | cut -d';' -f4`
	if [ "$pkg_file" != "${pkg_file#* }" ] ; then
		local tmp_file
		for chk in $pkg_file ; do
			[ "$tmp_file" = "" ] && tmp_file=$chk && continue
			local tmp_ball=`basename $chk`
			[ ! -f "${pkg_path}/${tmp_ball}" ] &&
				do_loadball $pkg_path $chk
		done
		pkg_file=$tmp_file
	fi
	local pkg_ball=`basename $pkg_file`
	[ ! -f "${pkg_path}/${pkg_ball}" ] &&
		do_loadball $pkg_path $pkg_file
	if [ "$pkg_fil2" != "" ] ; then
		pkg_ball=`basename $pkg_fil2`
		[ ! -f "${pkg_path}/${pkg_ball}" ] &&
			do_loadball $pkg_path $pkg_fil2
	fi
}

do_fetch_ball() #cleaned0
{
	local pkg_info=$1
	local pkg_load=`echo "$pkg_info" | cut -d';' -f1`
	local pkg_test=`dirname $pkg_load`
	local pkg_text=`basename $pkg_load`
	local pkg_temp="$TOOL_TEMP"
	local pkg_path=$2
	local cur_path=`pwd`
	cd $pkg_temp
	wget --spider $pkg_test >/dev/null 2>&1
	[ $? -ne 0 ] && error_exit "Cannot get $pkg_test!\n\n"
	# remove old tarballs?
	rm -rf ${pkg_text}*
	do_download $pkg_load $pkg_text 2>/dev/null
	[ ! -r "$pkg_text" ] && error_exit "Cannot download $pkg_load!\n\n"
	cd $cur_path
	local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
	pkg_test=$pkg_temp/$pkg_text
	[ ! -d "$pkg_path" ] && mkdir -p $pkg_path
	cd $pkg_path
	# remove old?
	rm -rf $pkg_name
	# extract accordingly?
	tar xf $pkg_test 2>/dev/null
	[ $? -ne 0 ] && error_exit "Cannot extract $pkg_test!\n\n"
	cd $cur_path
}

do_fetch() #cleaned0
{
	local pkg_name=$1 # package name
	local pkg_path=$2 # storage path
	local top_path=$WORK_PATH
	# update list
	do_list_update
	# setup trap for do_list_search
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local chk_info=`do_list_search $pkg_name`
	trap - ERR
	local chk_vers=`echo "$chk_info" | cut -d';' -f2`
	# check if local version is available
	# setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_info pkg_vers
	local pkg_file=`find_build $pkg_name`
	trap - ERR
	if [ "$pkg_file" != "" ] ; then
		# setup trap for info_build
		trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
		pkg_info=`info_build $pkg_file`
		trap - ERR
		if [ "$pkg_info" != "" ] ; then
			pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
			# we have one locally, use that path!
			pkg_path=`echo "$pkg_info" | cut -d';' -f3`
		fi
	fi
	# do we need to fetch?
	if [ "$pkg_vers" != "$chk_vers" ] ; then
		# if no local OR we want a clean one
		if [ "$pkg_vers" == "" -o "$OPT_CLEANUP" == "YES" ] ; then
			do_fetch_ball $chk_info $pkg_path
		fi
	fi
	# re-check script, do we need to download source?
	# setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	pkg_file=`find_build $pkg_name`
	trap - ERR
	[ "$pkg_file" = "" ] &&
		error_exit "$fun_name: Failed to fetch $pkg_name?\n\n"
	# setup trap for info_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	pkg_info=`info_build $pkg_file`
	trap - ERR
	[ "$pkg_info" = "" ] &&
		error_exit "$fun_name: Cannot find info for $pkg_name?\n\n"
	do_fetch_ware $pkg_info `dirname $pkg_file`
}

do_build() #cleaned0
{
	local pkg_file=$1
	must_have_file $pkg_file "Build script '$pkg_file' not found!"
	local pkg_name=`basename $pkg_file .SlackBuild`
	local pkg_path=`dirname $pkg_file`
	local pkg_vers=$2
	local opt_inst=$3
	local cur_path=`pwd`
	# check if already installed? should check version as well?
	local pkg_base=`find_install $pkg_name`
	if [ "$pkg_base" != "" ] ; then
		local chk_info=`get_pkg_info $pkg_base`
		local chk_vers=`echo "$chk_info" | cut -d' ' -f2`
		# check version - stop if exactly the same!
		if [ "$chk_vers" == "$pkg_vers" ] ; then
			echo "Package $pkg_base installed."
			[ "$OPT_BUILDUP" == "NO" ] && return
		fi
		# continue, but do not install?
		opt_inst=""
	fi
	# only root can actually build!
	must_be_root "Must run as root! ($pkg_name-$pkg_vers)"
	# start build?
	local log_file=$TOOL_TEMP/${pkg_name}.buildlog
	cd $pkg_path
	info_msg "Building '$pkg_name' ... "
	sh ${pkg_name}.SlackBuild >$log_file 2>&1
	[ $? -ne 0 ] && error_exit "Error building '$pkg_name'!\n\n"
	info_msg --no-tag "done!\n"
	cd $cur_path
	local pkg_ball=`cat $log_file | tail -n 2 | grep Slackware`
	pkg_ball=`echo "$pkg_ball" | sed 's/^.*package \(.*\) created.*$/\1/'`
	must_have_file $pkg_ball "Cannot find package '$pkg_ball'!"
	if [ "$opt_inst" == "--install" ] ; then
		# go install!
		info_msg "Installing '$pkg_ball'... "
		installpkg $pkg_ball >>$log_file 2>&1
		[ $? -ne 0 ] && error_exit "Error installing '$pkg_ball'!\n\n"
		info_msg --no-tag "done!\n"
	else
		# copy built package & build log to cur_path
		info_msg "Copying '$pkg_ball' to '$cur_path'... "
		local chk_perm=`get_path_owner $cur_path`
		mv $pkg_ball $cur_path
		pkg_ball=$cur_path/`basename $pkg_ball`
		mv $log_file $cur_path
		log_file=$cur_path/`basename $log_file`
		if [ "$chk_perm" != "" ] ; then
			chown $chk_perm $pkg_file $log_file
		fi
		info_msg --no-tag "done!\n"
	fi
}

do_build_this() #cleaned0
{
	local fun_name="do_build_this()"
	local pkg_name=$1
	local pkg_path=$2
	local opt_inst=$3
	local sav_path=$pkg_path
	# fetch build
	do_fetch $pkg_name $pkg_path
	# setup trap for find_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_file=`find_build $pkg_name`
	trap - ERR
	[ "$pkg_file" = "" ] && error_exit "Failed to fetch $pkg_name?\n\n"
	# setup trap for info_build
	trap 'error_exit "*** $fun_name FAILED at line $LINENO ***\n\n"' ERR
	local pkg_info=`info_build $pkg_file`
	trap - ERR
	local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
	local pkg_pack=`echo "$pkg_info" | cut -d';' -f3`
	local pkg_deps=`echo "$pkg_info" | cut -d';' -f6`
	# show this before dependencies if not really building
	if [ "$OPT_EXECUTE" != "YES" ]; then
		show_build $pkg_name $pkg_vers $pkg_pack $pkg_deps
	fi
	# iterate through dependencies, if requested
	if [ "$OPT_DEPENDS" == "YES" ]; then
		# some deps asks to refer to README
		[ "$pkg_deps" == "%README%" ] && pkg_deps=""
		pkg_deps=`echo $pkg_deps | tr ',' ' '`
		for pkg in $pkg_deps ; do
			do_build_this $pkg $sav_path --install
		done
	fi
	# build only if explicitly requested
	[ "$OPT_EXECUTE" == "YES" ] &&
		do_build $pkg_file $pkg_vers $opt_inst
}

do_update_all()
{
	local chk_path=$1
	local chk_full=`list_build`
	[ -z $chk_full ] && info_msg --no-tag "No scripts found!\n\n" && return
	local chk_list=`do_list_update`
	local pkg_root=`echo "$chk_list" | cut -d';' -f1`
	local pkg_list=`echo "$chk_list" | cut -d';' -f2`
	info_msg --no-tag "Updating buildscripts in '$chk_path':\n"
	for full in $chk_full ; do
		local chk_file=`echo "$full" | cut -d';' -f1`
		local the_path=`dirname $chk_file`
		local tmp_path=`dirname $the_path`
		local tmp_name=`basename $the_path`
		local chk_name=`echo "$full" | cut -d';' -f2`
		[ "$chk_name" != "$tmp_name" ] &&
			error_exit "Invalid package name! {$chk_name/$tmp_name}\n\n"
		# search list
		local pkg_info=`do_list_search $pkg_list $chk_name $pkg_root`
		local pkg_vers=`echo "$pkg_info" | cut -d';' -f2`
		local chk_vers=`echo "$full" | cut -d';' -f3`
		# fetch build... IF different versions
		if [ "$chk_vers" != "$pkg_vers" -a "$OPT_CLEANUP" == "YES" ] ; then
			do_fetch_ball $pkg_info $tmp_path
			chk_vers=$pkg_vers
		fi
		local pkg_path=$tmp_path/$pkg_name
		# have we got the buildscript?
		local pkg_exec=${pkg_path}/${pkg_name}.SlackBuild
		[ ! -f "$pkg_exec" ] && error_exit "Script '$pkg_exec' not found!\n\n"
		# do we need to download?
		do_fetch_ware $pkg_info $pkg_path
		# some deps asks to refer to README
		local pkg_deps=`echo "$pkg_info" | cut -d';' -f5`
		[ "$pkg_deps" == "%README%" ] && pkg_deps=""
		# show info
		echo -n "Package: $pkg_name ($pkg_vers)"
		[ "$chk_vers" != "$pkg_vers" ] &&
			echo -n ", Local Version: {$chk_vers}"
		pkg_path=`echo $pkg_path | sed "s|$chk_path||"`
		echo " [Path: $pkg_path]"
	done ; echo
}

do_check_installed() #cleaned
{
	local chk_path=$1
	local chk_list=`list_build`
	for full in $chk_list ; do
		local pkg_file=`echo "$full" | cut -d';' -f1`
		local tmp_path=`dirname $pkg_file`
		local pkg_path=`dirname $tmp_path`
		local pkg_name=`basename $tmp_path`
		local tmp_name=`echo "$full" | cut -d';' -f2`
		[ "$tmp_name" != "$pkg_name" ] &&
			error_exit "Invalid package name! {$tmp_name/$pkg_name}\n\n"
		local pkg_vers=`echo "$full" | cut -d';' -f3`
		# look for installed only!
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
		local pkg_root=`ls /var/log/packages | grep -e "$pkg_temp"`
		[ "$pkg_root" == "" ] && continue;
		# check version
		pkg_temp=`echo $pkg_root | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\1/'`
		pkg_temp=`echo $pkg_temp | sed 's/\(.*\)-\(.*\)/\2/'`
		[ "$pkg_temp" == "$pkg_vers" -a "$OPT_VERBOSE" != "YES" ] && continue;
		# show if not the same version
		echo -n "Installed: {$pkg_root}, "
		echo -n "Build: $pkg_name ($pkg_vers)"
		pkg_path=`echo $pkg_path | sed "s|$chk_path||"`
		echo " [Path: $pkg_path]"
	done ; echo
}

do_check_reversedeps()
{
	local pkg_name=$1
	local pkg_path=$2
	local chk_path=$CURR_PATH
	local sav_path=$pkg_path
}

process_command()
{
	local pkg_name pkg_path
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--install|-i)
				OPT_INSTALL="--install"
				;;
			--depends|-d)
				OPT_DEPENDS="YES"
				;;
			--reverse-deps|-r)
				OPT_REVDEPS="YES"
				;;
			--execute|-x)
				OPT_EXECUTE="YES"
				;;
			--update|-u)
				OPT_CLEANUP="YES"
				OPT_WARNOLD="YES"
				;;
			--update-local|-a)
				OPT_ALL_NEW="YES"
				OPT_CLEANUP="YES"
				;;
			--check-installed|-c)
				OPT_CHK_SYS="YES"
				;;
			--verbose|-v)
				OPT_VERBOSE="YES"
				;;
			--use-list|-l)
				OPT_LISTOLD="YES"
				;;
			--buildup|-b)
				OPT_BUILDUP="YES"
				;;
			--path|-p)
				shift
				must_have_path $1 "Invalid path '$1'!"
				WORK_PATH=`cd $1;pwd`
				;;
			--pack|-f)
				shift
				PACK_PATH="$1"
				;;
			-*)
				echo -e "$MSG_THISHELP\n"
				echo -e "[ERROR] Unknown option '$1'!\n" ; exit 1
				;;
			*)
				[ "$pkg_name" != "" ] &&
					echo -e "[ERROR] Multiple package? [$pkg_name]\n" && exit 1
				pkg_name="$1"
				;;
		esac
		shift
	done
	# check if path is valid?
	pkg_path=$WORK_PATH
	must_have_path $pkg_path "Path '$pkg_path' not found! Aborting!"
	# check option to list existing build script(s) against existing list
	[ "$OPT_LISTOLD" == "YES" ] && do_list_local $WORK_PATH && exit 0
	# check if package path supplied
	[ "$PACK_PATH" != "" ] && pkg_path=$pkg_path/$PACK_PATH
	# check option to check installed build script(s)
	[ "$OPT_CHK_SYS" == "YES" ] && do_check_installed $pkg_path && exit 0
	# check option to update ALL build scripts found
	[ "$OPT_ALL_NEW" == "YES" ] && do_update_all $pkg_path && exit 0
	# check if name supplied
	[ "$pkg_name" == "" ] && echo -e "$MSG_THISHELP\n" && exit 0
	# check option to check dependents
	[ "$OPT_REVDEPS" == "YES" ] &&
		do_check_reversedeps $pkg_name $pkg_path && exit 0
	# do your thing!
	do_build_this $pkg_name $pkg_path $OPT_INSTALL
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
