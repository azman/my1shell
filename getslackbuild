#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.net
# - get/execute slackbuild scripts from SlackBuilds.org
# - builds dependencies (based on .info file) if requested

# standard tool info
MY1TOOL="$(basename $0 .sh)"
MY1PATH="$(cd $(dirname $0);pwd)"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1TOOL
	[ -r $config ] && source $config && break
done

# my1slack tool specific
MY1_TOOLNAME="my1 SlackBuilds.org Executor"
MY1_TOOLVERS="2015.05.00"
MY1_BUILDDIR=${MY1_BUILDDIR:="$(dirname $MY1PATH)/slackbuilds"}
MY1_THISPATH=$(pwd -P)
MY1_PACKPATH=""
[ -z "$SLACKVERS" ] && [ -n "$RELEASE" ] && SLACKVERS=$RELEASE
SLACKVERS=${SLACKVERS:=""}
if [ "$SLACKVERS" == "" ]; then
	SLACKVERS=$(cat /etc/slackware-version)
	SLACKVERS=${SLACKVERS#Slackware }
	SLACKVMAJ=${SLACKVERS%%.*}
	SLACKVMIN=${SLACKVERS#*.}
	[ "${SLACKVMIN//./}" != "$SLACKVMIN" ] && SLACKVMIN=${SLACKVMIN%%.*}
	SLACKVERS=${SLACKVMAJ}.${SLACKVMIN}
fi

# global options & settings
OPT_INSTALL=""
OPT_DEPENDS="NO"
OPT_EXECUTE="NO"
OPT_GETTHAT="NO"
OPT_CLEANUP="NO"
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1TOOL [options] <pkg_name>
Options:
  --path </path/to/slackbuilds>
  --pack </sub/path/to/package/group>
  --lookup  : Download stuffs from Slackbuilds.org
  --install : Install when (and if) the build completes
  --depends : Check (and build) dependencies
  --cleanup : Clears old Slackbuilds and recheck (implies --lookup)
  --execute : Execute build (else, simply check @ dry-run)
SETHELPMSG
)

function do_download()
{
	local fname="$1"
	local label="$2"
	local cpath="$(pwd)"
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -n "Downloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!\n" && exit 1
	echo -ne "\b\b\b\b DONE!\n"
}

function do_lookup()
{
	local pkg_vers=$1
	local pkg_name=$2
	local pkg_root="http://slackbuilds.org/slackbuilds/$pkg_vers"
	local pkg_temp="/tmp/$(whoami)/my1/$MY1TOOL"
	local pkg_list="SLACKBUILDS.TXT"
	# prepare temp
	mkdir -p $pkg_temp 2>/dev/null
	[ $? -ne 0 ] &&
		echo -e "[ERROR] Cannot create path '$pkg_temp'!\n" && exit 1
	cd $pkg_temp
	# if not found OR nothing modified last 120 minutes
	if [ "$(find $pkg_list -mmin -120 2>/dev/null)" == "" ]; then
		rm -rf $pkg_list $pkg_list.gz # just in case, delete old one
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download ${pkg_root}/$pkg_list.gz $pkg_list.gz
		fi
		[ ! -r "$pkg_list.gz" ] &&
			echo -e "[ERROR] Cannot download $pkg_list.gz!\n" >&2 && exit 1
		gzip -d $pkg_list.gz
	fi
	# we must have it!
	[ ! -r "$pkg_list" ] &&
		echo -e "[ERROR] File '$pkg_list' not found!\n" >&2 && exit 1
	# look for pkg_name
	local pkg_test="SLACKBUILD NAME: $pkg_name"
	local pkg_text="$(cat $pkg_list|grep -e "${pkg_test}$" -A6|tr '\n' ';')"
	[ "$pkg_text" == "" ] &&
		echo -e "[ERROR] Cannot find script for '$pkg_name'!\n" >&2 && exit 1
	local pkg_path=${pkg_text##*SLACKBUILD LOCATION: }
	pkg_path=${pkg_path%%;*}
	pkg_path=${pkg_path//./$pkg_root}.tar.gz
	pkg_name=${pkg_text##*SLACKBUILD NAME: }
	pkg_name=${pkg_name%%;*}
	pkg_test=${pkg_name}.tar.gz
	local pkg_file=${pkg_text##*SLACKBUILD DOWNLOAD: }
	pkg_file=${pkg_file%%;*}
	pkg_file=${pkg_file%% *}
	# look for it!
	wget --spider $pkg_path >/dev/null 2>&1
	[ $? -ne 0 ] && echo -e "[ERROR] Cannot find $pkg_path!\n" >&2 && exit 1
	do_download $pkg_path $pkg_test 2>/dev/null
	[ ! -r "$pkg_test" ] &&
		echo -e "[ERROR] Cannot download $pkg_test!\n" >&2 && exit 1
	cd - >/dev/null
	pkg_path=$pkg_temp/$pkg_test
	# extract accordingly?
	tar xf $pkg_path 2>/dev/null
	[ $? -ne 0 ] && echo -e "[ERROR] Cannot extract $pkg_path!\n" >&2 && exit 1
	# download source tarball
	do_loadball $pkg_name $pkg_file
	return 0
}

function do_loadball()
{
	local pkg_path=$1
	local pkg_file=$2
	local pkg_ball=$(basename $pkg_file)
	[ ! -d $pkg_path ] &&
		echo -e "[ERROR] Cannot find $pkg_path!\n" >&2 && exit 1
	wget --spider $pkg_file >/dev/null 2>&1
	[ $? -ne 0 ] && echo -e "[ERROR] Cannot get $pkg_file!\n" >&2 && exit 1
	cd $pkg_path
	do_download $pkg_file $pkg_ball 2>/dev/null
	[ ! -r $pkg_ball ] &&
		echo -e "[ERROR] Cannot download $pkg_ball!\n" >&2 && exit 1
	cd - >/dev/null
	return 0
}

function get_userngrp()
{
	local chk_this=$1
	local chk_path
	local chk_user chk_grpn
	[ "$chk_this" == "." ] && chk_this=$(pwd -P)
	[ "$chk_this" == ".." ] && chk_this=$(dirname $(pwd -P))
	[ ! -r "$chk_this" ] && echo -e "Cannot read '$chk_this'!" 1>&2 && return
	chk_path=$(cd $(dirname $chk_this);pwd)
	chk_this=$(basename $chk_this)
	chk_user=$(ls -l "${chk_path}/" | grep -e "${chk_this}$")
	set -- $chk_user
	chk_user=$3
	chk_grpn=$4
	echo -n "$chk_user:$chk_grpn"
}

function do_build()
{
	local pkg_name=$1
	local opt_inst=$2
	local chk_path=${MY1_THISPATH}
	local pkg_file pkg_ball pkg_deps log_file inf_file
	[ ! -d "$MY1_BUILDDIR" ] &&
		echo -e "Path '$MY1_BUILDDIR' not found!\n" && exit 1
	cd $MY1_BUILDDIR
	if [ "$OPT_CLEANUP" == "YES" ] ; then
		rm -rf ${pkg_name}/
	fi
	if [ ! -f ${pkg_name}/${pkg_name}.SlackBuild ] ; then
		if [ "$OPT_GETTHAT" == "YES" ] ; then
			do_lookup ${SLACKVERS} $pkg_name
		else
			echo -e "SlackBuild for '$pkg_name' not found!\n" ; exit 1
		fi
	fi
	inf_file="${pkg_name}/${pkg_name}.info"
	[ ! -f ${inf_file} ] &&
		echo -e "[ERROR] Info file for '$pkg_name' not found!\n" && exit 1
	# check if tarball available?
	pkg_file=$(cat ${inf_file} | grep DOWNLOAD=)
	pkg_file=${pkg_file##*=\"}
	pkg_file=${pkg_file%\"*}
	pkg_file=${pkg_file%% *}
	pkg_ball=$(basename $pkg_file)
	[ "$OPT_GETTHAT" == "YES" ] &&
		[ ! -f "${pkg_name}/${pkg_ball}" ] && do_loadball $pkg_name $pkg_file
	# find deps
	pkg_deps=$(cat ${inf_file} | grep REQUIRES)
	pkg_deps=${pkg_deps#*=\"}
	pkg_deps=${pkg_deps%\"*}
	# some deps asks to refer to README
	[ "$pkg_deps" == "%README%" ] && pkg_deps=""
	# show this before dependencies if not building
	if [ "$OPT_EXECUTE" != "YES" ]; then
		echo -n "Package: $pkg_name"
		[ "$pkg_deps" != "" ] && echo -n ", Requires: $pkg_deps" ; echo
	fi
	# iterate through dependencies, if requested
	if [ "$OPT_DEPENDS" == "YES" ]; then
		for pkg in $pkg_deps ; do
			do_build $pkg --install
			cd $chk_path
		done
	fi
	# build only if explicitly requested
	if [ "$OPT_EXECUTE" == "YES" ]; then
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
		local pkg_base=$(ls /var/log/packages | grep -e "$pkg_temp")
		# check if already installed!
		#@DEBUG@echo "[$pkg_name] => [$pkg_base]!" && return
		[ "$pkg_base" != "" ] && echo "[$pkg_name] Installed!" && return
		[ $UID -ne 0 ] && echo -e "Must run as root!\n" && exit 1
		log_file=${chk_path}/${pkg_name}.buildlog
		cd ${pkg_name}
		echo -n "Building '$pkg_name' ... "
		sh ${pkg_name}.SlackBuild >${log_file} 2>&1
		[ $? -ne 0 ] && echo -e "Error building '$pkg_name'!\n" && exit 1
		echo "done!"
		local pkg_file="$(cat $log_file | tail -n 2 | grep Slackware)"
		pkg_file=${pkg_file#*package }
		pkg_file=${pkg_file% created*}
		if [ "$opt_inst" == "--install" ] ; then
			echo -n "Installing '$pkg_file'... "
			installpkg $pkg_file >>${log_file} 2>&1
			[ $? -ne 0 ] &&
				echo -e "Error installing '$pkg_file'!\n" && exit 1
			echo "done!"
		else
			local chk_perm=$(get_userngrp $chk_path)
			mv $pkg_file $chk_path
			pkg_file=${chk_path}/$(basename $pkg_file)
			if [ "$chk_perm" != "" ] ; then
				chown $chk_perm $pkg_file $log_file
			fi
		fi
	fi;
	cd $chk_path
}

function process_command()
{
	local pkg_name
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--install|-i)
				OPT_INSTALL="$1"
				;;
			--depends|-d)
				OPT_DEPENDS="YES"
				;;
			--execute|-x)
				OPT_EXECUTE="YES"
				;;
			--lookup|-l)
				OPT_GETTHAT="YES"
				;;
			--cleanup|-c)
				OPT_CLEANUP="YES"
				OPT_GETTHAT="YES"
				;;
			--path|-p)
				shift
				[ ! -d "$1" ] &&
					echo -e "[ERROR] Invalid path!? [$1]\n" && exit 1
				MY1_BUILDDIR="$(cd $1;pwd)"
				;;
			--pack)
				shift
				MY1_PACKPATH="$1"
				;;
			-*)
				echo -e "$MSG_THISHELP\n"
				echo -e "[ERROR] Unknown option '$1'!\n" ; exit 1
				;;
			*)
				[ "$pkg_name" != "" ] &&
					echo -e "[ERROR] Multiple package? [$pkg_name]\n" && exit 1
				pkg_name="$1"
				;;
		esac
		shift
	done
	# check if package path supplied
	[ "$MY1_PACKPATH" != "" ] && MY1_BUILDDIR=${MY1_BUILDDIR}/${MY1_PACKPATH}
	[ ! -d ${MY1_BUILDDIR} ] && mkdir -p ${MY1_BUILDDIR}
	# check if name supplied
	[ "$pkg_name" == "" ] && echo -e "$MSG_THISHELP\n" && exit 0
	# do your thing!
	do_build $pkg_name ${OPT_INSTALL}
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1TOOL - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
