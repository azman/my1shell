#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.org
# - get/execute slackbuild scripts from SlackBuilds.org (supports dependencies)

TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH ; pwd`
# look for config file
for conf in `pwd` $HOME; do
	conf=$conf/.$TOOL_NAME
	[ -r $conf ] && . $conf && break
done
# look for library scripts
source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}
source_lib libmy1slack
source_lib libmy1echo
source_lib libmy1file
source_lib libmy1get
# temporary path
TOOL_USER=`whoami`
TOOL_TEMP="/tmp/$TOOL_USER/$TOOL_NAME"
# tool specific
TOOL_DESC="my1 SlackBuilds.org Executor"
TOOL_VERS="2019.11.00"
TOOL_HELP=`cat <<SETHELPMSG
Usage:
  $TOOL_NAME [task] [options]
Task:
  help      : Show this help message
  list      : List all local scripts
  find      : Finds a package in list (and optionally all deps)
  update    : Updates package list in work path
  fetch     : Fetch a package (and optionally all deps)
  build     : Build a package (and optionally all deps)
  fresh     : Update all local scripts
  check     : Check installed package version against list
  check-rev : Check reverse dependencies
Options:
  --path | -p </path/to/slackbuilds>
  --pack | -g </sub/path/to/package/group>
  --depends | -d : Fetch (and build) dependencies
  --install | -i : Install when (and if) the build completes
  --execute | -x : Execute build (else, simply check @ dry-run)
  --buildup | -b : Force build even already installed
  --verbose | -v : Show more information (for --check-installed)
  --new          : Force fresh download of everything
  (*)            : First option without '-' is considered a package name
SETHELPMSG`
TOOL_PDIR=`dirname $TOOL_PATH`
WORK_PATH="$TOOL_PDIR/slackbuilds" # default slackbuilds path
PACK_PATH="test-pack" # default package path
CURR_PATH=`pwd -P`
BUILDLIST="SLACKBUILDS.TXT"
BUILDPATH="$TOOL_TEMP"
# setup default BUILD_URL
select_url()
{
	local root=$1
	local vers=`find_slackvers $root`
	echo -n "http://slackbuilds.org/slackbuilds/$vers"
}
BUILD_URL=`select_url`

info_build() #DONE
{
	local func="info_build()"
	[ ! -z "${temp+x}" ] && error_exit "$func: Var 'temp' NOT defined!\n\n"
	local full=$1 # full path name to SlackBuild
	local name=`basename $full .SlackBuild`
	local path=`dirname $full`
	local that="$path/$name.info"
	must_have_file $that "$func: Cannot find info file '$that'!"
	local base=`basename $path`
	[ "$base" != "$name" ] && error_exit "$func: Mismatch!{$base/$name}\n\n"
	local pack=`dirname $path`
	local desc=`cat $that`
	# get package version
	local vers=`echo "$desc" | grep VERSION=`
	vers=`echo "$vers" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name
	local file=`echo "$desc" | grep DOWNLOAD=`
	file=`echo "$file" | sed 's/^.*="\(.*\)".*$/\1/'`
	file=`echo $file | tr ' ' ','`
	# get download file name x86_64
	local fil2=`echo "$desc" | grep DOWNLOAD_x86_64=`
	fil2=`echo "$fil2" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get dependencies
	local deps=`echo "$desc" | grep REQUIRES= | sed 's/^.*="\(.*\)".*$/\1/'`
	deps=`echo $deps | tr ' ' ','`
	# format info
	temp="$name;$pack;$vers;$file;$fil2;$deps"
}

find_build() #DONE
{
	local func="find_build()"
	local work=$1
	local name=$2
	local file=`find $work -type f -name "${name}.SlackBuild"`
	echo -n "$file"
}

list_build() #DONE
{
	local func="list_build()"
	local work=$1
	local list=`find $work -type f -name "*.SlackBuild" | sort -u`
	echo -n "$list"
}

find_opts() #DONE
{
	local flag=$1 ; shift
	local opts=$@
	local temp=`echo $opts | grep -- $flag`
	[ "$temp" != "" ] && echo -n "$flag"
}

search_list() #DONE
{
	local func="search_list()"
	[ ! -z "${temp+x}" ] && error_exit "$func: Var 'temp' NOT defined!\n\n"
	local name=$1
	local work=$2
	local that=$BUILDLIST
	local list=$work/$that
	# look for pkg_name
	local test="SLACKBUILD NAME: $name"
	local text=`cat $list | grep -e "${test}$" -A10`
	[ "$text" == "" ] && error_exit "$func: Cannot find '$name' in '$list'!\n\n"
	# extract info
	test=`echo "$text" | grep 'SLACKBUILD NAME'`
	test=`echo "$test" | sed 's/.*: \(.*\)$/\1/'`
	[ "$test" != "$name" ] && return 2
	local load=`echo "$text" | grep 'SLACKBUILD LOCATION'`
	load=`echo "$load" | sed 's/.*: \.\(.*\)$/\1/'` # remove leading ./
	load="${load}.tar.gz"
	local vers=`echo "$text" | grep 'SLACKBUILD VERSION'`
	vers=`echo "$vers" | sed 's/.*: \(.*\)$/\1/'`
	local file=`echo "$text" | grep 'SLACKBUILD DOWNLOAD:'`
	file=`echo "$file" | sed 's/.*: \(.*\)$/\1/'`
	file=`echo $file | tr ' ' ','`
	local fil2=`echo "$text" | grep 'SLACKBUILD DOWNLOAD_x86_64'`
	fil2=`echo "$fil2" | sed 's/.*: \(.*\)$/\1/'`
	local deps=`echo "$text" | grep 'SLACKBUILD REQUIRES'`
	deps=`echo "$deps" | sed 's/.*: \(.*\)$/\1/'`
	deps=`echo $deps | tr ' ' ','`
	# format info
	temp="$name;$load;$vers;$file;$fil2;$deps"
}

show_build() #DONE
{
	local func="show_build()"
	local info=$1
	local work=$2
	local opts=$3
	local temp
	if [ "$opts" = "--get-info" ] ; then
		info_build $info # this should be a full pathname of a build script
		info=$temp
		unset temp
	fi
	local name=`echo "$info" | cut -d';' -f1`
	local pack=`echo "$info" | cut -d';' -f2`
	local vers=`echo "$info" | cut -d';' -f3`
	pack=`echo $pack | sed "s|$work||"`
	local deps=`echo "$info" | cut -d';' -f6`
	search_list $name $work
	local that=`echo "$temp" | cut -d';' -f3`
	unset temp
	# show it!
	head_msg "Package: $name ($that)"
	[ "$pack" != "" ] && info_msg --no-tag " [Pack: $pack]"
	[ "$vers" != "" -a "$vers" != "$that" ] &&
		head_msg ", Local Version: {$vers}"
	echo ; [ "$deps" != "" ] && warn_msg --no-tag "-- Requires: $deps\n"
}

do_list_local() #DONE
{
	local func="do_list_local()"
	local work=$1
	local list=`list_build $work`
	[ -z "$list" ] && info_msg --no-tag "No scripts found!\n\n" && return
	info_msg --no-tag "Listing all buildscripts...\n\n"
	for that in $list ; do
		show_build $that $work --get-info
	done
}

do_find_list() #DONE
{
	local func="do_find_list()"
	local work=$1 ; shift
	local name=$1 ; shift
	local opts=$@
	local temp
	search_list $name $work
	[ -z "$temp" ] &&
		info_msg --no-tag "Package '$name' NOT found!\n\n" && return
	local vers=`echo "$temp" | cut -d';' -f3`
	local deps=`echo "$temp" | cut -d';' -f6`
	local test=`echo "$temp" | cut -d';' -f1`
	[ "$test" != "$name" ] && error_exit "Wrong name {'$name':'$test'}!\n\n"
	local file=`find_build $work $name`
	# show it!
	head_msg "Package: $name ($vers)"
	[ -f "$file" ] && head_msg ", Build: {"`basename $file`"}"
	echo ; [ "$deps" != "" ] && warn_msg --no-tag "-- Requires: $deps\n"
	# iterate through dependencies, if requested
	temp=`find_opts --depends $opts`
	if [ "$temp" != "" ]; then
		deps=`echo $deps | tr ',' ' '`
		local that
		for that in $deps ; do
			do_find_list $work $that $opts
		done
	fi
}

do_list_update() #DONE
{
	local work=$1
	local flag=$2
	local that=$BUILDLIST
	local list=$work/$that
	local site=$BUILD_URL
	local opts="-mtime -1" # last 24h
	local mesg=1
	[ "$flag" == "--fresh" ] && opts="-mmin -120" # last 2h
	[ "$flag" == "--new" -a -f "$list" ] && mv $list ${list}.BAK
	local what=`find $work -maxdepth 1 -name $that $opts 2>/dev/null`
	if [ "$what" = "" ]; then
		local curr=`pwd` ; cd $work
		wget --spider $site >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			rm -rf $list ${list}.gz # just in case, delete old ones
			do_download $site/${that}.gz ${that}.gz
			[ ! -r "${list}.gz" ] && error_exit "Cannot get ${that}.gz!\n\n"
			gzip -d ${list}.gz
			info_msg "-- File '$list' updated!\n"
			rm -f ${list}.BAK
			mesg=0
		fi
		cd $curr
	fi
	[ ! -r "$list" ] && error_exit "File '$list' not found!\n"
	[ "$flag" == "--new" -a -f "${list}.BAK" ] &&
		info_msg "-- Using old '$list'!\n" && mv ${list}.BAK $list && mesg=0
	[ $mesg -ne 0 ] && info_msg "Using '$list'!\n"
}

go_fetch_ware() #DONE
{
	local info=$1
	local load=`echo "$info" | cut -d';' -f2`
	local site=$BUILD_URL
	load=$site/$load # do this earlier? in info_build?
	local test=`dirname $load`
	local path=$2
	# check if tarball available?
	local file=`echo "$info" | cut -d';' -f4`
	local fil2=`echo "$info" | cut -d';' -f5`
	if [ "$file" != "${file//,/}" ] ; then # multiple files?
		local list=`echo $file | tr ',' ' '`
		local temp that
		for that in $list ; do
			[ "$temp" = "" ] && temp=$that && continue
			local what=`basename $that`
			[ ! -f "${path}/${what}" ] && do_loadball $path $that
		done
		file=$temp
	fi
	local ball=`basename $file`
	[ ! -f "${path}/${ball}" ] && do_loadball $path $file
	if [ "$fil2" != "" ] ; then
		ball=`basename $fil2`
		[ ! -f "${path}/${ball}" ] && do_loadball $path $fil2
	fi
}

go_fetch_ball() #DONE
{
	local info=$1
	local load=`echo "$info" | cut -d';' -f2`
	local site=$BUILD_URL
	load=$site/$load # do this earlier? in info_build?
	local test=`dirname $load`
	local text=`basename $load`
	local temp="$TOOL_TEMP"
	local pack=$2
	local curr=`pwd`
	[ ! -d "$TOOL_TEMP" ] && mkdir -p "$TOOL_TEMP"
	cd $temp
	wget --spider $site >/dev/null 2>&1
	[ $? -ne 0 ] && error_exit "Cannot wget $site!\n\n"
	# remove old tarballs?
	rm -rf ${text}*
	do_download $load $text 2>/dev/null
	[ ! -r "$text" ] && error_exit "Cannot download $load!\n\n"
	cd $curr
	local name=`echo "$info" | cut -d';' -f1`
	local vers=`echo "$info" | cut -d';' -f3`
	test=$temp/$text
	[ ! -d "$pack" ] && mkdir -p $pack
	cd $pack
	# remove old?
	rm -rf ${name}
	# extract accordingly?
	tar xf $test 2>/dev/null
	[ $? -ne 0 ] && error_exit "Cannot extract $test!\n\n"
	cd $curr
}

go_fetch() #DONE
{
	local func="go_fetch()"
	local work=$1
	local name=$2
	local pack=$3
	local flag=$4
	[ -z "$pack" ] && pack=$work || pack=$work/$pack
	local temp
	search_list $name $work
	local info=$temp
	unset temp
	local vers test=`echo "$info" | cut -d';' -f3` # version in list
	local file=`find_build $work $name`
	if [ "$file" != "" ] ; then
		info_build $file
		if [ "$temp" != "" ] ; then
			vers=`echo "$temp" | cut -d';' -f3` # version in build info
			pack=`echo "$temp" | cut -d';' -f2` # use local path!
		fi
		unset temp
	fi
	[ "$flag" = "--new" ] && vers=""
	[ "$vers" == "" -o "$vers" != "$test" ] && go_fetch_ball $info $pack
	file=`find_build $work $name`
	[ "$file" = "" ] && error_exit "$func: Failed to fetch $name?\n\n"
	go_fetch_ware $info `dirname $file`
}

do_fetch_build() #DONE
{
	local func="do_fetch_build()"
	local work=$1 ; shift
	local name=$1 ; shift
	local pack=$1 ; shift
	local opts=$@
	local deps=`find_opts --depbuild $opts`
	# update list
	[ "$deps" = "" ] && do_list_update $work && echo
	# go for it...
	go_fetch $work $name $pack
	# check!
	local file=`find_build $work $name`
	[ "$file" = "" ] && error_exit "$func: Failed to fetch $name?!\n\n"
	local temp info
	info_build $file
	info=$temp
	show_build $info $work
	# iterate through dependencies, if requested
	temp=`find_opts --depends $opts`
	if [ "$temp" != "" ]; then
		local deps=`echo "$info" | cut -d';' -f6`
		# some deps asks to refer to README
		[ "$deps" = "%README%" ] && warn_msg "Deps info in README!" && deps=""
		deps=`echo $deps | tr ',' ' '`
		for that in $deps ; do
			do_fetch_build $work $that $pack $opts --depbuild
		done
	fi
}

do_update_all() #DONE
{
	local func="do_update_all()"
	local work=$1
	local list=`list_build $work`
	[ -z "$list" ] && info_msg --no-tag "No scripts found!\n\n" && return
	# update list
	do_list_update $work --fresh ; echo
	info_msg --no-tag "Updating all buildscripts...\n\n"
	for that in $list ; do
		local name=`basename $that .SlackBuild`
		go_fetch $work $name
		local file=`find_build $work $name`
		[ ! -f "$file" ] && error_exit "$func: Failed to fetch $name?!\n\n"
		show_build $file $work --get-info
	done
}

go_build() #DONE
{
	local func="go_build()"
	local file=$1 ; shift
	must_have_file $file "Build script '$file' not found!"
	local name=`basename $file .SlackBuild`
	local path=`dirname $file`
	local vers=$1 ; shift
	local opts=$@
	local curr=`pwd`
	# check if already installed? should check version as well?
	local temp bver base=`find_install $name`
	if [ "$base" != "" ] ; then
		temp=`get_pkg_info $base`
		bver=`echo "$temp" | cut -d' ' -f2`
		# check version - stop if exactly the same!
		if [ "$bver" == "$vers" ] ; then
			echo "Package $base installed."
			temp=`find_opts --buildup $opts`
			[ "$temp" = "" ] && return
		fi
	fi
	# only root can actually build!
	must_be_root "Must run as root! ($name-$vers)"
	# start build?
	local logs=$TOOL_TEMP/${name}.buildlog
	[ ! -d "$TOOL_TEMP" ] && mkdir -p "$TOOL_TEMP"
	cd $path
	info_msg "Building '$name' ... "
	sh ${name}.SlackBuild >$logs 2>&1
	[ $? -ne 0 ] && error_exit "Error building '$name'!\n\n"
	info_msg --no-tag "done!\n"
	cd $curr
	local ball=`cat $logs | tail -n 2 | grep Slackware`
	ball=`echo "$ball" | sed 's/^.*package \(.*\) created.*$/\1/'`
	must_have_file $ball "Cannot find package '$ball'!"
	temp=`find_opts --install $opts`
	if [ "$temp" != "" ] ; then
		if [ "$base" != "" ] ; then
			local flag qver
			# upgrade existing?
			temp=`get_pkg_info $base`
			qver=`echo "$temp" | cut -d' ' -f2`
			[ "$qver" == "$vers" ] && flag="--reinstall"
			# go upgrade!
			info_msg "Upgrading '$ball' ($bver -> $vers)... "
			upgradepkg $flag $ball >>$logs 2>&1
			[ $? -ne 0 ] && error_exit "Error upgrading '$ball'!\n\n"
			info_msg --no-tag "done!\n"
		else
			# go install!
			info_msg "Installing '$ball'... "
			installpkg $ball >>$logs 2>&1
			[ $? -ne 0 ] && error_exit "Error installing '$ball'!\n\n"
			info_msg --no-tag "done!\n"
		fi
	else
		# copy built package & build log to cur_path
		info_msg "Copying '$ball' to '$curr'... "
		mv $ball $curr
		ball=$curr/`basename $ball`
		mv $logs $curr
		logs=$curr/`basename $logs`
		info_msg --no-tag "done!\n"
		# fix permission of built package & logs
		local refp=`get_path_owner $curr`
		local chkp=`get_path_owner $ball`
		if [ "$chkp" != "" -a "$refp" != "" ] ; then
			if [ "$chkp" != "$refp" ] ; then
				info_msg "Fixing file permissions ... "
				chown $refp $ball $logs
				info_msg --no-tag "done!\n"
			fi
		fi
	fi
}

do_run_build() #DONE
{
	local func="do_run_build()"
	local work=$1 ; shift
	local name=$1 ; shift
	local opts=$@
	local file=`find_build $work $name`
	[ "$file" = "" ] && error_exit "Cannot find '$name.SlackBuild'!\n\n"
	local temp
	info_build $file
	local info=$temp
	unset temp
	local vers=`echo "$info" | cut -d';' -f3`
	local deps=`echo "$info" | cut -d';' -f6`
	# show this before dependencies if not really building
	local exec=`find_opts --execute $opts`
	[ "$exec" = "" ] && show_build $info $work
	# iterate through dependencies, if requested
	local temp=`find_opts --depends $opts`
	if [ "$temp" != "" ]; then
		# some deps asks to refer to README
		[ "$deps" == "%README%" ] && deps=""
		deps=`echo $deps | tr ',' ' '`
		for that in $deps ; do # force install!
			do_run_build $work $that $opts --install
		done
	fi
	# build only if explicitly requested
	[ "$exec" != "" ] && go_build $file $vers $opts
}

do_check_installed() #DONE
{
	local func="do_check_installed()"
	local work=$1 ; shift
	local opts=$@
	local list=`list_build $work`
	[ -z "$list" ] && info_msg --no-tag "No scripts found!\n\n" && return
	local find=0 done=0
	for that in $list ; do
		local temp info
		info_build $that
		info=$temp
		unset temp
		local name=`echo "$info" | cut -d';' -f1`
		local pack=`echo "$info" | cut -d';' -f2`
		local vers=`echo "$info" | cut -d';' -f3`
		pack=`echo $pack | sed "s|$work||"`
		# look for installed
		local base=`find_install $name`
		[ "$base" == "" ] && continue; find=1
		local test=`get_pkg_info $base`
		local what=`echo "$test" | cut -d' ' -f2`
		local verb=`find_opts --verbose $opts`
		# check version
		[ "$vers" == "$what" -a "$verb" = "" ] && continue; done=1
		# show if not the same version
		head_msg --tag "[PATCH]"
		head_msg "Installed: {$base}, Build: $name ($vers)"
		[ "$pack" != "" ] && info_msg --no-tag " [Pack: $pack]"
		echo
	done
	[ $find -ne 0 -a $done -eq 0 ] && info_msg "Installed is up-to-date.\n"
}

do_check_reversedeps()
{
	local func="do_check_reversedeps()"
	local work=$1
	local name=$2
	[ -z "$name" ] && error_exit "No package name given!\n\n"
	local file=`find_build $work $name`
	[ "$file" = "" ] && error_exit "Cannot find '$name.SlackBuild'!\n\n"
	local info temp
	info_build $file
	info=$temp
	unset temp
	[ "$info" = "" ] && error_exit "Failed to get $name info?\n\n"
	local dept list=`list_build $work`
	for that in $list ; do
		local next=`basename $that .SlackBuild`
		[ "$next" = "$name" ] && continue
		local test
		info_build $that
		test=$temp
		unset temp
		local what=`echo "$test" | cut -d';' -f6`
		[ "$what" = "%README%" ] && what=""
		[ "$what" = "" ] && continue
		what=`echo $what | tr ',' ' '`
		for haha in $what ; do
			if [ "$haha" = "$name" ] ; then
				dept="${dept}$next "
				break
			fi
		done
	done
	local more=1
	[ -z "$dept" ] && dept="None" && more=0
	show_build $info $work
	warn_msg --no-tag "-- Dependents: $dept\n"
	[ $more -eq 0 ] && return
	for that in $dept ; do
		do_check_reversedeps $work $that
	done
}

process_command()
{
	local task=$1 ; shift
	[ "$task" = "" ] && task="help"
	local work=$WORK_PATH # default path for slackbuilds
	local pack=$PACK_PATH # default sub-folder name for slackbuilds
	# check parameters
	local name optf opts
	while [ "$1" != "" ]; do
		case $1 in
			-p|--path) shift ; must_have_path $1 ; work=`cd $1 ; pwd` ;;
			-g|--pack) shift ; pack=$1 ;;
			-i|--install) opts="$opts --install" ;;
			-x|--execute) opts="$opts --execute" ;;
			-d|--depends) optf="$optf --depends" ; opts="$opts --depends" ;;
			-b|--buildup) opts="$opts --buildup" ;;
			-v|--verbose) optf="$optf --verbose" ;;
			--new) optf="$optf --new" ;;
			-*) error_exit "Unknown option '$1'\n\n" ;;
			*) [ "$name" != "" ] && error_exit "Unknown:'$1'\n\n" ; name=$1 ;;
		esac
		shift
	done
	# check if work path is valid
	must_have_path $work "Slackbuilds path '$work' not found!"
	info_msg --no-tag "Slackbuilds path: $work\n\n"
	# execute task
	case "$task" in
		help) echo "$TOOL_HELP" ;;
		list) do_list_local $work ;;
		find) do_find_list $work $name $optf ;;
		update) do_list_update $work $optf ;;
		fetch) do_fetch_build $work $name $pack $optf ;;
		build) do_run_build $work $name $opts ;;
		fresh) do_update_all $work $optf ;;
		check) do_check_installed $work $optf ;;
		check-rev) do_check_reversedeps $work $name $optf ;;
		*) error_exit "Unknown task '$task'!\n\n" ;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
