#!/bin/bash

# getslackbuild
# - written by azman@my1matrix.net
# - get/execute slackbuild scripts from SlackBuilds.org
# - builds dependencies (based on .info file) if requested

# standard tool info
MY1TOOL=`basename $0 .sh`
MY1PATH=`dirname $0`
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$MY1TOOL
	[ -r $config ] && source $config && break
done

# my1slack tool specific
MY1_TOOLNAME="my1 SlackBuilds.org Executor"
MY1_TOOLVERS="2017.03.02"
MY1_TOOLPDIR=`dirname $MY1PATH`
MY1_BUILDDIR=${MY1_BUILDDIR:="${MY1_TOOLPDIR}/slackbuilds"}
MY1_THISPATH=`pwd -P`
MY1_PACKPATH=""
[ -z "$SLACKVERS" ] && [ -n "$RELEASE" ] && SLACKVERS=$RELEASE
SLACKVERS=${SLACKVERS:=""}
if [ "$SLACKVERS" == "" ]; then
	SLACKVERS=`cat /etc/slackware-version | sed 's/Slackware //'`
	SLACKVMAJ=`echo $SLACKVERS | cut -d. -f1`
	SLACKVMIN=`echo $SLACKVERS | cut -d. -f2`
	# just in case?
	SLACKVREL=`echo $SLACKVERS | cut -d. -f3`
fi
[ -z "$SLACKARCH" ] && [ -n "$ARCH" ] && SLACKARCH=$ARCH
SLACKARCH=${SLACKARCH:=""}
if [ "$SLACKARCH" == "" ]; then
	SLACKARCH=`find / -maxdepth 1 -name 'lib64' -type d 2>/dev/null`
	if [ "$SLACKARCH" == "/lib64" ] ; then SLACKARCH="x86_64"
	else SLACKARCH="" ; fi
fi

# global options & settings
OPT_INSTALL=""
OPT_DEPENDS="NO"
OPT_EXECUTE="NO"
OPT_CLEANUP="NO"
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $MY1TOOL [options] <pkg_name>
Options:
  --path </path/to/slackbuilds>
  --pack </sub/path/to/package/group>
  --update  : Fetch new build script if available
  --install : Install when (and if) the build completes
  --depends : Check (and build) dependencies
  --execute : Execute build (else, simply check @ dry-run)
SETHELPMSG`

function do_download()
{
	local fname="$1"
	local label="$2"
	local cpath=`pwd`
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -ne "\nDownloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!\n" && exit 1
	echo -ne "\b\b\b\b DONE!\n"
}

function do_loadball()
{
	local pkg_path=$1
	local pkg_file=$2
	local pkg_ball=`basename $pkg_file`
	[ ! -d $pkg_path ] &&
		echo -e "[ERROR] Cannot find $pkg_path!\n" >&2 && exit 1
	# TODO! This has problems if redirected a lot (github source?)
	#wget --spider $pkg_file >/dev/null 2>&1
	#[ $? -ne 0 ] && echo -e "[ERROR] Cannot get $pkg_file!\n" >&2 && exit 1
	local chk_test=`curl -s -o /dev/null -w '%{http_code}' $pkg_file`
	[ $chk_test -ne 200 -o $chk_test -ne 302 ] &&
		echo -e "[ERROR] Cannot get $pkg_file!\n" >&2 && exit 1
	cd $pkg_path
	do_download $pkg_file $pkg_ball 2>/dev/null
	[ ! -r $pkg_ball ] &&
		echo -e "[ERROR] Cannot download $pkg_ball!\n" >&2 && exit 1
	cd - >/dev/null
	return 0
}

function get_userngrp()
{
	local chk_this=$1
	local chk_path=`pwd -P`
	local chk_user chk_grpn
	[ "$chk_this" == "." ] && chk_this=$chk_path
	[ "$chk_this" == ".." ] && chk_this=`dirname $chk_path`
	[ ! -r "$chk_this" ] && echo -e "Cannot read '$chk_this'!" 1>&2 && return
	chk_path=`dirname $chk_this`
	chk_path=`cd $chk_path;pwd`
	chk_this=`basename $chk_this`
	chk_user=`ls -l "${chk_path}/" | grep -e "${chk_this}$"`
	set -- $chk_user
	chk_user=$3
	chk_grpn=$4
	echo -n "$chk_user:$chk_grpn"
}

function get_buildinfo()
{
	local pkg_name=$1
	local inf_file="${MY1_BUILDDIR}/${pkg_name}/${pkg_name}.info"
	[ ! -f ${inf_file} ] && return
	local pkg_info=`cat $inf_file`
	# get package version
	local pkg_vers=`echo "$pkg_info" | grep VERSION=`
	pkg_vers=`echo "$pkg_vers" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name
	local pkg_file=`echo "$pkg_info" | grep DOWNLOAD=`
	pkg_file=`echo "$pkg_file" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get download file name x86_64
	local pkg_fil2=`echo "$pkg_info" | grep DOWNLOAD_x86_64=`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/^.*="\(.*\)".*$/\1/'`
	# get dependencies
	pkg_deps=`echo "$pkg_info" | grep REQUIRES= | sed 's/^.*="\(.*\)".*$/\1/'`
	# format info
	echo -n "$pkg_name;$pkg_vers;$pkg_file;$pkg_fil2;$pkg_deps"
	return
}

function do_build()
{
	local pkg_name=$1
	local opt_inst=$2
	local chk_path=${MY1_THISPATH}
	local pkg_path=${MY1_BUILDDIR}/${pkg_name}/
	local pkg_vers=${SLACKVERS}
	local pkg_root="http://slackbuilds.org/slackbuilds/$pkg_vers"
	local pkg_temp="/tmp/$(whoami)/my1/$MY1TOOL"
	local pkg_list="SLACKBUILDS.TXT"
	# prepare temp - get the list!
	mkdir -p $pkg_temp 2>/dev/null
	[ $? -ne 0 ] &&
		echo -e "[ERROR] Cannot create path '$pkg_temp'!\n" >&2 && exit 1
	# check if not found OR nothing modified last 120 minutes
	local chk_list=`find $pkg_temp -name $pkg_list -mmin -120 2>/dev/null`
	if [ "$chk_list" == "" ]; then
		cd $pkg_temp
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			rm -rf $pkg_list $pkg_list.gz # just in case, delete old one
			do_download ${pkg_root}/$pkg_list.gz $pkg_list.gz
			[ ! -r "$pkg_list.gz" ] &&
				echo -e "[ERROR] Cannot download $pkg_list.gz!\n" >&2 && exit 1
			gzip -d $pkg_list.gz
		else
			[ -r "$pkg_list" ] &&
				echo -e "[WARNING] NOT using latest $pkg_list!\n"
		fi
		cd - >/dev/null
	fi
	# we must have it!
	local tmp_list="${pkg_temp}/$pkg_list"
	[ ! -r "$tmp_list" ] &&
		echo -e "[ERROR] File '$tmp_list' not found!\n" >&2 && exit 1
	# look for pkg_name
	local pkg_test="SLACKBUILD NAME: $pkg_name"
	local pkg_text=`cat ${pkg_temp}/$pkg_list|grep -e "${pkg_test}$" -A10`
	[ "$pkg_text" == "" ] &&
		echo -e "[ERROR] Cannot find script for '$pkg_name'!\n" >&2 && exit 1
	# extract info
	pkg_test=`echo "$pkg_text" | grep 'SLACKBUILD NAME'`
	pkg_test=`echo "$pkg_test" | sed 's/.*: \(.*\)$/\1/'`
	[ "$pkg_test" != "$pkg_name" ] &&
		echo -e "[ERROR] Name error? '$pkg_test'/'$pkg_name'!\n" >&2 && exit 1
	local pkg_load=`echo "$pkg_text" | grep 'SLACKBUILD LOCATION'`
	pkg_load=`echo "$pkg_load" | sed 's/.*: \.\(.*\)$/\1/'`
	pkg_load="${pkg_root}${pkg_load}.tar.gz"
	local pkg_vers=`echo "$pkg_text" | grep 'SLACKBUILD VERSION'`
	pkg_vers=`echo "$pkg_vers" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_file=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD'`
	pkg_file=`echo "$pkg_file" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_fil2=`echo "$pkg_text" | grep 'SLACKBUILD DOWNLOAD_x86_64'`
	pkg_fil2=`echo "$pkg_fil2" | sed 's/.*: \(.*\)$/\1/'`
	local pkg_deps=`echo "$pkg_text" | grep 'SLACKBUILD REQUIRES'`
	pkg_deps=`echo "$pkg_deps" | sed 's/.*: \(.*\)$/\1/'`
	# check if local version is available
	local tmp_vers=""
	local pkg_info=`get_buildinfo $pkg_name`
	[ "$pkg_info" != "" ] && tmp_vers=`echo "$pkg_info" | cut -d';' -f2`
	# do we need to fetch?
	if [ "$tmp_vers" != "$pkg_vers" ] ; then
		if [ "$tmp_vers" == "" -o "$OPT_CLEANUP" == "YES" ] ; then
			pkg_test=`dirname $pkg_load`
			pkg_text=`basename $pkg_load`
			cd $pkg_temp
			wget --spider $pkg_test >/dev/null 2>&1
			[ $? -ne 0 ] &&
				echo -e "[ERROR] Cannot find $pkg_test!\n" >&2 && exit 1
			# remove old tarballs?
			rm -rf ${pkg_text}*
			do_download $pkg_load $pkg_text 2>/dev/null
			[ ! -r "$pkg_text" ] &&
				echo -e "[ERROR] Cannot download $pkg_load!\n" >&2 && exit 1
			cd - >/dev/null
			tmp_vers=$pkg_vers
			pkg_test=$pkg_temp/$pkg_text
			top_path=`dirname $pkg_path`
			[ ! -d "$top_path" ] && mkdir -p $top_path
			cd $top_path
			# remove old?
			rm -rf ${pkg_name}
			# extract accordingly?
			tar xf $pkg_test 2>/dev/null
			[ $? -ne 0 ] &&
				echo -e "[ERROR] Cannot extract $pkg_test!\n" >&2 && exit 1
			# download source tarball
			do_loadball $pkg_path $pkg_file
			[ "$pkg_fil2" != "" ] && do_loadball $pkg_path $pkg_fil2
			cd - >/dev/null
		fi
	fi
	# have we got the buildscript?
	[ ! -f ${pkg_path}/${pkg_name}.SlackBuild ] &&
		echo -e "SlackBuild for '$pkg_name' not found!\n" && exit 1
	# some deps asks to refer to README
	[ "$pkg_deps" == "%README%" ] && pkg_deps=""
	# show this before dependencies if not building
	if [ "$OPT_EXECUTE" != "YES" ]; then
		echo -n "Package: $pkg_name ($pkg_vers)"
		[ "$tmp_vers" != "" -a "$tmp_vers" != "$pkg_vers" ] &&
			echo -n ", Local Version: {$tmp_vers}"
		[ "$pkg_deps" != "" ] && echo -n ", Requires: $pkg_deps" ; echo
	fi
	# iterate through dependencies, if requested
	if [ "$OPT_DEPENDS" == "YES" ]; then
		for pkg in $pkg_deps ; do
			do_build $pkg --install
		done
	fi
	# build only if explicitly requested
	if [ "$OPT_EXECUTE" == "YES" ]; then
		[ $UID -ne 0 ] && echo -e "Must run as root!\n" && exit 1
		# check if already installed?
		local chk_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
		local chk_base=`ls /var/log/packages | grep -e "$chk_temp"`
		[ "$chk_base" != "" ] &&
			echo "Package ${chk_base} installed." && return
		# are we building x86_64?
		[ "$SLACKARCH" == "x86_64" -a "$pkg_fil2" != "" ] &&
			pkg_file="$pkg_fil2"
		# check if tarball available?
		local pkg_ball=`basename $pkg_file`
		[ ! -f "${pkg_path}/${pkg_ball}" ] && do_loadball $pkg_path $pkg_file
		local log_file=/tmp/${pkg_name}.buildlog
		cd ${pkg_path}
		echo -n "Building '$pkg_name' ... "
		sh ${pkg_name}.SlackBuild >${log_file} 2>&1
		[ $? -ne 0 ] && echo -e "Error building '$pkg_name'!\n" && exit 1
		echo "done!"
		cd - >/dev/null
		pkg_file=`cat ${log_file} | tail -n 2 | grep Slackware`
		pkg_file=`echo "$pkg_file" | sed 's/^.*package \(.*\) created.*$/\1/'`
		[ ! -f "$pkg_file" ] &&
			echo "Cannot find package '$pkg_file'!" && exit 1
		# check for previous installation
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
		local pkg_base=`ls /var/log/packages | grep -e "$pkg_temp"`
		if [ "$pkg_base" != "" ] ; then
			if [ "$opt_inst" == "--install" ] ; then
				echo -n "[$pkg_name] Installed ($pkg_base)! "
				echo -e "Installation cancelled!\n"
				opt_inst="";
			fi
		fi
		if [ "$opt_inst" == "--install" ] ; then
			# go install!
			echo -n "Installing '$pkg_file'... "
			installpkg $pkg_file >>${log_file} 2>&1
			[ $? -ne 0 ] &&
				echo -e "Error installing '$pkg_file'!\n" && exit 1
			echo "done!"
		else
			# copy built package & build log to chk_path (cwd)
			echo -n "Copying '$pkg_file' to '$chk_path'... "
			local chk_perm=`get_userngrp $chk_path`
			mv $pkg_file $chk_path
			pkg_file=${chk_path}/`basename $pkg_file`
			mv $log_file $chk_path
			log_file=${chk_path}/`basename $log_file`
			if [ "$chk_perm" != "" ] ; then
				chown $chk_perm $pkg_file $log_file
			fi
			echo "done!"
		fi
	fi;
}

function process_command()
{
	local pkg_name
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--install|-i)
				OPT_INSTALL="$1"
				;;
			--depends|-d)
				OPT_DEPENDS="YES"
				;;
			--execute|-x)
				OPT_EXECUTE="YES"
				;;
			--update|-u)
				OPT_CLEANUP="YES"
				;;
			--path|-p)
				shift
				[ ! -d "$1" ] &&
					echo -e "[ERROR] Invalid path!? [$1]\n" && exit 1
				MY1_BUILDDIR=`cd $1;pwd`
				;;
			--pack)
				shift
				MY1_PACKPATH="$1"
				;;
			-*)
				echo -e "$MSG_THISHELP\n"
				echo -e "[ERROR] Unknown option '$1'!\n" ; exit 1
				;;
			*)
				[ "$pkg_name" != "" ] &&
					echo -e "[ERROR] Multiple package? [$pkg_name]\n" && exit 1
				pkg_name="$1"
				;;
		esac
		shift
	done
	# check if name supplied
	[ "$pkg_name" == "" ] && echo -e "$MSG_THISHELP\n" && exit 0
	# check if package path supplied
	[ "$MY1_PACKPATH" != "" ] && MY1_BUILDDIR=${MY1_BUILDDIR}/${MY1_PACKPATH}
	# do your thing!
	do_build $pkg_name ${OPT_INSTALL}
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1TOOL - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
