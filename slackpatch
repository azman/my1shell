#!/bin/bash

# slackpatch
# - written by azman@my1matrix.org
# - slackware patch manager, using upgradepkg from pkgtools

# standard tool info
TOOL_NAME="my1 Slackware Patch Tool"
TOOL_VERS="2019.08.00"
TOOL_BASE=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH;pwd`
# look for libmy1slack
source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}
source_lib libmy1slack
source_lib libmy1file
call_setup
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$TOOL_BASE
	[ -r $config ] && . $config && break
done
TOOL_LOGS=${TOOL_LOGS:="/tmp/${TOOL_BASE}.log"}

# global options & settings
OPT_VERBOSE="NO"
OPT_UPGRADE=""
OPT_LOGFILE=${OPT_LOGFILE:="/dev/null"}
OPT_NOTHIRD=${OPT_NOTHIRD:="NO"}
PKG_IGNORED=${PKG_IGNORED:=""} # std package to ignore
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $TOOL_BASE <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
  quiet : Like 'check', but for use in another script!
Options:
  --verbose : Verbose mode (will also prompt patching!)
  --log     : Write process & results to log file '$TOOL_LOGS'
  --pkg <package_name>  : Check/update specific package
  --path <path_name>    : Specify additional patch path
  --skip <package_name> : Specify packages to skip
Mirror Source:
  $SLACKTREE
SETHELPMSG`

display_patches()
{
	local pat_temp pat_name pat_stat pat_vers
	local pat_opts pat_list chk_null
	pat_opts=$1 ; shift ; pat_list=`echo "$@" | sed 's/;/ /g'`
	[ "$pat_opts" == "check" ] && echo "Packages need updating:"
	[ "$pat_opts" == "pdone" ] && echo "Packages already up-to-date:"
	[ "$pat_opts" == "nlist" ] && echo "Unknown patches:"
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_temp=`echo $pat_loop | cut -d':' -f3` # filename
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		if [ "$pat_stat" == "$pat_opts" ] ; then
			chk_null="NO"
			[ "$OPT_VERBOSE" == "NO" ] && echo -n "$pat_name "
			[ "$OPT_VERBOSE" == "YES" ] && echo "$pat_name: ${pat_vers}"
		fi
	done
	# prettify output
	if [ "$chk_null" == "NO" ]; then
		[ "$OPT_VERBOSE" == "NO" ] && echo
	else
		[ "$pat_opts" == "check" ] && echo "** No updates found! **"
		[ "$pat_opts" == "pdone" ] && echo "** No up2date patches! **"
		[ "$pat_opts" == "nlist" ] && echo "** No unknown patches! **"
	fi
}

apply_patch()
{
	local pat_temp pat_name pat_stat pat_file do_update
	pat_temp="$@"
	pat_name=`echo $pat_temp | cut -d':' -f1`
	pat_stat=`echo $pat_temp | cut -d':' -f2`
	pat_file=`echo $pat_temp | cut -d':' -f3`
	# check if can be applied
	[ "$pat_stat" != "check" ] && return # patch not needed
	[ ! -r "$pat_file" ] &&
		error_exit "File '$pat_file' not found!\n\n"
	# apply the patch!
	if [ "$OPT_VERBOSE" == "YES" ]; then
		read -n 1 -p "Update '$pat_name'? [y]/[*]/[q] : " do_update ; echo
		if [ "$do_update" == "y" ]; then
			echo -n "Updating '$pat_name'... "
			/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
			echo "done."
		elif [ "$do_update" == "q" ]; then
			warn_msg "Aborting on '$pat_name'!"
			exit 0
		fi
	elif [ "$OPT_VERBOSE" == "NO" ]; then
		echo -n "Auto-updating '$pat_name'... "
		/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
		echo "done."
	fi
}

execute_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list pkg_list chk_list log_init
	#echo "Parameter Count: ${#}"
	# get pkg request list
	while [ "$1" != "" ]; do
		[ "$1" == "--patches" ] && shift && break;
		pkg_list="$pkg_list $1"
		shift
	done
	# get available patches list
	pat_list=`echo "$@" | sed 's/;/ /g'`
	# check for requested package
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_file=`echo $pat_loop | cut -d':' -f3`
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		[ "$pat_stat" != "check" ] && continue # patch not needed
		pat_temp=`echo $pkg_list | grep $pat_name`
		if [ "$pkg_list" == "" -o "$pat_temp" != "" ] ; then
			chk_list="${chk_list}${pat_loop} "
		fi
	done
	# browse through the check list
	if [ ! -z "$chk_list" ]; then
		# only root can apply patches!
		must_be_root
		log_init="$TOOL_BASE - $TOOL_NAME ($TOOL_VERS) - $(date)\n"
		echo -e $log_init >$OPT_LOGFILE
		echo "Packages need updating:"
		for pat_loop in $chk_list ; do
			apply_patch $pat_loop
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
}

check_patch()
{
	local pat_stat chk_null
	local pat_list=`echo "$@" | sed 's/;/ /g'`
	[ "$pat_opts" == "check" ] && echo "Packages need updating:"
	for pat_loop in $pat_list ; do
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		[ "$pat_stat" == "check" ] && chk_null="NO" && return 1
	done
	return 0
}

process_command()
{
	local go_commands="check pdone nlist patch quiet"
	local do_command
	local pkg_list pkg_temp pkg_path pat_list
	local pkg_path="--more ${SLACKROOT}/${SLACKFULL//ware/pack}"
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--verbose)
				OPT_VERBOSE="YES"
				;;
			--log)
				OPT_LOGFILE="$TOOL_LOGS"
				;;
			--override)
				OPT_UPGRADE="--reinstall --install-new"
				;;
			--pure)
				OPT_NOTHIRD="YES"
				;;
			--path)
				shift
				# check additional path
				[ ! -d "$1" ] && error_exit "Cannot find path '$1'!\n\n"
				pkg_path="${pkg_path} --more "`cd $1 ; pwd`
				;;
			--pkg)
				shift
				# check discrete package name
				pkg_temp=`find_install $1 $SLACKPACK`
				[ "$pkg_temp" == "" ] && error_exit "Unknown package '$1'!\n\n"
				pkg_temp=`get_pkg_info $pkg_temp | cut -d' ' -f1`
				pkg_list="${pkg_list} ${pkg_temp}"
				;;
			-*)
				error_exit "Unknown option '$1'\n\n!"
				;;
			*)
				[ "$do_command" != "" ] &&
					error_exit "Multiple commands '$1' & '$do_command'\n\n"
				for tcommand in $go_commands; do
					[ "$1" == "$tcommand" ] && do_command=$1 && break
				done
				[ "$do_command" == "" ] && echo -e "$MSG_THISHELP" &&
					error_exit "Unknown command '$1'!\n\n"
				;;
		esac
		shift
	done
	# if no command given, do a check
	[ "$do_command" == "" ] && do_command="check"
	if [ "$do_command" != "quiet" ] ; then
		echo -e "\n$TOOL_BASE - $TOOL_NAME ($TOOL_VERS)\n"
		echo "[$SLACKFULL]"
		echo -n "Looking for patches... "
	fi
	# find patches
	pat_list=`list_patches --tree $SLACKTREE $pkg_path $PKG_IGNORED`
	if [ "$do_command" != "quiet" ] ; then
		echo -e "done!\n"
	else
		check_patch "$pat_list"
		exit $?
	fi
	# display packages
	[ "$do_command" != "patch" ] &&
		display_patches $do_command "$pat_list"
	# patch packages
	[ "$do_command" == "patch" ] &&
		execute_patches $pkg_list --patches "$pat_list"
	echo ; exit 0
}

# BEGIN MAIN SCRIPT

process_command "$@"

# END MAIN SCRIPT
