#!/bin/bash

# slackpatch
# - written by azman@my1matrix.net
# - slackware patch manager

# standard tool info
TOOL_THISFUNC="my1 Slackware Patch Tool"
TOOL_THISVERS="2011.12.00"
# standard tool conf
TOOL_CHECKCMD="$@"
TOOL_COMMANDS=${TOOL_CHECKCMD:="help"}
TOOL_THISFILE=$(basename $0 .sh)
TOOL_LOCATION=$(cd $(dirname $0);pwd)
TOOL_CONFFILE="$TOOL_THISFILE.conf"
TOOL_MY1SLACK="libmy1slack"
# look for config file
for conf_path in  $(pwd) $TOOL_LOCATION ; do
	config_file="${conf_path}/${TOOL_CONFFILE}"
	[[ -r $config_file ]] && source $config_file && break
done
# look for my1slack library
[[ -r "$TOOL_LOCATION/$TOOL_MY1SLACK" ]] && source $TOOL_LOCATION/$TOOL_MY1SLACK
# my1slack tool specific
TOOL_SLACKDIR=${TOOL_SLACKDIR:="${SLACKROOTDIR}/${SLACKRELEASE}"}
TOOL_PATCHDIR=${TOOL_PATCHDIR:="${TOOL_SLACKDIR}/patches/packages"}
TOOL_LOGFILE=${TOOL_LOGFILE:="/tmp/${TOOL_THISFILE%%.*}.log"}
# global options & settings
OPT_FULLINFO="NO"
OPT_AUTOPATCH="YES"
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $TOOL_THISFILE <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
  help  : Show this help message
Options:
  --short  : Short Info
  --full   : Full Info
  --prompt : Prompt Before Patching
  --auto   : Auto-Patch
  --path <path_name> : Specify additional patch path
  --pkg <package_name> : Auto-Patch Implied!
Mirror Source:
  $TOOL_SLACKDIR
Log File:
  $TOOL_LOGFILE
SETHELPMSG
)

function find_patches()
{
	local pat_exts pat_base pat_name
	local pat_vers pat_arch pat_extd
	local pkg_temp pkg_base pkg_name
	local pkg_vers pkg_arch pkg_extd
	local curr_dir=$(pwd)

	for pat_file in *.t[gx]z; do
		# check extension first
		pat_exts="${pat_file##*.}"
		pat_base="${pat_file%%.${pat_exts}}"
		# get particulars
		pkg_temp=($(get_pkg_info $pat_base))
		pat_name="${pkg_temp[0]}"
		pat_vers="${pkg_temp[1]}"
		pat_arch="${pkg_temp[2]}"
		pat_extd="${pkg_temp[3]}"
		# find installed
		pkg_base="$(find_install $pat_name)"
		if [[ "$pkg_base" != "" ]]; then
			pkg_temp=($(get_pkg_info $pkg_base))
			pkg_name="${pkg_temp[0]}"
			pkg_vers="${pkg_temp[1]}"
			pkg_arch="${pkg_temp[2]}"
			pkg_extd="${pkg_temp[3]}"
			if [[ "$pkg_vers" == "$pat_vers" ]] &&
				[[ "$pkg_extd" == "$pat_extd" ]]; then
				PAT_LIST="$PAT_LIST $pat_name"
				eval patchstat_${pat_name//[-.]/_}="pdone"
				eval patchfile_${pat_name//[-.]/_}=${curr_dir}/${pat_file}
				eval patchvers_${pat_name//[-.]/_}=[${pat_vers}/${pat_extd}]
			else
				PAT_LIST="$PAT_LIST $pat_name"
				eval patchstat_${pat_name//[-.]/_}="check"
				eval patchfile_${pat_name//[-.]/_}=${curr_dir}/${pat_file}
				eval patchvers_${pat_name//[-.]/_}=[${pkg_vers}/${pkg_extd}]-to-[${pat_vers}/${pat_extd}]
			fi
		else
			PAT_LIST="$PAT_LIST $pat_name"
			eval patchstat_${pat_name//[-.]/_}="nlist"
			eval patchfile_${pat_name//[-.]/_}=${curr_dir}/${pat_file}
			eval patchvers_${pat_name//[-.]/_}=[${pat_vers}/${pat_extd}]
		fi
	done
	cd $curr_dir
}

function check_patches()
{
	local curr_dir=$(pwd)
	[[ ! -d $TOOL_PATCHDIR ]] &&
		echo -e "Path '$TOOL_PATCHDIR' not found! Aborting!\n" && exit 1
	cd $TOOL_PATCHDIR
	TOOL_PATCHDIR=$(pwd)
	find_patches
	KERNEL_PATPATH=$(find . -name "linux-*" -type d -maxdepth 1)
	for path in $KERNEL_PATPATH; do
		cd $path
		find_patches
		cd $TOOL_PATCHDIR
	done
	while [[ "$1" != "" ]]; do
		cd $1
		find_patches
		shift
	done
}

function extract_patches()
{
	local pkg_temp pat_list pkg_list pkg_opts
	pkg_opts=$1; shift; pkg_list=$@
	pat_list=""
	for pkg_name in $pkg_list ; do
		pkg_temp="patchstat_${pkg_name//-/_}"
		[[ "${!pkg_temp}" == "$pkg_opts" ]] && pat_list="$pat_list $pkg_name"
	done
	echo -n "$pat_list"
}

function check_request()
{
	local pkg_temp pkg_list
	pkg_list=""
	for pkg_name in $@ ; do
		pkg_temp="patchstat_${pkg_name//-/_}"
		[[ "${!pkg_temp}" == "check" ]] && pkg_list="$pkg_list $pkg_name"
	done
	echo -n "$pkg_list"
}

function must_be_root()
{
	[[ $UID -ne 0 ]] && echo -e "Abort: must run as root!\n" && exit 1
}

function execute_patches()
{
	local pkg_temp pkg_file pkg_vers
	local pkg_list=$(check_request $@)

	must_be_root

	[[ "$pkg_list" == "" ]] && pkg_list=$(extract_patches check $PAT_LIST)
	if [[ ! -z "$pkg_list" ]]; then
		echo -e "$TOOL_THISFILE - $TOOL_THISFUNC ($TOOL_THISVERS)\n$(date)\n" >$TOOL_LOGFILE
		echo "Packages need updating:"
		for pkg_name in $pkg_list ; do
			pkg_temp="patchstat_${pkg_name//-/_}"
			[[ "${!pkg_temp}" != "check" ]] && continue
			pkg_temp="patchfile_${pkg_name//-/_}"
			pkg_file=${!pkg_temp}
			pkg_temp="patchvers_${pkg_name//-/_}"
			pkg_vers=${!pkg_temp}
			[[ ! -r "$pkg_file" ]] && echo "Error: File '$pkg_file' not found!" && exit 1
			if [[ "$OPT_AUTOPATCH" == "NO" ]] ; then
				read -n 1 -p "Update package '$pkg' ? [y]/[*]/[q] : " do_update ; echo
				if [[ "$do_update" == "y" ]]; then
					echo -n "Updating '$pkg_name'... "
					/sbin/upgradepkg ${pkg_file} >>$TOOL_LOGFILE
					echo "done."
				elif [[ "$do_update" == "q" ]]; then
					echo "Aborting on '$pkg_name'!"
					exit 1
				fi
			elif [[ "$OPT_AUTOPATCH" == "YES" ]] ; then
				echo -n "Auto-updating '$pkg_name'... "
				/sbin/upgradepkg ${pkg_file} >>$TOOL_LOGFILE
				echo "done."
			fi
		done
	else
		echo "Nothing to patch/upgrade!"
	fi
	echo
}

function display_patches()
{
	local pkg_temp pkg_file pkg_vers pkg_list pkg_opts

	pkg_opts=$1; shift; pkg_list=$(extract_patches $pkg_opts $PAT_LIST)
	if [[ ! -z "$pkg_list" ]]; then
		[[ "$pkg_opts" == "check" ]] && echo "Packages need updating:"
		[[ "$pkg_opts" == "pdone" ]] && echo "Packages already up-to-date:"
		[[ "$pkg_opts" == "nlist" ]] && echo "Unknown patches:"
		for pkg_name in $pkg_list ; do
			pkg_temp="patchstat_${pkg_name//-/_}"
			[[ "${!pkg_temp}" != "$pkg_opts" ]] && continue
			pkg_temp="patchfile_${pkg_name//-/_}"
			pkg_file=${!pkg_temp}
			pkg_temp="patchvers_${pkg_name//-/_}"
			pkg_vers=${!pkg_temp}
			if [[ "$OPT_FULLINFO" == "NO" ]] ; then
				echo -n "$pkg_name "
			elif [[ "$OPT_FULLINFO" == "YES" ]] ; then
				echo "$pkg_name: ${pkg_vers}"
			fi
		done
		[[ "$OPT_FULLINFO" != "YES" ]] && echo
	else
		[[ "$pkg_opts" == "check" ]] && echo "No updates found!"
		[[ "$pkg_opts" == "pdone" ]] && echo "No up2date patches!"
		[[ "$pkg_opts" == "nlist" ]] && echo "No unknown patches!"
	fi
	echo
}

function process_command()
{
	local go_commands="check pdone nlist patch"
	local do_command=""
	local pkg_list="" pkg_path=""
	local pkg_temp
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--short)
				OPT_FULLINFO="NO"
				;;
			--full)
				OPT_FULLINFO="YES"
				;;
			--prompt)
				OPT_AUTOPATCH="NO"
				;;
			--auto)
				OPT_AUTOPATCH="YES"
				;;
			--path)
				shift
				# check additional path
				[[ ! -d "$1" ]] &&
					echo -e "Cannot find path '$1'!\n" && exit 1
				pkg_path="${pkg_path} $(cd $1;pwd)"
				;;
			--pkg)
				shift
				# check discrete package name
				pkg_temp=$(find_install $1)
				[[ "$pkg_temp" == "" ]] &&
					echo -e "Unknown package '$1'!\n" && exit 1
				pkg_list="${pkg_list} $pkg_temp"
				;;
			--help|-h|help)
				echo -e "$MSG_THISHELP\n"
				exit 0
				;;
			-*)
				echo -e "Unknown option '$1'!\n" && exit 1
				;;
			*)
				[[ "$do_command" != "" ]] &&
					echo -e "Multiple commands '$1' & '$do_command'\n" && exit 1
				for tcommand in $go_commands; do
					[[ "$1" == "$tcommand" ]] && do_command=$1 && break
				done
				[[ "$do_command" == "" ]] &&
					echo -e "Unknown command '$1'!\n" && exit 1
				;;
		esac
		shift
	done
	# exit if no command...
	[[ "$do_command" == "" ]] && echo -e "No command given!\n" && exit 1
	# find packages
	check_patches $pkg_path
	# display packages
	[[ "$do_command" != "patch" ]] && display_patches $do_command
	# patch packages
	[[ "$do_command" == "patch" ]] && execute_patches $pkg_list
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_THISFILE - $TOOL_THISFUNC ($TOOL_THISVERS)\n"
process_command $TOOL_COMMANDS

# END MAIN SCRIPT
