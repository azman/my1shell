#!/bin/bash

# slackpatch
# - written by azman@my1matrix.org
# - slackware patch manager, using upgradepkg from pkgtools

# standard tool info
TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH;pwd`
TOOL_DESC="my1 Slackware Patch Tool"
TOOL_VERS="2019.08.00"
TOOL_HELP=`cat <<SETHELPMSG
Usage:
  $TOOL_NAME <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
  quiet : Like 'check', but for use in another script!
Options:
  --verbose : Verbose mode (will also prompt patching!)
  --log     : Write process & results to log file '$TOOL_LOGS'
  --override: Upgrade like fresh installation
  --pure    : Ignore 3rd-party packages
  --root    : Assign rootfs to process on...
  --help    : This help message
  --pkg <package_name>  : Check/update specific package
  --path <path_name>    : Specify additional patch path
  --skip <package_name> : Specify packages to skip
SETHELPMSG`

# look for library scripts
source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}
source_lib libmy1slack
source_lib libmy1file
source_lib libmy1echo
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$TOOL_NAME
	[ -r $config ] && . $config && break
done
TOOL_LOGS=${TOOL_LOGS:="/tmp/${TOOL_NAME}.log"}
# global options & settings
OPT_VERBOSE="NO"
OPT_UPGRADE=""
OPT_CHKROOT=""
OPT_LOGFILE=${OPT_LOGFILE:="/dev/null"}
OPT_NOTHIRD=${OPT_NOTHIRD:="NO"}
PKG_IGNORED=${PKG_IGNORED:=""} # std package to ignore

display_patches()
{
	local pat_temp pat_name pat_stat pat_vers
	local pat_opts pat_list chk_null
	pat_opts=$1 ; shift ; pat_list=`echo "$@" | sed 's/;/ /g'`
	[ "$pat_opts" == "check" ] && echo "Packages need updating:"
	[ "$pat_opts" == "pdone" ] && echo "Packages already up-to-date:"
	[ "$pat_opts" == "nlist" ] && echo "Unknown patches:"
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_temp=`echo $pat_loop | cut -d':' -f3` # filename
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		if [ "$pat_stat" == "$pat_opts" ] ; then
			chk_null="NO"
			[ "$OPT_VERBOSE" == "NO" ] && echo -n "$pat_name "
			[ "$OPT_VERBOSE" == "YES" ] && echo "$pat_name: ${pat_vers}"
		fi
	done
	# prettify output
	if [ "$chk_null" == "NO" ]; then
		[ "$OPT_VERBOSE" == "NO" ] && echo
	else
		[ "$pat_opts" == "check" ] && echo "** No updates found! **"
		[ "$pat_opts" == "pdone" ] && echo "** No up2date patches! **"
		[ "$pat_opts" == "nlist" ] && echo "** No unknown patches! **"
	fi
}

apply_patch()
{
	local pat_temp pat_name pat_stat pat_file do_update
	local opt_root=$OPT_CHKROOT
	[ ! -z "$opt_root" ] && opt_root="ROOT=$OPT_ROOT"
	pat_temp="$@"
	pat_name=`echo $pat_temp | cut -d':' -f1`
	pat_stat=`echo $pat_temp | cut -d':' -f2`
	pat_file=`echo $pat_temp | cut -d':' -f3`
	# check if can be applied
	[ "$pat_stat" != "check" ] && return # patch not needed
	[ ! -r "$pat_file" ] &&
		error_exit "File '$pat_file' not found!\n\n"
	# apply the patch!
	if [ "$OPT_VERBOSE" == "YES" ]; then
		read -n 1 -p "Update '$pat_name'? [y]/[*]/[q] : " do_update ; echo
		if [ "$do_update" == "y" ]; then
			echo -n "Updating '$pat_name'... "
			$opt_root /sbin/upgradepkg $OPT_UPGRADE $pat_file >>$OPT_LOGFILE
			echo "done."
		elif [ "$do_update" == "q" ]; then
			warn_msg "Aborting on '$pat_name'!"
			exit 0
		fi
	elif [ "$OPT_VERBOSE" == "NO" ]; then
		echo -n "Auto-updating '$pat_name'... "
		$opt_root /sbin/upgradepkg $OPT_UPGRADE $pat_file >>$OPT_LOGFILE
		echo "done."
	fi
}

execute_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list pkg_list chk_list log_init
	#echo "Parameter Count: ${#}"
	# get pkg request list
	while [ "$1" != "" ]; do
		[ "$1" == "--patches" ] && shift && break;
		pkg_list="$pkg_list $1"
		shift
	done
	# get available patches list
	pat_list=`echo "$@" | sed 's/;/ /g'`
	# check for requested package
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_file=`echo $pat_loop | cut -d':' -f3`
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		[ "$pat_stat" != "check" ] && continue # patch not needed
		pat_temp=`echo $pkg_list | grep $pat_name`
		if [ "$pkg_list" == "" -o "$pat_temp" != "" ] ; then
			chk_list="${chk_list}${pat_loop} "
		fi
	done
	# browse through the check list
	if [ ! -z "$chk_list" ]; then
		# only root can apply patches!
		must_be_root
		log_init="$TOOL_NAME - $TOOL_DESC ($TOOL_VERS) - $(date)\n"
		echo -e $log_init >$OPT_LOGFILE
		echo "Packages need updating:"
		for pat_loop in $chk_list ; do
			apply_patch $pat_loop
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
}

check_patch()
{
	local pat_list=`echo "$@" | sed 's/;/ /g'`
	for pat_loop in $pat_list ; do
		local pat_stat=`echo $pat_loop | cut -d':' -f2`
		[ "$pat_stat" == "check" ] && exit 1
	done
	exit 0
}

process_command()
{
	local go_commands="check pdone nlist patch quiet"
	local do_command=$1 ; shift
	# check parameters
	local pkg_temp pkg_path sys_root
	while [ "$1" != "" ]; do
		case $1 in
			--verbose) OPT_VERBOSE="YES" ;;
			--log) OPT_LOGFILE="$TOOL_LOGS" ;;
			--override) OPT_UPGRADE="--reinstall --install-new" ;;
			--pure) OPT_NOTHIRD="YES" ;;
			--path) shift ; pkg_path="${pkg_path}$1 " ;;
			--pack|--pkg) shift ; pkg_temp="${pkg_temp}$1 " ;;
			--help|-h) echo -e "$TOOL_HELP" && return 0 ;;
			--root) shift ; sys_root=$1 ;;
			--skip) shift ; PKG_IGNORED="${PKG_IGNORED}$1 " ;;
			*) error_exit "Unknown param '$1'!\n\n" ;;
		esac
		shift
	done
	if [ ! -z "$sys_root" ] ; then
		[ ! -d "$sys_root" ] && error_exit "Cannot find root '$sys_root'!\n\n"
		OPT_CHKROOT=`cd $sys_root ; pwd`
	fi
	call_setup $OPT_CHKROOT
	[ ! -d "$SLACKTREE" ] &&
		error_exit "Cannot find slack info in '$OPT_CHKROOT'!\n\n"
	local pkg_tree="--tree $SLACKTREE"
	local pkg_more="--more ${SLACKROOT}/${SLACKFULL//ware/pack}"
	local pkg_skip="$PKG_IGNORED"
	local pkg_list
	# process discrete package list
	if [ ! -z "$pkg_temp" ] ; then
		for that in $pkg_temp ; do
			# check discrete package name
			that=`find_install $that $SLACKPACK`
			[ "$that" == "" ] && error_exit "Unknown package '$that'!\n\n"
			pkg_list=`get_pkg_info $that | cut -d' ' -f1`
		done
	fi
	# process extra package paths
	if [ ! -z "$pkg_path" ] ; then
		for that in $pkg_path ; do
			[ ! -d "$that" ] && error_exit "Cannot find path '$that'!\n\n"
			pkg_more="${pkg_more} --more "`cd $that ; pwd`
		done
	fi
	# if no command given, do a check
	[ "$do_command" == "" ] && do_command="check"
	if [ "$do_command" != "quiet" ] ; then
		echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
		echo "[$SLACKFULL=>$OPT_CHKROOT]"
		echo -n "Looking for patches... "
	fi
	# find patches
	local pat_list=`list_patches $pkg_tree $pkg_more $pkg_skip`
	[ "$do_command" == "quiet" ] && check_patch "$pat_list"
	echo -e "done!\n"
	# discrete package name list for patching
	local do_execute="$pkg_list --patches"
	# display packages
	[ "$do_command" != "patch" ] && display_patches $do_command "$pat_list"
	# patch packages
	[ "$do_command" == "patch" ] && execute_patches $do_execute "$pat_list"
	echo ; exit 0
}

# BEGIN MAIN SCRIPT

process_command "$@"

# END MAIN SCRIPT
