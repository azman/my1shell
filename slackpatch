#!/bin/bash

# slackpatch
# - written by azman@my1matrix.org
# - slackware patch manager, using upgradepkg from pkgtools

# standard tool info
TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH;pwd`
TOOL_DESC="my1 Slackware Patch Tool"
TOOL_VERS="2019.11.00"
TOOL_LOGS=${TOOL_LOGS:="/tmp/my1/${TOOL_NAME}.log"}
TOOL_HELP=`cat <<SETHELPMSG
Usage:
  $TOOL_NAME <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
  quiet : Like 'check', but for use in another script!
Options:
  --verbose  : Verbose mode (will also prompt patching!)
  --log      : Use log file '$TOOL_LOGS'
  --override : Upgrade with '--reinstall' and '--install-new'
  --pure     : Ignore 3rd-party packages
  --help     : This help message
  --pkg <package_name>  : Specify package to check/update
  --skip <package_name> : Specify packages to skip
  --path <path_name>    : Specify additional patch path
  --root <path_name>    : Specify rootfs to patch
SETHELPMSG`

# look for library scripts
source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}
source_lib libmy1slack
source_lib libmy1file
source_lib libmy1echo
# look for config file
TOOL_CONF=$HOME/.$TOOL_NAME
[ -r $TOOL_CONF ] && . $TOOL_CONF
# config can contain ignored packages
PKG_IGNORED=${PKG_IGNORED:=""}

display_patches()
{
	local task=$1 ; shift
	local what=$1
	if [ "$what" = "--verbose" ] ; then shift ; what=1 ; else what=0 ; fi
	local list=`echo $@ | sed 's/;/ /g'`
	[ "$task" = "check" ] && echo "Packages need updating:"
	[ "$task" = "pdone" ] && echo "Packages already up-to-date:"
	[ "$task" = "nlist" ] && echo "Unknown patches:"
	local flag=0
	for loop in $list ; do
		local name=`echo $loop | cut -d':' -f1`
		local stat=`echo $loop | cut -d':' -f2`
		local temp=`echo $loop | cut -d':' -f3` # filename
		local vers=`echo $loop | cut -d':' -f4`
		if [ "$stat" == "$task" ] ; then
			flag=1
			[ $what -eq 0 ] && echo -n "$name " || echo "$name: $vers"
		fi
	done
	# prettify output
	if [ $flag -ne 0 ]; then
		[ $what -eq 0 ] && echo
	else
		[ "$task" = "check" ] && echo "** No updates found! **"
		[ "$task" = "pdone" ] && echo "** No up2date patches! **"
		[ "$task" = "nlist" ] && echo "** No unknown patches! **"
	fi
}

apply_patch()
{
	local temp=$1
	[ -z "$temp" ] && error_exit "No patch info given!\n\n"
	local root opts logs=/dev/null wait=0
	shift # first param is patch info
	while [ "$1" != "" ]; do
		case $1 in
			--root) shift ; must_have_path $1 ; root="ROOT=$1" ;;
			--logs) shift ; must_have_file $1 ; logs=$1 ;;
			--opts) shift ; opts="$opts $1" ;;
			--wait) wait=1 ;;
			*) error_exit "Unknown parameter '$1'!\n\n" ;;
		esac
		shift
	done
	local name=`echo $temp | cut -d':' -f1`
	local stat=`echo $temp | cut -d':' -f2`
	local file=`echo $temp | cut -d':' -f3`
	# check if can be applied
	echo "[DEBUG] '$stat' '$name' @ '$root' (opts:$opts;wait:$wait)"
	[ "$stat" != "check" ] && return # patch not needed
	[ ! -r "$file" ] && error_exit "File '$file' not found!\n\n"
	# prompt stuff
	local what="Auto-updating"
	local skip=0 # by default, we patch!
	# check if prompt requested
	if [ $wait -ne 0 ]; then
		what="Updating"
		skip=1 # assume skipped initially
		read -n 1 -p "Update '$name'? [y]/[*]/[q] : " temp ; echo
		case "$temp" in
			q|Q) warn_msg "Aborting on '$name'!\n\n" ; exit 0 ;;
			y|Y) skip=0 ;;
		esac
	fi
	# apply the patch! if NOT skipped...
	if [ $skip -eq 0 ]; then
		echo -n "$what '$name'... "
		echo "$root /sbin/upgradepkg $opts $file >>$logs"
		echo "done."
	fi
}

execute_patches()
{
	#echo "Parameter Check: $@"
	#echo "Parameter Count: ${#}"
	# get pkg request list.. and options
	local pkgs opts logs
	while [ "$1" != "" ]; do
		case $1 in
			--patches) shift ; break ;;
			--root) shift ; opts="$opts --root $1" ;;
			--opts) shift ; opts="$opts --opts $1" ;;
			--logs) shift ; must_have_file $1 ; logs=$1 ;;
			--wait) opts="$opts --wait" ;;
			*) pkgs="$pkgs $1" ;;
		esac
		shift
	done
	# get remaining - patches list!
	local list temp=`echo $@ | sed 's/;/ /g'`
	for loop in $temp ; do
		local name=`echo $loop | cut -d':' -f1`
		local stat=`echo $loop | cut -d':' -f2`
		local file=`echo $loop | cut -d':' -f3`
		local vers=`echo $loop | cut -d':' -f4`
		[ "$stat" != "check" ] && continue # patch not needed
		local that=`echo $pkgs | grep $name`
		[ "$pkgs" == "" -o "$that" != "" ] && list="${list}${loop} "
	done
	# browse through the check list
	if [ "$list" != "" ]; then
		# only root can apply patches!
		#must_be_root
		if [ "$logs" != "" ] ; then
			local init="$TOOL_NAME - $TOOL_DESC ($TOOL_VERS) - $(date)\n"
			echo -e $init >$logs
			opts="$opts --logs $logs"
		fi
		echo "Packages need updating:"
		for loop in $list ; do
			apply_patch $loop $opts
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
}

check_patch()
{
	local list=`echo $@ | sed 's/;/ /g'`
	for loop in $list ; do
		local stat=`echo $loop | cut -d':' -f2`
		[ "$stat" == "check" ] && exit 1
	done
	exit 0
}

process_command()
{
	local task temp path root opts what pure=0
	while [ "$1" != "" ]; do
		case $1 in
			--override) opts="$opts --opts --reinstall --opts --install-new" ;;
			--verbose) opts="$opts --wait" ; what="--verbose" ;;
			--log) opts="$opts --logs $TOOL_LOGS" ;;
			--pure) pure=1 ;;
			--path) shift ; path="${path}$1 " ;;
			--pack|--pkg) shift ; temp="${temp}$1 " ;;
			--help|-h) echo -e "$TOOL_HELP" && return 0 ;;
			--root) shift ; root=$1 ;;
			--skip) shift ; PKG_IGNORED="${PKG_IGNORED}$1 " ;;
			*) [ -z "$task" ] && task=$1 ||
				error_exit "Unknown param '$1'!\n\n" ;;
		esac
		shift
	done
	# check rootfs if specified
	if [ ! -z "$root" ] ; then
		[ ! -d "$root" ] && error_exit "Cannot find root '$root'!\n\n"
		root=`cd $root ; pwd`
		opts="--root $root $opts"
	fi
	call_setup $root
	[ ! -d "$SLACKTREE" ] &&
		error_exit "Cannot get info for slack in '$root'!\n\n"
	local pick
	# process discrete package list
	if [ ! -z "$temp" ] ; then
		for that in $temp ; do
			that=`find_install $that $SLACKPACK`
			[ "$that" == "" ] && error_exit "Unknown package '$that'!\n\n"
			pick=`get_pkg_info $that | cut -d' ' -f1`
		done
	fi
	# process extra package paths
	local more
	if [ $pure -eq 0 ] ; then
		temp=${SLACKROOT}/${SLACKFULL//ware/pack}
		[ -d $temp ] && more="--more $temp"
		if [ ! -z "$path" ] ; then
			for that in $path ; do
				[ ! -d "$that" ] && error_exit "Cannot find path '$that'!\n\n"
				that=`cd $that ; pwd`
				more="$more --more $that"
			done
		fi
	fi
	# if no command given, do a check
	[ "$task" == "" ] && task="check"
	if [ "$task" != "quiet" ] ; then
		local show
		[ "$root" != "" ] && show="@$root"
		echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
		echo "[$SLACKFULL$show]"
		echo -n "Looking for patches... "
	fi
	# find patches
	local tree="--tree $SLACKTREE"
	local skip="$PKG_IGNORED"
	local list=`list_patches $tree $more $skip`
	[ "$task" == "quiet" ] && check_patch $list
	echo -e "done!\n"
	[ "$task" != "patch" ] && display_patches $task $what $list
	[ "$task" == "patch" ] && execute_patches $pick $opts --patches $list
	echo ; exit 0
}

# BEGIN MAIN SCRIPT

process_command "$@"

# END MAIN SCRIPT
