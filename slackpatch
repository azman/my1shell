#!/bin/bash

# slackpatch
# - written by azman@my1matrix.net
# - slackware patch manager
# - using upgradepkg from pkgtools

# standard tool info
MY1_TOOLNAME="my1 Slackware Patch Tool"
MY1_TOOLVERS="2019.06.00"
MY1_TOOLBASE=`basename $0 .sh`
MY1_TOOLPATH=`dirname $0`
MY1_TOOL_LIB="libmy1slack"
# look for my1slack library
[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ] && . $MY1_TOOLPATH/$MY1_TOOL_LIB
# get slackware tree info
call_setup
# look for config file
for config in `pwd` $HOME; do
	config=$config/.$MY1_TOOLBASE
	[ -r $config ] && . $config && break
done

# my1slack tool specific
MY1_TOOL_LOG=${MY1_TOOL_LOG:="/tmp/${MY1_TOOLBASE}.log"}
MY1_SLACKDIR=${MY1_SLACKDIR:="${SLACKTREE}"}
MY1_PATCHDIR=${MY1_PATCHDIR:="${SLACKTREE}/patches/packages"}
MY1_SPACKDIR=${MY1_SPACKDIR:="${SLACKNAME//ware/pack}-$SLACKVERS"}
MY1_PATCHEXT=${MY1_PATCHEXT:="${SLACKROOT}/$MY1_SPACKDIR"}
# global options & settings
OPT_VERBOSE="NO"
OPT_LOGFILE="/dev/null"
OPT_UPGRADE=""
OPT_NOTHIRD="NO"
PKG_IGNORED=${PKG_IGNORED:=""} # std package to ignore
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
Options:
  --verbose : Verbose mode (will also prompt patching!)
  --log     : Write process & results to log file '$MY1_TOOL_LOG'
  --pkg <package_name>  : Check/update specific package
  --path <path_name>    : Specify additional patch path
  --skip <package_name> : Specify packages to skip
Mirror Source:
  $MY1_SLACKDIR
SETHELPMSG`

function check_patches()
{
	local pat_path pat_list pat_temp lnx_path
	[ ! -d $MY1_PATCHDIR ] &&
		error_exit "Path '$MY1_PATCHDIR' not found!"
	MY1_PATCHDIR=`cd $MY1_PATCHDIR ; pwd`
	pat_list=`list_package_path $MY1_PATCHDIR $SLACKLOGS $PKG_IGNORED`
	# look for paths for kernel patches
	lnx_path=`find $MY1_PATCHDIR -name "linux-*" -type d -maxdepth 1`
	for path in $lnx_path ; do
		pat_temp=`list_package_path $path $SLACKLOGS $PKG_IGNORED`
		pat_list="${pat_list}${pat_temp}"
	done
	if [ "$OPT_NOTHIRD" != "YES" ] ; then
		# look for extra custom package path
		if [ -d "$MY1_PATCHEXT" ] ; then
			pat_path=$MY1_PATCHEXT
			pat_temp=`list_package_path $pat_path $SLACKLOGS $PKG_IGNORED`
			pat_list="${pat_list}${pat_temp}"
		fi
		# process extra paths
		while [ "$1" != "" ] ; do
			pat_path=`cd $1 ; pwd`
			[ ! -d $pat_path ] && error_exit "Path '$pat_path' is invalid!"
			pat_temp=`list_package_path $pat_path $SLACKLOGS $PKG_IGNORED`
			pat_list="${pat_list}${pat_temp}"
			shift
		done
	fi
	echo -n "$pat_list"
}

function apply_patch()
{
	local pat_temp pat_name pat_stat pat_file do_update
	pat_temp="$@"
	pat_name=`echo $pat_temp | cut -d':' -f1`
	pat_stat=`echo $pat_temp | cut -d':' -f2`
	pat_file=`echo $pat_temp | cut -d':' -f3`
	# check if can be applied
	[ "$pat_stat" != "check" ] && return # patch not needed
	[ ! -r "$pat_file" ] &&
		error_exit "File '$pat_file' not found!"
	# apply the patch!
	if [ "$OPT_VERBOSE" == "YES" ]; then
		read -n 1 -p "Update '$pat_name'? [y]/[*]/[q] : " do_update ; echo
		if [ "$do_update" == "y" ]; then
			echo -n "Updating '$pat_name'... "
			/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
			echo "done."
		elif [ "$do_update" == "q" ]; then
			warn_msg "Aborting on '$pat_name'!"
			exit 0
		fi
	elif [ "$OPT_VERBOSE" == "NO" ]; then
		echo -n "Auto-updating '$pat_name'... "
		/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
		echo "done."
	fi
}

function display_patches()
{
	local pat_temp pat_name pat_stat pat_vers
	local pat_opts pat_list chk_null
	pat_opts=$1 ; shift ; pat_list=`echo "$@" | sed 's/;/ /g'`
	[ "$pat_opts" == "check" ] && echo "Packages need updating:"
	[ "$pat_opts" == "pdone" ] && echo "Packages already up-to-date:"
	[ "$pat_opts" == "nlist" ] && echo "Unknown patches:"
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_temp=`echo $pat_loop | cut -d':' -f3` # filename
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		if [ "$pat_stat" == "$pat_opts" ] ; then
			chk_null="NO"
			[ "$OPT_VERBOSE" == "NO" ] && echo -n "$pat_name "
			[ "$OPT_VERBOSE" == "YES" ] && echo "$pat_name: ${pat_vers}"
		fi
	done
	# prettify output
	if [ "$chk_null" == "NO" ]; then
		[ "$OPT_VERBOSE" == "NO" ] && echo
	else
		[ "$pat_opts" == "check" ] && echo "** No updates found! **"
		[ "$pat_opts" == "pdone" ] && echo "** No up2date patches! **"
		[ "$pat_opts" == "nlist" ] && echo "** No unknown patches! **"
	fi
}

function execute_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list pkg_list chk_list log_init
	#echo "Parameter Count: ${#}"
	# get pkg request list
	while [ "$1" != "" ]; do
		[ "$1" == "--patches" ] && shift && break;
		pkg_list="$pkg_list $1"
		shift
	done
	# get available patches list
	pat_list=`echo "$@" | sed 's/;/ /g'`
	# check for requested package
	for pat_loop in $pat_list ; do
		pat_name=`echo $pat_loop | cut -d':' -f1`
		pat_stat=`echo $pat_loop | cut -d':' -f2`
		pat_file=`echo $pat_loop | cut -d':' -f3`
		pat_vers=`echo $pat_loop | cut -d':' -f4`
		[ "$pat_stat" != "check" ] && continue # patch not needed
		pat_temp=`echo $pkg_list | grep $pat_name`
		if [ "$pkg_list" == "" -o "$pat_temp" != "" ] ; then
			chk_list="${chk_list}${pat_loop} "
		fi
	done
	# browse through the check list
	if [ ! -z "$chk_list" ]; then
		# only root can apply patches!
		must_be_root
		log_init="$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS) - $(date)\n"
		echo -e $log_init >$OPT_LOGFILE
		echo "Packages need updating:"
		for pat_loop in $chk_list ; do
			apply_patch $pat_loop
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
}

function process_command()
{
	local go_commands="check pdone nlist patch"
	local do_command
	local pkg_list pkg_temp pat_list
	# default?
	local pkg_path="$PKG_EXT_PATH"
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--verbose)
				OPT_VERBOSE="YES"
				;;
			--log)
				OPT_LOGFILE="$MY1_TOOL_LOG"
				;;
			--override)
				OPT_UPGRADE="--reinstall --install-new"
				;;
			--pure)
				OPT_NOTHIRD="YES"
				;;
			--path)
				shift
				# check additional path
				[ ! -d "$1" ] && error_exit "Cannot find path '$1'!"
				pkg_path="${pkg_path} "`cd $1 ; pwd`
				;;
			--pkg)
				shift
				# check discrete package name
				pkg_temp=`find_install $1 $SLACKPACK`
				[ "$pkg_temp" == "" ] && error_exit "Unknown package '$1'!"
				pkg_temp=`get_pkg_info $pkg_temp | cut -d' ' -f1`
				pkg_list="${pkg_list} ${pkg_temp}"
				;;
			-*)
				error_exit "Unknown option '$1'!"
				;;
			*)
				[ "$do_command" != "" ] &&
					error_exit "Multiple commands '$1' & '$do_command'"
				for tcommand in $go_commands; do
					[ "$1" == "$tcommand" ] && do_command=$1 && break
				done
				[ "$do_command" == "" ] && echo -e "$MSG_THISHELP" &&
					error_exit "Unknown command '$1'!"
				;;
		esac
		shift
	done
	# if no command given, do a check
	[ "$do_command" == "" ] && do_command="check"
	# find patches
	echo -n "Looking for patches... "
	pat_list=`check_patches $pkg_path`
	echo -e "done!\n"
	# display packages
	[ "$do_command" != "patch" ] &&
		display_patches $do_command "$pat_list"
	# patch packages
	[ "$do_command" == "patch" ] &&
		execute_patches $pkg_list --patches "$pat_list"
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
