#!/bin/bash

# slackpatch
# - written by azman@my1matrix.net
# - slackware patch manager

# standard tool info
MY1_TOOLNAME="my1 Slackware Patch Tool"
MY1_TOOLVERS="2012.03.00"
MY1_TOOLBASE=$(basename $0 .sh)
MY1_TOOLPATH=$(cd $(dirname $0);pwd)
MY1_TOOL_LIB="libmy1slack"
# look for config file
for config in $(pwd) $MY1_TOOLPATH $HOME; do
	config=$config/.$MY1_TOOLBASE
	[[ ! -f $config ]] && continue
	source $config ; break
done
# look for my1slack library
[[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ]] &&
	source $MY1_TOOLPATH/$MY1_TOOL_LIB

# my1slack tool specific
MY1_SLACKDIR=${MY1_SLACKDIR:="${SLACKROOTDIR}/${SLACKRELEASE}"}
MY1_PATCHDIR=${MY1_PATCHDIR:="${MY1_SLACKDIR}/patches/packages"}
MY1_LOG_FILE=${MY1_LOG_FILE:="${MY1_TOOLPATH}/${MY1_TOOLBASE%%.*}.log"}
# global options & settings
OPT_FULLINFO="NO"
OPT_AUTOPATCH="YES"
OPT_LOGFILE="/dev/null"
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
  help  : Show this help message
Options:
  --short  : Short Info
  --full   : Full Info
  --prompt : Prompt Before Patching
  --auto   : Auto-Patch
  --log    : Write to log file
  --path <path_name> : Specify additional patch path
  --pkg <package_name> : Auto-Patch Implied!
Mirror Source:
  $MY1_SLACKDIR
Log File:
  $MY1_LOG_FILE
SETHELPMSG
)

function find_patches()
{
	local pat_exts pat_base pat_name
	local pat_vers pat_arch pat_extd
	local pkg_temp pkg_base pkg_name
	local pkg_vers pkg_arch pkg_extd
	local chk_name chk_stat chk_file chk_vers
	local chk_path=$(pwd)
	# process all package files
	for pat_file in *.t[gx]z; do
		# check extension first
		pat_exts="${pat_file##*.}"
		pat_base="${pat_file%%.${pat_exts}}"
		# get particulars
		pkg_temp=($(get_pkg_info $pat_base))
		pat_name="${pkg_temp[0]}"
		pat_vers="${pkg_temp[1]}"
		pat_arch="${pkg_temp[2]}"
		pat_extd="${pkg_temp[3]}"
		# populate information
		chk_name="$pat_name"
		chk_file="${chk_path}/${pat_file}"
		chk_vers="[${pat_vers}/${pat_extd}]"
		# find installed
		pkg_base="$(find_install $pat_name)"
		if [[ "$pkg_base" != "" ]]; then
			pkg_temp=($(get_pkg_info $pkg_base))
			pkg_name="${pkg_temp[0]}"
			pkg_vers="${pkg_temp[1]}"
			pkg_arch="${pkg_temp[2]}"
			pkg_extd="${pkg_temp[3]}"
			# warn if for different arch!
			[[ "$pkg_arch" != "$pat_arch" ]] &&
				warn_msg "Mismatched arch for '$pat_name'! \
					($pat_arch)/($pkg_arch)"
			# check version update
			if [[ "$pkg_vers" == "$pat_vers" ]] &&
				[[ "$pkg_extd" == "$pat_extd" ]]; then
				chk_stat="pdone"
			else
				chk_stat="check"
				chk_vers="[${pkg_vers}/${pkg_extd}]->[${pat_vers}/${pat_extd}]"
			fi
		else
			chk_stat="nlist"
		fi
		echo "$chk_name $chk_stat $chk_file $chk_vers"
	done
}

function check_patches()
{
	local pat_path pat_list
	local lnx_path chk_path=$(pwd)
	MY1_PATCHDIR=$(cd $MY1_PATCHDIR;pwd)
	[[ ! -d $MY1_PATCHDIR ]] &&
		error_exit "Path '$MY1_PATCHDIR' not found!"
	cd $MY1_PATCHDIR
	pat_list=$(find_patches)
	# look for paths for kernel patches
	lnx_path=$(find . -name "linux-*" -type d -maxdepth 1)
	for path in $lnx_path; do
		cd $path
		pat_list="${pat_list}$(find_patches)"
		cd $MY1_PATCHDIR
	done
	# process extra paths
	while [[ "$1" != "" ]]; do
		pat_path=$(cd $1;pwd)
		[[ ! -d $pat_path ]] && 
			error_exit "Path '$pat_path' is invalid!"
		cd $pat_path
		pat_list="${pat_list}$(find_patches)"
		cd - >/dev/null
		shift
	done
	echo -n "$pat_list"
}

function apply_patch()
{
	local pat_temp pat_name pat_stat pat_file do_update
	pat_temp=($(echo "$@"))
	pat_name=${pat_temp[0]}
	pat_stat=${pat_temp[1]}
	pat_file=${pat_temp[2]}
	# check if can be applied
	[[ "$pat_stat" != "check" ]] && return # patch not needed
	[[ ! -r "$pat_file" ]] &&
		error_exit "File '$pat_file' not found!"
	# apply the patch!
	if [[ "$OPT_AUTOPATCH" == "NO" ]] ; then
		read -n 1 -p "Update '$pat_name'? [y]/[*]/[q] : " do_update ; echo
		if [[ "$do_update" == "y" ]]; then
			echo -n "Updating '$pat_name'... "
			/sbin/upgradepkg ${pat_file} >>$OPT_LOGFILE
			echo "done."
		elif [[ "$do_update" == "q" ]]; then
			warn_msg "Aborting on '$pat_name'!"
			exit 0
		fi
	elif [[ "$OPT_AUTOPATCH" == "YES" ]] ; then
		echo -n "Auto-updating '$pat_name'... "
		/sbin/upgradepkg ${pat_file} >>$OPT_LOGFILE
		echo "done."
	fi
}

function display_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list chk_null
	pat_opts=$1 ; shift ; pat_list=("$@")
	#echo "Patch Count: ${#pat_list[@]}"
	[[ "$pat_opts" == "check" ]] && echo "Packages need updating:"
	[[ "$pat_opts" == "pdone" ]] && echo "Packages already up-to-date:"
	[[ "$pat_opts" == "nlist" ]] && echo "Unknown patches:"
	for (( a=0;a<${#pat_list[@]};a++ )); do
		pat_temp=($(echo ${pat_list[$a]}))
		pat_name=${pat_temp[0]}
		pat_stat=${pat_temp[1]}
		#pat_file=${pat_temp[2]}
		pat_vers=${pat_temp[3]}
		#echo "Check: ${pat_temp[0]}, (${pat_stat}:${pat_opts})"
		if [[ "$pat_stat" == "$pat_opts" ]] ; then
			chk_null="NO"
			[[ "$OPT_FULLINFO" == "NO" ]] && echo -n "$pat_name "
			[[ "$OPT_FULLINFO" == "YES" ]] && echo "$pat_name: ${pat_vers}"
		fi
	done
	# prettify output
	if [[ "$chk_null" == "NO" ]] ; then
		[[ "$OPT_FULLINFO" != "YES" ]] && echo
	else
		[[ "$pat_opts" == "check" ]] && echo "** No updates found! **"
		[[ "$pat_opts" == "pdone" ]] && echo "** No up2date patches! **"
		[[ "$pat_opts" == "nlist" ]] && echo "** No unknown patches! **"
	fi
	echo
}

function execute_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list pkg_list chk_list log_init
	#echo "Parameter Count: ${#}"
	# only root can apply patches!
	must_be_root 
	# get pkg request list
	while [[ "$1" != "" ]]; do
		[[ "$1" == "--patches" ]] && break;
		pkg_list="$pkg_list $1"
		shift
	done
	pkg_list=($(echo $pkg_list))
	# get available patches list
	shift && pat_list=("$@")
	# check for requested package
	for (( x=0,y=0;x<${#pat_list[@]};x++ )); do
		pat_temp=($(echo ${pat_list[$x]}))
		pat_name=${pat_temp[0]}
		pat_stat=${pat_temp[1]}
		pat_file=${pat_temp[2]}
		if [[ ${#pkg_list[@]} -eq 0 ]] ||
			[[ "$(echo ${pkg_list[@]} | grep $pat_name)" != "" ]] ; then
			chk_list[$y]="$pat_name $pat_stat $pat_file"
			(( y++ ))
		fi
	done
	#echo "Check Count: ${#chk_list[@]}"
	# browse through the check list
	if [[ ${#chk_list[@]} -gt 0 ]]; then
		log_init="$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS) - $(date)\n"
		echo -e $log_init >$OPT_LOGFILE
		echo "Packages need updating:"
		for (( x=0;x<${#chk_list[@]};x++ )); do
			apply_patch "${chk_list[$x]}"
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
	echo
}

function process_command()
{
	local go_commands="check pdone nlist patch"
	local do_command
	local pkg_list pkg_path pkg_temp pat_list
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--short)
				OPT_FULLINFO="NO"
				;;
			--full)
				OPT_FULLINFO="YES"
				;;
			--prompt)
				OPT_AUTOPATCH="NO"
				;;
			--auto)
				OPT_AUTOPATCH="YES"
				;;
			--log)
				OPT_LOGFILE="$MY1_LOG_FILE"
				;;
			--path)
				shift
				# check additional path
				[[ ! -d "$1" ]] && error_exit "Cannot find path '$1'!"
				pkg_path="${pkg_path} $(cd $1;pwd)"
				;;
			--pkg)
				shift
				# check discrete package name
				pkg_temp=$(find_install $1)
				[[ "$pkg_temp" == "" ]] && error_exit "Unknown package '$1'!"
				pkg_temp=($(get_pkg_info $pkg_temp))
				pkg_temp="${pkg_temp[0]}"
				pkg_list="${pkg_list} ${pkg_temp}"
				;;
			--help|-h|help)
				echo "$MSG_THISHELP"
				exit 0
				;;
			-*)
				error_exit "Unknown option '$1'!"
				;;
			*)
				[[ "$do_command" != "" ]] &&
					error_exit "Multiple commands '$1' & '$do_command'"
				for tcommand in $go_commands; do
					[[ "$1" == "$tcommand" ]] && do_command=$1 && break
				done
				[[ "$do_command" == "" ]] &&
					error_exit "Unknown command '$1'!"
				;;
		esac
		shift
	done
	# exit if no command...
	[[ "$do_command" == "" ]] && echo "$MSG_THISHELP!" && exit 0
	# find patches
	pat_list=$(check_patches $pkg_path)
	SAVE_IFS=$IFS
	IFS='
'
	pat_list=($(echo "$pat_list"))
	IFS=$SAVE_IFS
	# display packages
	[[ "$do_command" != "patch" ]] &&
		display_patches $do_command "${pat_list[@]}"
	# patch packages
	[[ "$do_command" == "patch" ]] &&
		execute_patches $pkg_list --patches "${pat_list[@]}"
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"

# END MAIN SCRIPT
