#!/bin/bash

# slackpatch
# - written by azman@my1matrix.net
# - slackware patch manager
# - using upgradepkg from pkgtools

# standard tool info
MY1_TOOLNAME="my1 Slackware Patch Tool"
MY1_TOOLVERS="2015.04.01"
MY1_TOOLBASE=$(basename $0 .sh)
MY1_TOOLPATH=$(cd $(dirname $0);pwd)
MY1_TOOL_LIB="libmy1slack"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1_TOOLBASE
	[ -r $config ] && source $config && break
done
# look for my1slack library
[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ] && source $MY1_TOOLPATH/$MY1_TOOL_LIB

# my1slack tool specific
MY1_TOOL_LOG=${MY1_TOOL_LOG:="/tmp/${MY1_TOOLBASE}.log"}
MY1_SLACKDIR=${MY1_SLACKDIR:="${SLACKRELPATH}"}
MY1_PATCHDIR=${MY1_PATCHDIR:="${MY1_SLACKDIR}/patches/packages"}
MY1_PATCHEXT=${MY1_PATCHEXT:="${MY1_TOOLPATH}/../slackpack"}
# global options & settings
OPT_VERBOSE="NO"
OPT_LOGFILE="$MY1_TOOL_LOG"
OPT_UPGRADE=""
PKG_EXTPATH=${PKG_EXTPATH:=""} # extra package source to check
PKG_IGNORED=${PKG_IGNORED:=""} # std package to ignore
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  check : Check patch status (find relevant patches)
  pdone : List patches that has been applied
  nlist : List patches NOT in update list (not used)
  patch : Apply updates/patches
Options:
  --verbose : Verbose mode (will also prompt patching!)
  --log     : Write process & results to log file
  --path <path_name>   : Specify additional patch path
  --pkg <package_name> : Check/update specific package
Mirror Source:
  $MY1_SLACKDIR
Log File:
  $MY1_TOOL_LOG
SETHELPMSG
)

function find_patches()
{
	local pat_exts pat_base pat_name
	local pat_vers pat_arch pat_extd
	local pkg_temp pkg_base pkg_name
	local pkg_vers pkg_arch pkg_extd
	local chk_name chk_stat chk_file chk_vers
	local chk_path=$(pwd)
	# process all package files
	for pat_file in *.t[gx]z; do
		# check extension first
		pat_exts="${pat_file##*.}"
		pat_base="${pat_file%%.${pat_exts}}"
		# get particulars
		pkg_temp=($(get_pkg_info $pat_base))
		pat_name="${pkg_temp[0]}"
		pat_vers="${pkg_temp[1]}"
		pat_arch="${pkg_temp[2]}"
		pat_extd="${pkg_temp[3]}"
		# check ignore list
		[ "$(echo "$@" | grep "$pat_name")" != "" ] && continue
		# populate information
		chk_name="$pat_name"
		chk_file="${chk_path}/${pat_file}"
		chk_vers="[${pat_vers}/${pat_extd}]"
		# find installed
		pkg_base="$(find_install $pat_name)"
		if [ "$pkg_base" != "" ]; then
			pkg_temp=($(get_pkg_info $pkg_base))
			pkg_name="${pkg_temp[0]}"
			pkg_vers="${pkg_temp[1]}"
			pkg_arch="${pkg_temp[2]}"
			pkg_extd="${pkg_temp[3]}"
			# skip if for different arch!
			[ "$pkg_arch" != "$pat_arch" ] && continue
			# check version update
			if [ "$pkg_vers" == "$pat_vers" ] &&
				[ "$pkg_extd" == "$pat_extd" ]; then
				chk_stat="pdone"
			else
				chk_stat="check"
				chk_vers="[${pkg_vers}/${pkg_extd}]->[${pat_vers}/${pat_extd}]"
			fi
		else
			local chk_arch sys_arch="x86"
			[ "$SLACKARCH" == "64" ] && sys_arch="x86_64"
			case $pat_arch in
				i*86) chk_arch="x86" ;;
				x86_64) chk_arch="x86_64" ;;
				noarch) chk_arch="$sys_arch" ;;
				*) chk_arch=""
			esac
			[ "$chk_arch" != "$sys_arch" ] && continue
			chk_stat="nlist"
		fi
		echo "$chk_name $chk_stat $chk_file $chk_vers "
		#echo "$pat_file $chk_stat" 1>&2
	done
}

function check_patches()
{
	local pat_path pat_list
	local lnx_path chk_path=$(pwd)
	MY1_PATCHDIR=$(cd $MY1_PATCHDIR;pwd)
	[ ! -d $MY1_PATCHDIR ] &&
		error_exit "Path '$MY1_PATCHDIR' not found!"
	cd $MY1_PATCHDIR
	pat_list=$(find_patches $PKG_IGNORED)
	# look for paths for kernel patches
	lnx_path=$(find . -name "linux-*" -type d -maxdepth 1)
	for path in $lnx_path; do
		cd $path
		pat_list="${pat_list}"$'\n'"$(find_patches $PKG_IGNORED)"
		cd - > /dev/null
	done
	# look for extra custom package path
	if [ -d $MY1_PATCHEXT ]; then
		cd $MY1_PATCHEXT
		pat_list="${pat_list}"$'\n'"$(find_patches $PKG_IGNORED)"
		cd - > /dev/null
	fi
	# process extra paths
	while [ "$1" != "" ]; do
		pat_path=$(cd $1;pwd)
		[ ! -d $pat_path ] &&
			error_exit "Path '$pat_path' is invalid!"
		cd $pat_path
		pat_list="${pat_list}$(find_patches)"
		cd - >/dev/null
		shift
	done
	#echo -n "=>$(echo "$pat_list"|wc -l) " 1>&2
	echo -n "$pat_list"
}

function apply_patch()
{
	local pat_temp pat_name pat_stat pat_file do_update
	pat_temp=($(echo "$@"))
	pat_name=${pat_temp[0]}
	pat_stat=${pat_temp[1]}
	pat_file=${pat_temp[2]}
	# check if can be applied
	[ "$pat_stat" != "check" ] && return # patch not needed
	[ ! -r "$pat_file" ] &&
		error_exit "File '$pat_file' not found!"
	# prepare log file?
	echo -n "" >$OPT_LOGFILE
	# apply the patch!
	if [ "$OPT_VERBOSE" == "YES" ]; then
		read -n 1 -p "Update '$pat_name'? [y]/[*]/[q] : " do_update ; echo
		if [ "$do_update" == "y" ]; then
			echo -n "Updating '$pat_name'... "
			/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
			echo "done."
		elif [ "$do_update" == "q" ]; then
			warn_msg "Aborting on '$pat_name'!"
			exit 0
		fi
	elif [ "$OPT_VERBOSE" == "NO" ]; then
		echo -n "Auto-updating '$pat_name'... "
		/sbin/upgradepkg $OPT_UPGRADE ${pat_file} >>$OPT_LOGFILE
		echo "done."
	fi
}

function display_patches()
{
	local pat_temp pat_name pat_stat pat_vers
	local pat_opts pat_list chk_null
	pat_opts=$1 ; shift ; pat_list=("$@")
	#echo "Patch Count: ${#pat_list[@]}"
	[ "$pat_opts" == "check" ] && echo "Packages need updating:"
	[ "$pat_opts" == "pdone" ] && echo "Packages already up-to-date:"
	[ "$pat_opts" == "nlist" ] && echo "Unknown patches:"
	for (( a=0;a<${#pat_list[@]};a++ )); do
		pat_temp=($(echo ${pat_list[$a]}))
		pat_name=${pat_temp[0]}
		pat_stat=${pat_temp[1]}
		pat_vers=${pat_temp[3]}
		#echo "Check: ${pat_temp[2]} (${pat_stat}:${pat_opts})[$a]"
		if [ "$pat_stat" == "$pat_opts" ] ; then
			chk_null="NO"
			[ "$OPT_VERBOSE" == "NO" ] && echo -n "$pat_name "
			[ "$OPT_VERBOSE" == "YES" ] && echo "$pat_name: ${pat_vers}"
		fi
	done
	# prettify output
	if [ "$chk_null" == "NO" ]; then
		[ "$OPT_VERBOSE" == "NO" ] && echo
	else
		[ "$pat_opts" == "check" ] && echo "** No updates found! **"
		[ "$pat_opts" == "pdone" ] && echo "** No up2date patches! **"
		[ "$pat_opts" == "nlist" ] && echo "** No unknown patches! **"
	fi
}

function execute_patches()
{
	local pat_temp pat_name pat_stat pat_file pat_vers
	local pat_opts pat_list pkg_list chk_list log_init
	#echo "Parameter Count: ${#}"
	# get pkg request list
	while [ "$1" != "" ]; do
		[ "$1" == "--patches" ] && break;
		pkg_list="$pkg_list $1"
		shift
	done
	pkg_list=($(echo $pkg_list))
	# get available patches list
	shift ; pat_list=("$@")
	# check for requested package
	for (( x=0,y=0;x<${#pat_list[@]};x++ )); do
		pat_temp=($(echo ${pat_list[$x]}))
		pat_name=${pat_temp[0]}
		pat_stat=${pat_temp[1]}
		pat_file=${pat_temp[2]}
		[ "$pat_stat" != "check" ] && continue # patch not needed
		if [ ${#pkg_list[@]} -eq 0 ] ||
			[ "$(echo ${pkg_list[@]} | grep $pat_name)" != "" ] ; then
			chk_list[$y]="$pat_name $pat_stat $pat_file"
			(( y++ ))
		fi
	done
	#echo "Check Count: ${#chk_list[@]}"
	# browse through the check list
	if [ ${#chk_list[@]} -gt 0 ]; then
		# only root can apply patches!
		must_be_root
		log_init="$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS) - $(date)\n"
		echo -e $log_init >$OPT_LOGFILE
		echo "Packages need updating:"
		for (( x=0;x<${#chk_list[@]};x++ )); do
			apply_patch "${chk_list[$x]}"
		done
	else
		echo "** Nothing to patch/upgrade! **"
	fi
}

function process_command()
{
	local go_commands="check pdone nlist patch"
	local do_command
	local pkg_list pkg_temp pat_list
	# default?
	local pkg_path="$PKG_EXT_PATH"
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--verbose)
				OPT_VERBOSE="YES"
				;;
			--log)
				OPT_LOGFILE="$MY1_TOOL_LOG"
				;;
			--override)
				OPT_UPGRADE="--reinstall --install-new"
				;;
			--path)
				shift
				# check additional path
				[ ! -d "$1" ] && error_exit "Cannot find path '$1'!"
				pkg_path="${pkg_path} $(cd $1;pwd)"
				;;
			--pkg)
				shift
				# check discrete package name
				pkg_temp=$(find_install $1)
				[ "$pkg_temp" == "" ] && error_exit "Unknown package '$1'!"
				pkg_temp=($(get_pkg_info $pkg_temp))
				pkg_temp="${pkg_temp[0]}"
				pkg_list="${pkg_list} ${pkg_temp}"
				;;
			-*)
				error_exit "Unknown option '$1'!"
				;;
			*)
				[ "$do_command" != "" ] &&
					error_exit "Multiple commands '$1' & '$do_command'"
				for tcommand in $go_commands; do
					[ "$1" == "$tcommand" ] && do_command=$1 && break
				done
				[ "$do_command" == "" ] && echo -e "$MSG_THISHELP" &&
					error_exit "Unknown command '$1'!"
				;;
		esac
		shift
	done
	# if no command given, do a check
	[ "$do_command" == "" ] && do_command="check"
	# find patches
	echo -n "Looking for patches... "
	pat_list=$(check_patches $pkg_path)
	local ifs_save=$IFS
	IFS=$'\n'
	pat_list=($(echo "$pat_list"))
	IFS=$ifs_save
	echo -e "done!\n"
	# display packages
	[ "$do_command" != "patch" ] &&
		display_patches $do_command "${pat_list[@]}"
	# patch packages
	[ "$do_command" == "patch" ] &&
		execute_patches $pkg_list --patches "${pat_list[@]}"
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
