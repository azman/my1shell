#!/bin/bash

# slackview
# - written by azman@my1matrix.net
# - slackware package info viewer

# standard tool info
MY1_TOOLNAME="my1 Slackware Package Viewer Tool"
MY1_TOOLVERS="2019.06.00"
MY1_TOOLBASE=`basename $0 .sh`
MY1_TOOLPATH=`dirname $0`
MY1_TOOL_LIB="libmy1slack"
# look for my1slack library
[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ] && . $MY1_TOOLPATH/$MY1_TOOL_LIB
# get slackware tree info
call_setup
# prepare help message
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  find   : Find package(s) in mirror@installation
         > --alien    : Find & list alien package(s)
         > {pkg_name} : Find & display package info
  file   : Manage File for package list
         > --insert   : Insert package to list
         > --delete   : Delete package from list
         > --update   : Update packages on list
         > --sort     : Sort packages on list
         > --name     : Specify filename
         > --pack     : Select official software set
  help   : Show this help message
Mirror Source:
  $SLACKTREE
SETHELPMSG`

function view_alien_pkgs()
{
	local do_echo="YES"
	local log_path="/var/log/packages"
	# find installed
	for pkg_base in `ls $log_path` ; do
		local pkg_name=`get_pkg_info $pkg_base | cut -d' ' -f1`
		local pkg_test=`find_package $pkg_name $SLACKPACK`
		if [ "$pkg_test" == "" ]; then
			echo "Alien package: $pkg_name ($pkg_base)"
			do_echo="NO"
		fi
	done
	[ "$do_echo" == "YES" ] && info_msg "No alien package found!\n"
}

function view_show_pkgs()
{
	for pkg_name in "$@"; do
		show_info $pkg_name $SLACKPACK
		[ $? -eq 0 ] && continue
		warn_msg "Unknown package '$pkg_name'!\n"
	done
}

function view_find_package()
{
	local pkg_list
	while [ "$1" != "" ]; do
		case "$1" in
			--alien)
				view_alien_pkgs
				return
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	view_show_pkgs $pkg_list
}

function file_pack_part()
{
	local pkg_name=$1
	local pkg_soft=`get_packsoft $SLACKPACK $pkg_name`
	local pkg_part="${pkg_soft}!${pkg_name}" # pkg_soft=z for unknown
	echo -n $pkg_part
}

function file_insert_package()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	# we may get more than 1 matching entries
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	pkg_temp=`file_pack_part $pkg_name`
	if [ -z "$pkg_test" ]; then
		pkg_test=`find_package $pkg_name $SLACKPACK`
		[ "$pkg_test" == "" ] &&
			echo "PACKAGE: [INSERT] => $pkg_name (FAILED!)" && return
		# insert if no matching entry
		echo "$pkg_temp" >>$pkg_file
		echo "PACKAGE: [INSERT] => $pkg_temp ($pkg_test)"
	else
		if [ "$pkg_test" == "$pkg_temp" ] ; then
			pkg_test=`echo $pkg_temp | cut -d'!' -f1`
			if [ "$pkg_test" != "z" ] ; then
				pkg_test=`find_package $pkg_name $SLACKPACK`
			else
				pkg_test="EXTERNAL PACKAGE?"
			fi
		fi
		# update if existing found
		sed -i -e "\|^$pkg_test\$|c\\$pkg_temp" $pkg_file
		[ $? -ne 0 ] && pkg_test="$FAILED!"
		echo "PACKAGE: [UPDATE] => $pkg_temp ($pkg_test)"
	fi
}

function file_remove_package()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	if [ -z "$pkg_test" ]; then
		echo "PACKAGE: [REMOVE] => $pkg_name not found in list!"
	else
		# remove if existing found
		sed -i -e "\|^$pkg_test\$|d" $pkg_file
		[ $? -ne 0 ] && pkg_test="$pkg_test (FAILED!)"
		echo "PACKAGE: [REMOVE] => $pkg_test"
	fi
}

function file_option_package()
{
	local pkg_temp pkg_test do_select
	local pkg_file=$1
	local pkg_name=$2
	local pkg_stat="UNKNOWN"
	# interactive
	local pkg_base=`find_package $pkg_name $SLACKPACK`
	[ "$pkg_base" != "" ] && show_info $pkg_name $SLACKPACK
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	if [ "$pkg_test" == "" ]; then
		pkg_stat="EXCLUDED"
	else
		pkg_test=`find_package $pkg_temp $SLACKPACK`
		pkg_compare $pkg_test $pkg_base
		[ $? -ne 0 ] && pkg_stat="INCLUDED"
	fi
	echo -ne "\nStatus: $pkg_stat >> "
	read -n 1 -p "Command ([i]nsert/[d]elete/[*]): " do_select ; echo
	if [ "$do_select" == "i" ]; then
		file_insert_package $pkg_file $pkg_name
	elif [ "$do_select" == "d" ]; then
		file_remove_package $pkg_file $pkg_name
	fi
}

function file_update_packages()
{
	local pkg_temp pkg_name pkg_base
	local pkg_file=$1
	local pkg_list=`cat $pkg_file`
	# browse packages on file
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f1`
		pkg_name=`echo $pkg_loop | cut -d'!' -f2`
		pkg_base=`find_package $pkg_name $SLACKPACK`
		file_insert_package $pkg_file $pkg_name
	done
}

function view_file_package()
{
	local pkg_list pkg_file pkg_temp pkg_name
	local do_select
	while [ "$1" != "" ]; do
		case "$1" in
			--insert)
				do_select="YES"
				;;
			--delete|--remove)
				do_select="INV"
				;;
			--update)
				do_select="UPD"
				;;
			--sort)
				do_select="SOT"
				;;
			--name)
				shift
				pkg_file="$1"
				;;
			--pack)
				shift
				pkg_temp=`get_pathsoft $SLACKPACK $1`
				for pkg in $pkg_temp ; do
					pkg_name=`get_pkg_info $pkg | cut -d' ' -f1`
					pkg_list="${pkg_list}${pkg_name} "
				done
				;;
			-*)
				echo -e "Unknown option '$1'! Aborting!\n"
				exit 1
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	# check package file - create if needed
	[ "$pkg_file" == "" ] && error_exit "No package list given!"
	[ ! -f "$pkg_file" ] && touch "$pkg_file"
	[ ! -r "$pkg_file" ] && error_exit "Cannot read '$pkg_file'!"
	# check request to update file
	[ "$do_select" == "UPD" ] &&
		file_update_packages $pkg_file && return
	# check sort request
	if [ "$do_select" == "SOT" ]; then
		echo -n "Sorting (with uniq) $pkg_file..."
		cat $pkg_file | uniq | sort -o $pkg_file
		echo " done!"
		return
	fi
	# check if list is empty
	[ "$pkg_list" == "" ] &&
		error_exit "No package selected? Nothing to do!"
	# process the given package list
	for pkg in $pkg_list; do
		case $do_select in
			YES) file_insert_package $pkg_file $pkg ;;
			INV) file_remove_package $pkg_file $pkg ;;
			*) file_option_package $pkg_file $pkg ;;
		esac
	done
}

function process_command()
{
	local tool_cmd
	local pkgs_txt=$SLACKTREE/PACKAGES.TXT
	local log_path="/var/log/packages"
	[ ! -f $pkgs_txt ] &&
		error_exit "File '$pkgs_txt' not found! Aborting!"
	[ ! -d $log_path ] &&
		error_exit "'$log_path' not found! Aborting!"
	tool_cmd=$1; shift
	case "$tool_cmd" in
		find)
			view_find_package "$@"
			;;
		file)
			view_file_package "$@"
			;;
		*)
			echo -e "$MSG_THISHELP\n" && exit 0
			;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
