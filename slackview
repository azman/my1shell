#!/bin/bash

# slackview
# - written by azman@my1matrix.net
# - slackware package info viewer

# standard tool info
TOOL_NAME="my1 Slackware Package Viewer Tool"
TOOL_VERS="2019.06.00"
TOOL_BASE=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH ; pwd`

source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}

source_lib libmy1slack
source_lib libmy1echo

# get slackware tree info
call_setup
# prepare help message
MSG_THISHELP=`cat <<SETHELPMSG
Usage:
  $TOOL_BASE <command> [options]
Commands:
  find   : Find package(s) in mirror@installation
         > --alien    : Find & list alien package(s)
         > {pkg_name} : Find & display package info
  file   : Manage File for package list
         > --insert   : Insert package to list
         > --delete   : Delete package from list
         > --update   : Update packages on list
         > --sort     : Sort packages on list
         > --name <>  : Specify filename
         > --dups <>  : Remove duplicates from filename
         > --pack <>  : Select official software set
  help   : Show this help message
Mirror Source:
  $SLACKTREE
SETHELPMSG`

view_alien_pkgs()
{
	local do_echo="YES"
	local log_path="/var/log/packages"
	# find installed
	for pkg_base in `ls $log_path` ; do
		local pkg_name=`get_pkg_info $pkg_base | cut -d' ' -f1`
		local pkg_test=`find_package $pkg_name $SLACKPACK`
		if [ "$pkg_test" == "" ]; then
			echo "Alien package: $pkg_name ($pkg_base)"
			do_echo="NO"
		fi
	done
	[ "$do_echo" == "YES" ] && info_msg "No alien package found!\n"
}

show_info()
{
	# get package info
	local pkg_name=$1
	local pkg_pack=$2 # slackpack
	local pkg_flag pkg_find pkg_stat pkg_soft
	local pkg_info=`find_install $pkg_name --full $pkg_pack`
	local pkg_test=`find_package $pkg_name --full $pkg_pack`
	[ "$pkg_info" == "" ] && pkg_flag="NOT " && pkg_info=$pkg_test
	[ "$pkg_info" == "" ] && return 1
	[ "$pkg_test" == "" ] && pkg_stat=" (ALIEN!)" || \
		pkg_soft=`echo $pkg_test | cut -d' ' -f3`
	[ "$pkg_soft" != "" ] && pkg_soft="("`basename $pkg_soft`")"
	# info structure?
	local pkg_base pkg_file pkg_path pkg_size pkg_full
	pkg_base=`echo $pkg_info | cut -d' ' -f1`
	pkg_file=`echo $pkg_info | cut -d' ' -f2`
	pkg_path=`echo $pkg_info | cut -d' ' -f3`
	pkg_size=`echo $pkg_info | cut -d' ' -f4`
	pkg_full=`echo $pkg_info | cut -d' ' -f5`
	[ ! -f $pkg_path/$pkg_file ] && pkg_find="NOT "
	local pkg_temp pkg_name pkg_vers pkg_arch pkg_extd
	pkg_temp=`get_pkg_info $pkg_base`
	pkg_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg_extd=`echo $pkg_temp | cut -d' ' -f4`
	# do the printing
	local title="PACKAGE <$pkg_name> - BEGIN"
	local trail="PACKAGE <$pkg_name> - END"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "$title"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "FILE               : ${pkg_file}${pkg_stat} $pkg_soft"
	echo "LOCATION           : $pkg_path"
	echo "VERSION            : $pkg_vers"
	echo "ARCHITECTURE       : $pkg_arch"
	echo "BUILD TAG          : $pkg_extd"
	echo "SIZE (Compressed)  : $pkg_size"
	echo "SIZE (Uncompressed): $pkg_full"
	echo "PACKAGE STATUS     : ${pkg_find}FOUND"
	echo "INSTALL STATUS     : ${pkg_flag}INSTALLED"
	local pkg_desc=`find_install_desc $pkg_name`
	[ "$pkg_desc" == "" ] && pkg_desc=`find_package_desc $pkg_name`
	[ "$pkg_desc" != "" ] &&
	echo "DESCRIPTION        : " && echo -e "$pkg_desc"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	echo "$trail"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	return 0
}

view_show_pkgs()
{
	for pkg_name in "$@"; do
		show_info $pkg_name $SLACKPACK
		[ $? -eq 0 ] && continue
		warn_msg "Unknown package '$pkg_name'!\n"
	done
}

view_find_package()
{
	local pkg_list
	while [ "$1" != "" ]; do
		case "$1" in
			--alien)
				view_alien_pkgs
				return
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	view_show_pkgs $pkg_list
}

file_pack_part()
{
	local pkg_name=$1
	local pkg_soft=`get_packsoft $SLACKPACK $pkg_name`
	local pkg_part="${pkg_soft}!${pkg_name}" # pkg_soft=z for unknown
	echo -n $pkg_part
}

file_insert_package()
{
	local pkg_temp pkg_test pkg_pack pkg_what
	local pkg_file=$1
	local pkg_name=$2
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	# we may get more than 1 matching entries
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	pkg_temp=`file_pack_part $pkg_name`
	if [ -z "$pkg_test" ]; then
		pkg_test=`find_package $pkg_name $SLACKPACK`
		[ "$pkg_test" == "" ] &&
			echo "PACKAGE: [INSERT] => $pkg_name (FAILED!)" && return 0
		# insert if package is valid
		echo "$pkg_temp" >>$pkg_file
		echo "PACKAGE: [INSERT] => $pkg_temp ($pkg_test)"
		return 1
	else
		pkg_pack=`echo $pkg_test | cut -d'!' -f1`
		pkg_what=`echo $pkg_temp | cut -d'!' -f1`
		if [ "$pkg_what" != "$pkg_pack" ] ; then
			sed -i -e "\|^$pkg_test\$|c\\$pkg_temp" $pkg_file
			[ $? -ne 0 ] && pkg_test="$FAILED!"
			echo "PACKAGE: [UPDATE] => $pkg_temp ($pkg_test)"
			return 2
		fi
	fi
	return 0
}

file_remove_package()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	if [ -z "$pkg_test" ]; then
		echo "PACKAGE: [REMOVE] => $pkg_name not found in list!"
	else
		# remove if existing found
		sed -i -e "\|^$pkg_test\$|d" $pkg_file
		[ $? -ne 0 ] && pkg_test="$pkg_test (FAILED!)"
		echo "PACKAGE: [REMOVE] => $pkg_test"
	fi
}

file_remove_dups()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local dup_file=$2
	# browse all packages in pkg_file
	for pkg_loop in `cat $pkg_file` ; do
		pkg_temp=`cat $dup_file | grep -e "^$pkg_loop\$"`
		if [ "$pkg_temp" != "" ] ; then
			echo -n "DUPLICATE: '$pkg_temp'! Removing... "
			sed -i -e "\|^$pkg_temp\$|d" $pkg_file
			[ $? -ne 0 ] && echo "failed!"
			echo "done."
			pkg_test=$pkg_temp
		fi
	done
	[ -z "$pkg_test" ] && echo "No duplicates in $pkg_file & $dup_file!"
}

file_option_package()
{
	local pkg_temp pkg_test do_select
	local pkg_file=$1
	local pkg_name=$2
	local pkg_stat="UNKNOWN"
	# interactive
	local pkg_base=`find_package $pkg_name $SLACKPACK`
	[ "$pkg_base" != "" ] && show_info $pkg_name $SLACKPACK
	local pkg_list=`cat $pkg_file | grep "$pkg_name"`
	for pkg_loop in $pkg_list ; do
		pkg_temp=`echo $pkg_loop | cut -d'!' -f2`
		[ "$pkg_temp" == "$pkg_name" ] && pkg_test=$pkg_loop && break
	done
	if [ "$pkg_test" == "" ]; then
		pkg_stat="EXCLUDED"
	else
		pkg_test=`find_package $pkg_temp $SLACKPACK`
		pkg_compare $pkg_test $pkg_base
		[ $? -ne 0 ] && pkg_stat="INCLUDED"
	fi
	echo -ne "\nStatus: $pkg_stat >> "
	read -n 1 -p "Command ([i]nsert/[d]elete/[*]): " do_select ; echo
	if [ "$do_select" == "i" ]; then
		file_insert_package $pkg_file $pkg_name
	elif [ "$do_select" == "d" ]; then
		file_remove_package $pkg_file $pkg_name
	fi
}

file_dolist_packages()
{
	local pkg_temp pkg_name pkg_base
	local pkg_file=$1
	# browse packages on file
	while read -r pkg_loop  ; do
		pkg_temp=`echo $pkg_loop | grep -E '^ *#|^$'`
		if [ "$pkg_temp" != "" ] ; then
			echo "[COMMENT] '$pkg_loop'"
		else
			pkg_temp=`echo $pkg_loop | cut -d'!' -f1`
			pkg_name=`echo $pkg_loop | cut -d'!' -f2`
			pkg_base=`find_package $pkg_name $SLACKPACK`
			if [ "$pkg_base" = "" ] ; then
				echo "[NOT FOUND] '$pkg_loop'"
			else
				echo "[PACKAGE] $pkg_base ($pkg_temp:$pkg_name)"
			fi
		fi
	done < $pkg_file
}

file_sort_packages()
{
	echo -n "Sorting $pkg_file..."
	cat $pkg_file | sort -u -o $pkg_file
	echo " done!"
}

file_update_packages()
{
	local pkg_temp pkg_name
	local pkg_file=$1
	local pkg_list=`cat $pkg_file`
	local new_flag=0
	# browse packages on file
	while read -r pkg_loop  ; do
		pkg_temp=`echo $pkg_loop | grep -E '^ *#|^$'`
		[ "$pkg_temp" != "" ] && continue
		pkg_name=`echo $pkg_loop | cut -d'!' -f2`
		file_insert_package $pkg_file $pkg_name
		[ $? -ne 0 ] && new_flag=1
	done < $pkg_file
	# sort if list updated!
	[ $new_flag -ne 0 ] && file_sort_packages
	return 0
}

view_file_package()
{
	local pkg_list pkg_file pkg_temp pkg_name dup_file
	local do_select
	while [ "$1" != "" ]; do
		case "$1" in
			--insert)
				do_select="YES"
				;;
			--delete|--remove)
				do_select="INV"
				;;
			--update)
				do_select="UPD"
				;;
			--list)
				do_select="LST"
				;;
			--sort)
				do_select="SOT"
				;;
			--dups)
				shift
				dup_file="$1"
				do_select="DUP"
				;;
			--name)
				shift
				pkg_file="$1"
				;;
			--pack)
				shift
				pkg_temp=`get_pathsoft $SLACKPACK $1`
				for pkg in $pkg_temp ; do
					pkg_name=`get_pkg_info $pkg | cut -d' ' -f1`
					pkg_list="${pkg_list}${pkg_name} "
				done
				;;
			-*)
				error_exit "Unknown option '$1'! Aborting!\n\n"
				;;
			*)
				pkg_temp=`find_package $1 $SLACKPACK`
				if [ "$pkg_temp" = "" ] ; then
					warn_msg "Unknown package '$1'!\n"
				else
					info_msg "Package '$1' included\n"
					pkg_list="$pkg_list $1"
				fi
				;;
		esac
		shift
	done
	# check package file - create if needed
	[ "$pkg_file" == "" ] && error_exit "No package list given!\n\n"
	[ ! -f "$pkg_file" ] && touch "$pkg_file"
	[ ! -r "$pkg_file" ] && error_exit "Cannot read '$pkg_file'!\n\n"
	# check request to list packages
	[ "$do_select" == "LST" ] &&
		file_dolist_packages $pkg_file && return
	# check request to update file
	[ "$do_select" == "UPD" ] &&
		file_update_packages $pkg_file && return
	# check sort request
	[ "$do_select" == "SOT" ] &&
		file_sort_packages && return
	# check request to remove duplicates in file
	if [ "$do_select" == "DUP" ] ; then
		[ ! -r "$dup_file" ] &&
			error_exit "Cannot read '$dup_file'!\n\n"
		file_remove_dups $pkg_file $dup_file
		return
	fi
	# check if list is empty
	[ "$pkg_list" == "" ] &&
		error_exit "No package selected? Nothing to do!\n\n"
	# process the given package list
	for pkg in $pkg_list; do
		case $do_select in
			YES) file_insert_package $pkg_file $pkg ;;
			INV) file_remove_package $pkg_file $pkg ;;
			*) file_option_package $pkg_file $pkg ;;
		esac
	done
}

process_command()
{
	local tool_cmd
	local pkgs_txt=$SLACKTREE/PACKAGES.TXT
	local log_path=$SLACKLOGS
	[ ! -f $pkgs_txt ] &&
		error_exit "File '$pkgs_txt' not found! Aborting!\n\n"
	[ ! -d $log_path ] &&
		error_exit "'$log_path' not found! Aborting!\n\n"
	tool_cmd=$1; shift
	case "$tool_cmd" in
		find)
			view_find_package "$@"
			;;
		file)
			view_file_package "$@"
			;;
		*)
			echo -e "$MSG_THISHELP\n" && exit 0
			;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_BASE - $TOOL_NAME ($TOOL_VERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
