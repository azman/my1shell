#!/bin/bash

# slackview
# - written by azman@my1matrix.net
# - slackware package info viewer
# - finds installs and in slackware tree

# standard tool info
MY1_TOOLNAME="my1 Slackware Package Viewer Tool"
MY1_TOOLVERS="2012.03.00"
MY1_TOOLBASE=$(basename $0 .sh)
MY1_TOOLPATH=$(cd $(dirname $0);pwd)
MY1_TOOL_LIB="libmy1slack"
# look for config file
for config in $(pwd) $MY1_TOOLPATH $HOME; do
	config=$config/.$MY1_TOOLBASE
	[[ ! -f $config ]] && continue
	source $config ; break
done
# look for my1slack library
[[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ]] &&
	source $MY1_TOOLPATH/$MY1_TOOL_LIB

function pkg_db_check()
{
	local pkg_temp pkg_name=$1
	pkg_temp="pkgbase_${pkg_name//-/_}"
	[[ -z "${!pkg_temp}" ]] && pkg_db_install $pkg
	[[ -z "${!pkg_temp}" ]] && pkg_db_package $pkg
	[[ -z "${!pkg_temp}" ]] && return 1
	return 0
}

function view_alien_pkgs()
{
	local do_echo
	# find installed
	for pkg_base in $(ls $SLACKINSTLOG); do
		pkg_name="${pkg_base%-*-*-*}"
		# find if alien
		if [[ "$(find_package $pkg_name)" == "" ]]; then
			echo "Alien package: ${pkg_base%-*-*-*} ($pkg_base)"
			do_echo="YES"
		fi
	done
	[[ "$do_echo" != "YES" ]] && echo "No alien package found!"
	echo
}

function view_show_pkgs()
{
	for pkg in "$@"; do
		pkg_db_check $pkg
		[[ $? -ne 0 ]] &&
			echo -e "Package '$pkg' not found!\n" && continue
		show_info $pkg
	done
}

function view_find_package()
{
	local pkg_list
	while [[ "$1" != "" ]]; do
		case "$1" in
			--alien)
				view_alien_pkgs
				return
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	view_show_pkgs $pkg_list
}

function file_insert_package()
{
	local pkg_temp pkg_test pkg_list
	local pkg_file=$1
	local pkg_name=$2
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file | grep "$pkg_name"))
	IFS=$ifs_save
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		[[ "$pkg_temp" == "$pkg_name" ]] && pkg_test=${pkg_list[$x]} && break
		pkg_temp=($(get_pkg_info ${pkg_list[$x]}))
		[[ "${pkg_temp[0]}" == $pkg_name ]] && pkg_test=${pkg_list[$x]} && break
	done
	pkg_temp=$(find_package $pkg_name)
	if [[ "$pkg_test" == "" ]]; then
		echo $pkg_temp >>$pkg_file
		echo "Package '$pkg_temp' added to $pkg_file."
	else
		# insert/update?
		sed -i -e "\|^$pkg_test\$|c\\$pkg_temp" $pkg_file
		if [[ $? -ne 0 ]]; then
			echo "Error replacing package '$pkg_name'! [$pkg_temp]"
		else
			echo "Package '$pkg_name' updated in $pkg_file. [$pkg_temp]"
		fi
	fi
	echo
}

function file_remove_package()
{
	local pkg_temp pkg_list pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file | grep "$pkg_name"))
	IFS=$ifs_save
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		[[ "$pkg_temp" == "$pkg_name" ]] && pkg_test=${pkg_list[$x]} && break
		pkg_temp=($(get_pkg_info ${pkg_list[$x]}))
		[[ "${pkg_temp[0]}" == $pkg_name ]] && pkg_test=${pkg_list[$x]} && break
	done
	if [[ "$pkg_test" == "" ]]; then
		echo "Package '$pkg_name' not in file!"
	else
		# remove?
		sed -i -e "\|^$pkg_test\$|d" $pkg_file
		if [[ $? -ne 0 ]]; then
			echo "Error deleting package '$pkg_name'! [$pkg_test]"
		else
			echo "Package '$pkg_test' deleted from $pkg_file."
		fi
	fi
	echo
}

function file_option_package()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local pkg_stat="INCLUDED"
	# interactive
	pkg_test="pkgbase_${pkg_name//-/_}"
	[[ -z "${!pkg_test}" ]] && pkg_db_package $pkg_name
	[[ -z "${!pkg_test}" ]] &&
		echo "Package '$pkg_name' unknown!" && return
	show_info $pkg_name
	pkg_temp=$(find_package $pkg_name)
	pkg_test=$(find_infile $pkg_file $pkg_name)
	if [[ "$pkg_test" == "" ]]; then
		pkg_stat="EXCLUDED"
	else
		comp_package $pkg_test $pkg_temp
		[[ $? -ne 0 ]] &&
			pkg_stat="INCLUDED ($pkg_test/$pkg_temp) [$?]"
	fi
	echo -n "Status: $pkg_stat. "
	read -n 1 -p "Command ([i]nsert/[d]elete/[*]): " do_select ; echo
	if [[ "$do_select" == "i" ]]; then
		file_insert_package $pkg_file $pkg_name
	elif [[ "$do_select" == "d" ]]; then
		file_remove_package $pkg_file $pkg_name
	else
		echo
	fi
}

function file_browse_packages()
{
	local pkg_name pkg_temp pkg_test pkg_full
	local opt_more opt_init="[p]revious/[n]ext/[q]uit"
	local tmp_list pkg_list pkg_file=$1 do_select x y
	shift ; pkg_list="$@" # list ignored for now
	# get all packages on file
	local ifs_save=$IFS
	IFS=$'\n'
	tmp_list=($(cat $pkg_file))
	IFS=$ifs_save
	# browse packages on file
	for (( x=0;x<${#tmp_list[@]}; )); do
		pkg_full=${tmp_list[$x]}
		pkg_test=""
		pkg_temp=($(get_pkg_info $pkg_full))
		pkg_name=${pkg_temp[0]}
		echo -n "PACKAGE: ${pkg_full}"
		[[ "${pkg_temp[1]}" == "${pkg_temp[0]}" ]] && pkg_name=$pkg_full &&
			pkg_full=$(find_package $pkg_name) && pkg_test=" (${pkg_full})"
		[[ "$pkg_full" == "" ]] && pkg_test=" (INVALID?)"
		[[ "$pkg_test" != "" ]] && echo -n "$pkg_test"
		# try to show details
		pkg_test="pkgdesc_${pkg_name//-/_}"
		[[ -z "${!pkg_test}" ]] && pkg_db_package $pkg_name --all
		if [[ -z "${!pkg_test}" ]] ; then
			echo -n " => "
			opt_more=""
		else
			echo -e "\n\n${!pkg_test}\n"
			opt_more="[u]pdate/[d]elete/"
		fi
		# navigation options
		read -n 1 -p "Command (${opt_more}${opt_init}): " do_select
		echo ; echo
		if [[ "$do_select" == "n" ]]; then
			[[ $x -lt ${#tmp_list[@]}-1 ]] && (( x++ ))
		elif [[ "$do_select" == "p" ]]; then
			[[ $x -gt 0 ]] && (( x-- ))
		elif [[ "$do_select" == "u" ]]; then
			[[ "$opt_more" == "" ]] && continue
			(( y=x ))
			file_insert_package $pkg_file $pkg_name
			(( x=y ))
		elif [[ "$do_select" == "d" ]]; then
			[[ "$opt_more" == "" ]] && continue
			file_remove_package $pkg_file $pkg_name
			break;
		elif [[ "$do_select" == "q" ]]; then
			break;
		fi
	done
	echo
}

function file_update_packages()
{
	local pkg_name pkg_temp pkg_test pkg_full
	local tmp_list tmp_stat do_select x y
	# get all packages on file
	local ifs_save=$IFS
	IFS=$'\n'
	tmp_list=($(cat $pkg_file))
	IFS=$ifs_save
	# browse packages on file
	for (( x=0;x<${#tmp_list[@]};x++ )); do
		pkg_test=${tmp_list[$x]}
		pkg_full="$pkg_test"
		pkg_temp=($(get_pkg_info $pkg_full))
		pkg_name=${pkg_temp[0]}
		tmp_stat=""
		echo -n "PACKAGE: ${pkg_full}"
		[[ "${pkg_temp[1]}" == "${pkg_temp[0]}" ]] && pkg_name=$pkg_full &&
			pkg_full=$(find_package $pkg_name) && tmp_stat="$pkg_full"
		[[ "$pkg_full" == "" ]] && tmp_stat="INVALID"
		[[ "$tmp_stat" != "" ]] && echo -n " ($tmp_stat)"
		echo -n " => "
		# update if not the same
		if [[ "$tmp_stat" == "INVALID" ]]; then
			read -n 1 -p "Options ([d]elete/[i]gnore/[q]uit): " do_select
			if [[ "$do_select" == "d" ]]; then
				echo -e "\bDeleted!"
				(( y=x ))
				file_remove_package $pkg_file $pkg_name
				(( x=y ))
			elif [[ "$do_select" == "i" ]]; then
				echo -e "\bIgnored!"
			elif [[ "$do_select" == "q" ]]; then
				echo -e "\bAborted!"
				break;
			fi
		elif [[ "$pkg_full" != "$pkg_test" ]]; then
			echo " Updated!"
			(( y=x ))
			file_insert_package $pkg_file $pkg_name
			(( x=y ))
		else
			echo " OK!"
		fi
	done
	echo
}

function view_file_package()
{
	local pkg_list pkg_file pkg_temp pkg_name
	local do_select do_sort
	while [[ "$1" != "" ]]; do
		case "$1" in
			--select)
				do_select="YES"
				;;
			--unselect)
				do_select="INV"
				;;
			--browse)
				do_select="CHK"
				;;
			--update)
				do_select="UPD"
				;;
			--name)
				shift
				pkg_file="$1"
				;;
			--sort)
				do_sort="YES"
				;;
			--pack)
				shift
				pkg_temp=$(get_softpack $1)
				for pkg in $pkg_temp ; do
					pkg_name=($(get_pkg_info $pkg))
					pkg_list="$pkg_list ${pkg_name[0]}"
				done
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	# check package file - create if needed
	[[ "$pkg_file" == "" ]] &&
		echo -e "[ERROR] File name for package list NOT given!\n" && return
	[[ ! -f "$pkg_file" ]] && touch "$pkg_file"
	[[ ! -r "$pkg_file" ]] &&
		echo -e "[ERROR] Cannot read file '$pkg_file'!\n" && return
	# check request to update file
	[[ "$do_select" == "UPD" ]] &&
		file_update_packages $pkg_file && return
	# check request to browse file
	[[ "$do_select" == "CHK" ]] &&
		file_browse_packages $pkg_file $pkg_list && return
	# check if list is empty
	[[ "$pkg_list" == "" ]] &&
		echo -e "No package selected? Nothing to do!\n" && return
	# process the given package list
	for pkg in $pkg_list; do
		case $do_select in
			YES) file_insert_package $pkg_file $pkg ;;
			INV) file_remove_package $pkg_file $pkg ;;
			*) file_option_package $pkg_file $pkg ;;
		esac
	done
	# sort file if requested
	if [[ "$do_sort" == "YES" ]]; then
		# should be with software set!
		echo -n "Sorting (with uniq) $pkg_file..."
		cat $pkg_file | uniq | sort -o $pkg_file
		echo " done!"
	fi
}

function process_command()
{
	local tool_cmd
	[[ ! -f $SLACKPKGFILE ]] &&
		echo -e "File '$SLACKPKGFILE' not found! Aborting!\n" && exit 1
	[[ ! -d $SLACKINSTLOG ]] &&
		echo -e "'$SLACKINSTLOG' not found! Not a slack? Aborting!\n" && exit 1
	tool_cmd=$1; shift
	case "$tool_cmd" in
		find)
			view_find_package "$@"
			;;
		file)
			view_file_package "$@"
			;;
		help|-h|--help)
			echo "Usage:"
			echo "  $MY1_TOOLBASE <command> [parameter]"
			echo "Available commands:"
			echo "  find   : Find package(s) in mirror@installation"
			echo "         > --alien    : Find & list alien package(s)"
			echo "         > {pkg_name} : Find & display package info"
			echo "  file   : Manage File for package list"
			echo "         > --select   : Insert package to list"
			echo "         > --unselect : Delete package from list"
			echo "         > --browse   : Browse packages on list"
			echo "         > --name     : Specify filename"
			echo "         > --pack     : Select official software set"
			echo "         > --sort     : Sort package list"
			echo "  help   : Show this help message"
			echo "Mirror Source:"
			echo "  ${SLACKROOTDIR}/${SLACKRELEASE}"
			echo
			exit 0
			;;
		*)
			echo "Unknown command!"
			echo
			exit 1
			;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"

# END MAIN SCRIPT
