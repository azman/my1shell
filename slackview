#!/bin/bash

# slackview
# - written by azman@my1matrix.net
# - slackware package info viewer
# - finds installs and in slackware tree

# standard tool info
MY1_TOOLNAME="my1 Slackware Package Viewer Tool"
MY1_TOOLVERS="2012.03.00"
MY1_TOOLBASE=$(basename $0 .sh)
MY1_TOOLPATH=$(cd $(dirname $0);pwd)
MY1_TOOL_LIB="libmy1slack"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1_TOOLBASE
	[ -r $config ] && source $config && break
done
# look for my1slack library
[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ] && source $MY1_TOOLPATH/$MY1_TOOL_LIB

# my1slack tool specific
MY1_TOOL_LOG=${MY1_TOOL_LOG:="/tmp/${MY1_TOOLBASE}.log"}
MY1_SLACKDIR=${MY1_SLACKDIR:="${SLACKROOTDIR}/${SLACKRELEASE}"}
MY1_ROOT_DEF=${MY1_ROOT_DEF:="/opt/chroot32"}
MY1_LIVE_DEF=${MY1_LIVE_DEF:="$(pwd)"}
MY1_USER_DEF=${MY1_USER_DEF:="user"}
# global options & settings
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  find   : Find package(s) in mirror@installation
         > --alien    : Find & list alien package(s)
         > {pkg_name} : Find & display package info
  file   : Manage File for package list
         > --insert   : Insert package to list
         > --delete   : Delete package from list
         > --browse   : Browse packages on list
         > --update   : Update packages on list
         > --sort     : Sort packages on list
         > --name     : Specify filename
         > --pack     : Select official software set
  help   : Show this help message
Mirror Source:
  $MY1_SLACKDIR
Log File:
  $MY1_TOOL_LOG
SETHELPMSG
)

function view_alien_pkgs()
{
	local do_echo="YES"
	# find installed
	for pkg_base in $(ls $SLACKINSTLOG); do
		pkg_name="${pkg_base%-*-*-*}"
		# find if alien
		if [ "$(find_package $pkg_name)" == "" ]; then
			echo "Alien package: ${pkg_base%-*-*-*} ($pkg_base)"
			do_echo="NO"
		fi
	done
	[ "$do_echo" == "YES" ] && info_msg "No alien package found!\n"
}

function view_show_pkgs()
{
	for pkg_name in "$@"; do
		show_info $pkg_name
		[ $? -eq 0 ] && continue
		warn_msg "Unknown package '$pkg_name'!\n"
	done
}

function view_find_package()
{
	local pkg_list
	while [ "$1" != "" ]; do
		case "$1" in
			--alien)
				view_alien_pkgs
				return
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	view_show_pkgs $pkg_list
}

function file_pack_part()
{
	local pkg_name=$1
	local pkg_soft="$(get_packsoft $pkg_name)"
	local pkg_part="${pkg_soft}!${pkg_name}"
	echo -n $pkg_part
}

function file_insert_package()
{
	local pkg_list pkg_temp pkg_test
	local pkg_file=$1
	local pkg_part=$2
	local ifs_save=$IFS
	local pkg_name=${pkg_part#*!}
	local pkg_soft=${pkg_part#%!${pkg_name}}
	IFS=$'\n'
	pkg_list=($(cat $pkg_file | grep "$pkg_name"))
	IFS=$ifs_save
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		[ "${pkg_temp#*!}" == "$pkg_name" ] && pkg_test=$pkg_temp && break
	done
	if [ "$pkg_test" == "" ]; then
		# insert
		echo "$pkg_part" >>$pkg_file
		return 0
	else
		# update
		sed -i -e "\|^$pkg_test\$|c\\$pkg_part" $pkg_file
		return $?
	fi
}

function file_remove_package()
{
	local pkg_list pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file | grep "$pkg_name"))
	IFS=$ifs_save
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		[ "${pkg_temp#*!}" == "$pkg_name" ] && pkg_test=$pkg_temp && break
	done
	if [ "$pkg_test" == "" ]; then
		# nothing to do
		return 0
	else
		# remove
		sed -i -e "\|^$pkg_test\$|d" $pkg_file
		return $?
	fi
}

function file_option_package()
{
	local pkg_temp pkg_test
	local pkg_file=$1
	local pkg_name=$2
	local pkg_stat="INCLUDED"
	# interactive
	local pkg_base="$(find_package $pkg_name)"
	[ "$pkg_base" == "" ] && echo "Package '$pkg_name' unknown!" && return
	show_info $pkg_name
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file | grep "$pkg_name"))
	IFS=$ifs_save
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		[ "${pkg_temp#*!}" == "$pkg_name" ] && pkg_test=$pkg_temp && break
	done
	if [ "$pkg_test" == "" ]; then
		pkg_stat="EXCLUDED"
	else
		pkg_test=$(find_package ${pkg_test#*!})
		comp_package $pkg_test $pkg_base
		[ $? -ne 0 ] && pkg_stat="INCLUDED ($pkg_test/$pkg_base) [$?]"
	fi
	echo -ne "\nStatus: $pkg_stat. "
	read -n 1 -p "Command ([i]nsert/[d]elete/[*]): " do_select ; echo
	if [ "$do_select" == "i" ]; then
		file_insert_package $pkg_file $(file_pack_part $pkg_name)
	elif [ "$do_select" == "d" ]; then
		file_remove_package $pkg_file $pkg_name
	fi
}

function file_browse_packages()
{
	local pkg_name pkg_temp pkg_desc pkg_base
	local opt_more opt_init="[p]revious/[n]ext/[q]uit"
	local pkg_list pkg_file=$1 do_select x y
	# get all packages on file
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file))
	IFS=$ifs_save
	# browse packages on file
	for (( x=0;x<${#pkg_list[@]}; )); do
		pkg_temp=${pkg_list[$x]}
		pkg_name=${pkg_temp#*!}
		pkg_base=$(find_package $pkg_name)
		echo -n "PACKAGE: ${pkg_name} (${pkg_base})"
		# try to show details
		pkg_desc="$(find_package_desc $pkg_name)"
		if [ "$pkg_desc" == "" ] ; then
			echo -n " => "
			opt_more=""
		else
			echo -e "\n\n${pkg_desc}\n"
			opt_more="[u]pdate/[d]elete/"
		fi
		# navigation options
		read -n 1 -p "Command (${opt_more}${opt_init}): " do_select
		echo ; echo
		if [ "$do_select" == "n" ]; then
			[ $x -lt ${#pkg_list[@]}-1 ] && (( x++ ))
		elif [ "$do_select" == "p" ]; then
			[ $x -gt 0 ] && (( x-- ))
		elif [ "$do_select" == "u" ]; then
			[ "$opt_more" == "" ] && continue
			local pkg_part=$(file_pack_part $pkg_name)
			file_insert_package $pkg_file $pkg_part 
			if [ $? -eq 0 ] ; then echo "Package '$pkg_name' updated!"
			else echo "Package '$pkg_name' update error!" ; fi
			break;
		elif [ "$do_select" == "d" ]; then
			[ "$opt_more" == "" ] && continue
			file_remove_package $pkg_file $pkg_name
			if [ $? -eq 0 ] ; then echo "Package '$pkg_name' deleted!"
			else echo "Package '$pkg_name' delete error!" ; fi
			break;
		elif [ "$do_select" == "q" ]; then
			break;
		fi
	done
}

function file_update_packages()
{
	local pkg_list pkg_temp pkg_name pkg_base
	local do_select x y
	# get all packages on file
	local ifs_save=$IFS
	IFS=$'\n'
	pkg_list=($(cat $pkg_file))
	IFS=$ifs_save
	# browse packages on file
	for (( x=0;x<${#pkg_list[@]};x++ )); do
		pkg_temp=${pkg_list[$x]}
		pkg_name=${pkg_temp#*!}
		pkg_base=$(find_package $pkg_name)
		echo -n "PACKAGE: "
		if [ "$pkg_base" == "" ]; then
			echo -n "[INVALID]"
		else
			local pkg_part=$(file_pack_part $pkg_name)
			if [ "$pkg_temp" != "$pkg_part" ]; then
				(( y=x ))
				file_insert_package $pkg_file $pkg_part
				if [ $? -eq 0 ] ; then echo -n "[UPDATED]"
				else echo -n "[ERROR]" ; fi
				(( x=y ))
			else
				echo -n "[OK]"
			fi
		fi
		echo " => $pkg_name ($pkg_base)"
	done
}

function view_file_package()
{
	local pkg_list pkg_file pkg_temp pkg_name
	local do_select
	while [ "$1" != "" ]; do
		case "$1" in
			--insert)
				do_select="YES"
				;;
			--delete)
				do_select="INV"
				;;
			--browse)
				do_select="CHK"
				;;
			--update)
				do_select="UPD"
				;;
			--sort)
				do_select="SOT"
				;;
			--name)
				shift
				pkg_file="$1"
				;;
			--pack)
				shift
				pkg_temp=$(get_softpack $1)
				for pkg in $pkg_temp ; do
					pkg_name=($(get_pkg_info $pkg))
					pkg_list="$pkg_list ${pkg_name[0]}"
				done
				;;
			*)
				pkg_list="$pkg_list $1"
				;;
		esac
		shift
	done
	# check package file - create if needed
	[ "$pkg_file" == "" ] && error_exit "No package list given!"
	[ ! -f "$pkg_file" ] && touch "$pkg_file"
	[ ! -r "$pkg_file" ] && error_exit "Cannot read '$pkg_file'!"
	# check request to update file
	[ "$do_select" == "UPD" ] &&
		file_update_packages $pkg_file && return
	# check request to browse file
	[ "$do_select" == "CHK" ] &&
		file_browse_packages $pkg_file && return
	# check sort request
	if [ "$do_select" == "SOT" ]; then
		echo -n "Sorting (with uniq) $pkg_file..."
		cat $pkg_file | uniq | sort -o $pkg_file
		echo " done!"
		return
	fi
	# check if list is empty
	[ "$pkg_list" == "" ] &&
		error_exit "No package selected? Nothing to do!"
	# process the given package list
	for pkg in $pkg_list; do
		case $do_select in
			YES) file_insert_package $pkg_file $(file_pack_part $pkg) ;;
			INV) file_remove_package $pkg_file $pkg ;;
			*) file_option_package $pkg_file $pkg ;;
		esac
	done
}

function process_command()
{
	local tool_cmd
	[ ! -f $SLACKPKGFILE ] &&
		error_exit "File '$SLACKPKGFILE' not found! Aborting!"
	[ ! -d $SLACKINSTLOG ] &&
		error_exit "'$SLACKINSTLOG' not found! Aborting!"
	tool_cmd=$1; shift
	case "$tool_cmd" in
		find)
			view_find_package "$@"
			;;
		file)
			view_file_package "$@"
			;;
		*)
			echo -e "$MSG_THISHELP\n" && exit 0
			;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
