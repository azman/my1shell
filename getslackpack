#!/bin/bash

# getslackpack
# - written by azman@my1matrix.org
# - standalone slackware package retriever

TOOL_NAME=`basename $0 .sh`
# look for config file
for conf in `pwd`/.$TOOL_NAME $HOME/.$TOOL_NAME ; do
	[ -r $conf ] && source $conf && break
done
# setup path to slackware tree
[ -z "$SLACKROOT" ] && SLACKROOT=`pwd`
[ -z "$SLACKARCH" ] && [ -n "$ARCH" ] && SLACKARCH=$ARCH
[ -z "$SLACKARCH" ] && SLACKARCH=`uname -m`
[ "$SLACKARCH" == "x86_64" ] && SLACKSUFX="64" || SLACKSUFX=
[ -z "$SLACKNAME" ] && SLACKNAME="slackware$SLACKSUFX"
[ -z "$SLACKVERS" ] && [ -n "$VERS" ] && SLACKVERS=$VERS
[ -z "$SLACKVERS" ] && [ ! -f /etc/slackware-version ] && SLACKVERS="current" ||
	SLACKVERS=`cat /etc/slackware-version | sed 's/Slackware //'`
SLACKFULL=$SLACKNAME-$SLACKVERS
SLACKPATH=$SLACKROOT/slackpack$SLACKSUFX-$SLACKVERS
# temporary path
TOOL_USER=`whoami`
TOOL_TEMP="/tmp/$TOOL_USER/$TOOL_NAME"
# x86 packages usually target specific arch - used in salix/rwork repos!
[ -z "$ARCH_X86" ] && ARCH_X86="i486"
case $SLACKARCH in x86|i*86) SLACKARCH=$ARCH_X86 ;; esac
# tool options - allow config file to set these...
OPT_CHECK=${OPT_CHECK:="YES"}
OPT_CLEAN=${OPT_CLEAN:="NO"}
OPT_SWEEP=${OPT_SWEEP:="NO"}
THIS_CONF=${THIS_CONF:=""}

do_download()
{
	local fname="$1"
	local label="$2"
	local cpath="$(pwd)"
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -n "Downloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!" && exit 1
	echo -ne "\b\b\b\b DONE!\n"
}

go_loadsums() #DONE
{
	local root=$1
	local repo=$2
	local sums=$3
	[ -z "$sums" ] && sums="CHECKSUMS.md5"
	# check clean option
	if [ "$OPT_CLEAN" == "YES" ] ; then
		rm -rf $TOOL_TEMP
		[ $? -eq 0 ] && OPT_CLEAN="NO"
	fi
	# prepare temp
	local curr=`pwd`
	local temp="$TOOL_TEMP/$repo"
	mkdir -p $temp ; cd $temp
	# if not found OR nothing modified last 120 minutes
	local test=`find $sums -mmin -120 2>/dev/null`
	if [ "$test" == "" ]; then
		rm -rf ${sums}* # just in case, delete old ones
		local that="$root/$sums"
		wget --spider ${that}.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download ${that}.gz ${sums}.gz
			gzip -d ${sums}.gz
		else
			do_download $root/$sums $sums
		fi
		# we must have it!
		[ ! -r "$sums" ] && echo "Cannot find $sums!" >&2 && exit 1
	fi
	cd $curr
}

go_loadpkgt()
{
	local func="go_loadpkgt()"
	local root=$1
	local repo=$2
	local pack=$3
	[ -z "$pack" ] && pack="PACKAGES.TXT"
	local sums=$4
	[ -z "$sums" ] && sums="CHECKSUMS.md5"
	# prepare temp
	local curr=`pwd`
	local temp="$TOOL_TEMP/$repo"
	mkdir -p $temp ; cd $temp
	# check if not found OR nothing modified last 24x60 minutes
	local test=`find $pack -mmin -1440 2>/dev/null`
	if [ "$test" == "" ]; then
		rm -rf ${pack}* # just in case, delete old one
		local that="$root/$pack"
		wget --spider ${that}.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download ${that}.gz ${pack}.gz
			gzip -d ${pack}.gz
		else
			do_download $that $pack
		fi
		# we must have it!
		[ ! -r "$pack" ] && echo "$func: Cannot find $pack!" >&2 && exit 1
		# check validity
		cat $sums | grep -e " ./${pack}$" >$pack.md5
		if [ -r "${pack}.md5" -a "$(cat ${pack}.md5)" != "" ]; then
			md5sum --check ${pack}.md5 >/dev/null 2>&1
			[ $? -ne 0 ] && rm -f $pack &&
				echo "$func: [$pack] Checksum failed!" >&2 && exit 1
		else
			echo "$func: $pack validity not checked! (no md5)"
		fi
	fi
	cd $curr
}

go_loadinfo() #DONE
{
	local root=$1
	local repo=$2
	case "$repo" in
		slack) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		salix) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		rwork) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
	esac
	# obtain checksum
	local sums="CHECKSUMS.md5"
	go_loadsums $root $repo $sums
	# obtain package
	local temp="$TOOL_TEMP/$repo"
	local file="PACKAGES.TXT"
	go_loadpkgt $root $repo $file $sums
}

go_loadpack()
{
	local pkg_root=$1
	local pkg_rsrc=$2
	local pkg_repo=$3
	local pkg_path=$4
	local pkg_file=$5
	case "$pkg_repo" in
		slack) pkg_repo="$pkg_repo$SLACKSUFX-$SLACKVERS" ;;
		salix) pkg_repo="$pkg_repo$SLACKSUFX-$SLACKVERS" ;;
		rwork) pkg_repo="$pkg_repo$SLACKSUFX-$SLACKVERS" ;;
	esac
	local pkg_temp="$TOOL_TEMP/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	local pkg_md5f="$pkg_path/$pkg_file.md5"
	# obtain checksum
	go_loadsums $pkg_root $pkg_repo
	# prepare pack path for checksum
	mkdir -p $pkg_path
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# extract checksum for file
	cat $pkg_sums | grep -e "^.*${pkg_rsrc}/${pkg_file}$" >$pkg_md5f
	[ $? -ne 0 ] &&
		echo "Cannot create checksum for '$pkg_file'!" && exit 1
	# fix path in checksum file
	sed -i "s|${pkg_rsrc}||g" $pkg_md5f
	cd - >/dev/null
	# go to package path
	cd $pkg_path
	# fix download path
	pkg_root=${pkg_root}${pkg_rsrc}
	local pkg_test="KO"
	# tell them...
	echo -n "$pkg_file"
	# check if valid package exists
	if [ -r $pkg_file.md5 ]; then
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -eq 0 ] && pkg_test="OK"
		if [ "$pkg_test" == "OK" ]; then
			echo -n " (LOCAL)"
		else
			if [ -f "${pkg_file}" ] ; then
				rm -rf ${pkg_file}
				echo -n " ..."
			fi
		fi
	fi
	echo
	# find old files?
	pkg_name=${pkg_file%-*} # strip build
	pkg_name=${pkg_name%-*} # strip arch
	pkg_name=${pkg_name%-*} # strip vers
	for tmp in ${pkg_name}* ; do
		# make sure same package name (not extended)
		tmp_name=${tmp%-*} # strip build
		tmp_name=${tmp_name%-*} # strip arch
		tmp_name=${tmp_name%-*} # strip vers
		[ "$tmp_name" != "$pkg_name" ] && continue;
		# leave the current ones
		[ "$tmp" == "${pkg_file}" ] && continue;
		[ "$tmp" == "${pkg_file}.md5" ] && continue;
		echo -n "Found '$tmp'"
		[ "$OPT_SWEEP" == "NO" ] && echo && continue
		rm -rf $tmp
		echo ": REMOVED."
	done
	if [ "$OPT_CHECK" != "YES" ] && [ "$pkg_test" == "KO" ]; then
		# download if not found or invalid
		do_download $pkg_root/$pkg_file $pkg_file
		[ ! -r "$pkg_file" ] && rm -f $pkg_file.md5 &&
			echo "[ERROR] Download error?!" && exit 1
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -ne 0 ] && rm -f $pkg_file && rm -f $pkg_file.md5 &&
			echo "[ERROR] Checksum failed!" && exit 1
	fi
	cd - >/dev/null
}

go_loadrawl() #DONE
{
	local func="go_loadrawl()"
	local root=$1
	local repo=$2
	local arch=$3
	case "$repo" in
		slack) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		salix) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		rwork) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
	esac
	# check clean option
	if [ "$OPT_CLEAN" == "YES" ] ; then
		rm -rf $TOOL_TEMP
		[ $? -eq 0 ] && OPT_CLEAN="NO"
	fi
	# prepare temp
	local temp="$TOOL_TEMP/$repo"
	local curr=`pwd`
	mkdir -p $temp ; cd $temp
	local list="index.html"
	local test=`find $list -mmin -120 2>/dev/null`
	# if not found OR nothing modified last 120 minutes
	if [ "$test" == "" ]; then
		rm -rf ${list}* # just in case, delete old one
		wget --spider $root >/dev/null 2>&1
		[ $? -eq 0 ]  do_download $root $list
		[ ! -r "$list" ] && echo "$func: Cannot get $list!" >&2 && exit 1
	fi
	cd $curr
}

go_packrawl()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_path=$3
	local pkg_file=$4
	local pkg_rsrc=$5
	local pkg_test="KO"
	# tell them...
	echo -n "$pkg_file"
	# prepare / change to pack path
	mkdir -p $pkg_path ; cd $pkg_path
	if [ -f "${pkg_file}.md5" ]; then
		md5sum --check ${pkg_file}.md5 >/dev/null 2>&1
		[ $? -eq 0 ] && pkg_test="OK"
		if [ "$pkg_test" == "OK" ]; then
			echo -n " (LOCAL)"
		else
			if [ -f "${pkg_file}" ] ; then
				rm -rf ${pkg_file}
				echo -n " ..."
			fi
		fi
	fi
	echo
	# find old files?
	pkg_name=${pkg_file%-*} # strip build
	pkg_name=${pkg_name%-*} # strip arch
	pkg_name=${pkg_name%-*} # strip vers
	for tmp in ${pkg_name}* ; do
		# make sure same package name (not extended)
		tmp_name=${tmp%-*} # strip build
		tmp_name=${tmp_name%-*} # strip arch
		tmp_name=${tmp_name%-*} # strip vers
		[ "$tmp_name" != "$pkg_name" ] && continue;
		# leave the current ones
		[ "$tmp" == "${pkg_file}" ] && continue;
		[ "$tmp" == "${pkg_file}.md5" ] && continue;
		echo -n "Found '$tmp'"
		[ "$OPT_SWEEP" == "NO" ] && echo && continue
		rm -rf $tmp
		echo ": REMOVED."
	done
	if [ "$OPT_CHECK" != "YES" ] && [ "$pkg_test" == "KO" ]; then
		# download if old?
		if [ "$(find $pkg_file -mmin -1440 2>/dev/null)" == "" ]; then
			rm -rf $pkg_file # just in case, delete old one
			do_download $pkg_root/$pkg_file $pkg_file
			if [ "$pkg_rsrc" == "${pkg_file}.md5" ]; then
				rm -rf $pkg_rsrc # just in case, delete old one
				do_download $pkg_root/$pkg_rsrc $pkg_rsrc
			fi
			if [ ! -r "$pkg_file" ]; then
				echo "[ERROR] Download Error?!"
			elif [ -r "$pkg_rsrc" ]; then
				pkg_test="KO"
				md5sum --check $pkg_rsrc >/dev/null 2>&1
				[ $? -eq 0 ] && pkg_test="OK"
				if [ "$pkg_test" != "OK" ]; then
					echo "[ERROR] Checksum failed!" &&
						rm -f $pkg_file && rm -f $pkg_rsrc
				fi
			fi
		fi
	fi
	cd - >/dev/null
}

go_findrawl() #DONE
{
	local func="go_findrawl()"
	[ ! -z "${pack+x}" ] && echo "$func: Var 'pack' NOT defined!" && exit 1
	local repo=$1
	local name=$2
	local arch=$3
	local vers=$4
	case "$repo" in
		slack) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		salix) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		rwork) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
	esac
	local info="$TOOL_TEMP/$repo/index.html"
	# info structure?
	local temp="${name}-[^-]*-${arch}-[^-]*.t[gx]z "
	local text="$(cat $info | sed -e :a -e 's/<[^>]*>//g;/</N;//ba')"
	local test="$(echo "$text" | grep -e 't[gx]z\s' | grep $name)"
	[ "$test" = "" ] && return
	local file=`echo ${test} | cut -d' ' -f1`
	[ "$file" = "" ] && return
	# check for md5 file
	temp="${name}-[^-]*-${arch}-[^-]*.t[gx]z.md5"
	test="$(echo "$text" | grep -e "$temp" )"
	local md5s=`echo ${test} | cut -d' ' -f1`
	# assign!
	pack="$file:$md5s"
}

go_findpack() #DONE
{
	local func="go_findpack()"
	[ ! -z "${pack+x}" ] && echo "$func: Var 'pack' NOT defined!" && exit 1
	local repo=$1
	local name=$2
	local arch=$3
	local vers=$4
	case "$repo" in
		slack) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		salix) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
		rwork) repo="$repo$SLACKSUFX-$SLACKVERS" ;;
	esac
	local info="$TOOL_TEMP/$repo/PACKAGES.TXT"
	[ ! -f "$info" ] && echo "Cannot find '$info'!" && exit 1
	# info structure?
	local temp=" ${name}-[^-]*-[^-]*-[^-]*.t[gx]z$"
	local text=`cat $info | grep -e "$temp" -A3`
	[ "$text" = "" ] && return
	# filter arch
	temp=$arch
	#[ "$arch" == "i486" ] && [ "$repo" == "salix" ] && temp="i686"
	[ "$arch" == "i486" ] && temp="i[3456]86"
	local test=`echo "$text" | grep -E "$temp" -A3`
	[ "$test" == "" ] && test=`echo "$text" | grep -E "noarch" -A3`
	[ "$test" == "" ] && return
	text="$test"
	# filter version
	if [ "$repo" == "alien" -o "$repo" == "alien-res" ] ; then
		temp=pkg$SLACKSUFX/$vers
		test=`echo "$text" | grep -e "$temp" -A2 -B1`
		[ "$test" == "" ] && return;
		text="$test"
	fi
	# get package name
	local labs="PACKAGE NAME:"
	local file=`echo "$text" | grep "^$labs"`
	file=`echo "$file" | sed "s/$labs[[:space:]]*//"`
	# get location
	labs="PACKAGE LOCATION:"
	local path=`echo "$text" | grep "^$labs"`
	path=`echo "$path" | sed "s/$labs[[:space:]]*//"`
	path=`echo "$path" | sed 's/^.\(.*\)$/\1/'`
	# assign!
	pack="$file:$path"
}

do_findthat() #DONE
{
	local path=$1
	local item=$2
	local repo=`echo $item | cut -d':' -f1`
	local name=`echo $item | cut -d':' -f2`
	# default repo - alien_bob's stuffs!
	local site_bob="http://bear.alienbase.nl"
	local root_bob="${site_bob}/mirrors/people/alien/slackbuilds"
	# alien_bob's restricted builds
	local root_res="${site_bob}/mirrors/people/alien/restricted_slackbuilds"
	# official slackware packages
	local root_slk="http://mirrors.slackware.com/slackware/$SLACKFULL"
	# salix packages
	local root_slx="http://download.salixos.org/$SLACKARCH/$SLACKVERS"
	# rlworkman's packages
	local root_rlw="http://rlworkman.net/pkgs/$SLACKVERS/$SLACKARCH"
	# find url
	local root rawp=0
	case "$repo" in
		alien) root="$root_bob" ;;
		alien-res) root="$root_res" ;;
		slack) root="$root_slk" ;;
		salix) root="$root_slx" ;;
		rwork) root="$root_rlw" ; rawp=1 ;;
		*) echo "Unknown repo '$repo'!" && exit 1 ;;
	esac
	#echo "[DEBUG] |$root|$repo|$name|$rawp|"
	local file rsrc
	local arch=$SLACKARCH
	local vers=$SLACKVERS
	if [ $rawp -eq 0 ]; then
		go_loadinfo $root $repo
		echo -n "{$repo} '$name': "
		local pack ; go_findpack $repo $name $arch $vers
		if [ "$pack" != "" ]; then
			file=`echo $pack | cut -d':' -f1`
			rsrc=`echo $pack | cut -d':' -f2`
			go_loadpack $root $rsrc $repo $path $file
		else
			echo "not found!"
		fi
	else
		go_loadrawl $root $repo $arch
		echo -n "{$repo} '$name': "
		local pack ; go_findrawl $repo $name $arch $vers
		if [ "$pack" != "" ]; then
			file=`echo $pack | cut -d':' -f1`
			rsrc=`echo $pack | cut -d':' -f2`
			go_packrawl $root $repo $path $file $rsrc
		else
			echo "not found!"
		fi
	fi
}

create_list() #DONE
{
	local func="create_list()"
	[ ! -z "${list+x}" ] && echo "$func: Var 'list' NOT defined!" && exit 1
	# set default
	local rawp that repo="alien"
	# process param and create expanded list
	while [ "$1" != "" ]; do
		case "$1" in
			--alien) repo="alien" ;;
			--alien-res) repo="alien-res" ;;
			--slack) repo="slack" ;;
			--salix) repo="salix" ;;
			--rwork) repo="rwork" ;;
			-*) echo "Unknown repo '$1'!" && exit 1 ;;
			*) [ -z "$list" ] && list="$repo:$1" || list="$list;$repo:$1" ;;
		esac
		shift
	done
}

do_execthat() #DONE
{
	local func="do_execthat()"
	local path
	local repo="alien" # default repo
	local temp="$THIS_CONF"
	local pick_xfburn="--rwork xfburn libburn libisofs"
	local pick_office="--alien libreoffice libreoffice-dict-en openjdk"
	# create list from parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--alien) repo="$1" ;;
			--alien-res) repo="$1" ;;
			--slack) repo="$1" ;;
			--salix) repo="$1" ;;
			--rwork) repo="$1" ;;
			--reset) temp="" ;;
			--office) temp="$temp $pick_office" ;;
			--xfburn) temp="$temp $pick_xfburn" ;;
			--exec) OPT_CHECK="NO" ;; # default is YES (check only)
			--check) OPT_CHECK="YES" ;; # in case need to override config
			--clean) OPT_CLEAN="YES" ;;
			--sweep) OPT_SWEEP="YES" ;;
			--path) shift ; path=$1 ;;
			-*) echo "$func: Unknown option '$1'!" ; exit 1 ;;
			*) temp="${temp} ${repo} $1" ;;
		esac
		shift
	done
	[ -z "$path" ] && path=$SLACKPATH
	[ ! -d "$path" ] && echo "$func: Creating '$path'" && mkdir -p $path
	path=`cd $path ; pwd`
	[ -z "$temp" ] && echo "$func: Empty pack list!" && exit 1
	local list ; create_list $temp
	local size=0 step
	temp=`echo $list | tr ';' ' '`
	for step in $temp ; do size=$((size+1)) ; done
	echo "Package Path: $path"
	echo "Package Count: $size"
	for step in $temp ; do do_findthat $path $step ; done
}

# just do it!
do_execthat $@ ; exit 0
