#!/bin/bash

# getslackpack
# - written by azman@my1matrix.net
# - standalone slackware package retriever

MY1TOOL="$(basename $0 .sh)"
MY1PATH="$(dirname $0)"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1TOOL
	[ -r $config ] && source $config && break
done

# setup path to slackware tree
SLACKROOT=${SLACKROOT:="$(pwd)"}
[ -z "$SLACKARCH" ] && [ -n "$ARCH" ] && SLACKARCH=$ARCH
SLACKARCH=${SLACKARCH:="$(uname -m)"}
case $SLACKARCH in
	x86|i*86) SLACKARCH="i486" ;;
	x86_64|amd64) SLACKARCH="x86_64" ;;
esac
SLACKSUFX=${SLACKSUFX:=""}
[ "$SLACKARCH" == "x86_64" ] && SLACKSUFX="64"
SLACKFULL=${SLACKFULL:="slackware${SLACKSUFX}"}
[ -z "$SLACKVERS" ] && [ -n "$RELEASE" ] && SLACKVERS=$RELEASE
SLACKVERS=${SLACKVERS:="current"}
SLACKFULL=${SLACKFULL}-${SLACKVERS}
SLACKPATH=${SLACKROOT}/slackpack

# default repo - alien stuffs!
DEF_ROOT="http://taper.alienbase.nl/mirrors/people/alien/slackbuilds"
DEF_REPO="alien"
DEF_PACK="libreoffice libreoffice-dict-en openjdk icedtea-web rhino"

# tool options
OPT_CHECK="NO"
OPT_CLEAN="NO"

function do_download()
{
	local fname="$1"
	local label="$2"
	local cpath="$(pwd)"
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -n "Downloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!" && exit 1
	echo -ne "\b\b\b\b DONE!\n"
}

function go_loadsums()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	# check clean option
	if [ "$OPT_CLEAN" == "YES" ] ; then
		rm -rf /tmp/$MY1TOOL
		[ $? -ne 0 ] && OPT_CLEAN="NO"
	fi
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# if not found OR nothing modified last 120 minutes
	if [ "$(find $pkg_sums -mmin -120 2>/dev/null)" == "" ]; then
		rm -rf $pkg_sums # just in case, delete old one
		wget --spider $pkg_root/$pkg_sums.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download $pkg_root/$pkg_sums.gz $pkg_sums.gz
			gzip -d $pkg_sums.gz
		else
			do_download $pkg_root/$pkg_sums $pkg_sums
		fi
		# we must have it!
		[ ! -r "$pkg_sums" ] &&
			echo "[ERROR] Cannot find $pkg_sums!" >&2 && exit 1
	fi
	cd - >/dev/null
}


function go_loadinfo()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	local pkg_file="PACKAGES.TXT"
	# obtain checksum
	go_loadsums $pkg_root $pkg_repo
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# if not found OR nothing modified last 120 minutes
	if [ "$(find $pkg_file -mmin -120 2>/dev/null)" == "" ]; then
		rm -rf $pkg_file # just in case, delete old one
		wget --spider $pkg_root/$pkg_file.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download $pkg_root/$pkg_file.gz $pkg_file.gz
			gzip -d $pkg_file.gz
		else
			do_download $pkg_root/$pkg_file $pkg_file
		fi
		# we must have it!
		[ ! -r "$pkg_file" ] &&
			echo "[ERROR] Cannot find $pkg_file!" >&2 && exit 1
		# check validity
		cat $pkg_sums | grep -e " ./${pkg_file}$" >$pkg_file.md5
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -ne 0 ] && rm -f $pkg_file &&
			echo "[ERROR] $pkg_file: Checksum failed!" >&2 && exit 1
	fi
	cd - >/dev/null
}

function go_findpack()
{
	local pkg_repo=$1
	local pkg_name=$2
	local pkg_arch=$3
	local pkg_vers=$4
	local pkg_temp=""
	local pkgs_txt="/tmp/$MY1TOOL/$pkg_repo/PACKAGES.TXT"
	# info structure?
	local pkg_file pkg_path
	local pkg_temp="${pkg_name}-[^-]*-[^-]*-[^-]*.t[gx]z$"
	local pkg_text="$(cat $pkgs_txt | grep -e "$pkg_temp" -A1 | tr '\n' ';')"
	[ "$pkg_text" = "" ] && return
	local ifs_save=$IFS
	IFS=$'\n'
	local pkg_list=($(echo "${pkg_text}" | sed 's/--/\n/g'))
	IFS=$ifs_save
	local loop
	for (( loop=0;loop<${#pkg_list[@]};loop++ )); do
		local pkg_test="$(echo ${pkg_list[$loop]} | sed 's/;/\n/g')"
		# extract basic info
		local chk_name="PACKAGE NAME:"
		pkg_file=$(echo "$pkg_test" | grep "^$chk_name")
		pkg_file="${pkg_file##${check_name}* }"
		[ "$(echo $pkg_file|grep -e "$pkg_arch")" == "" ] &&
			[ "$(echo $pkg_file|grep -e "noarch")" == "" ] && continue;
		chk_name="PACKAGE LOCATION:"
		pkg_path=$(echo "$pkg_test" | grep "^$chk_name")
		pkg_path="${pkg_path##${check_name}* }"
		pkg_path=$(echo $pkg_path|sed 's/^.\(.*\)$/\1/')
		[ "$pkg_repo" != "slack" ] &&
			[ "$(echo $pkg_path|grep -e "$pkg_vers")" == "" ] && continue;
		# first found - send and exit
		echo "$pkg_file $pkg_path"
		break;
	done
}

function go_loadpack()
{
	local pkg_root=$1
	local pkg_rsrc=$2
	local pkg_repo=$3
	local pkg_path=$4
	local pkg_file=$5
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	local pkg_md5f="$pkg_path/$pkg_file.md5"
	# obtain checksum
	go_loadsums $pkg_root $pkg_repo
	# prepare pack path for checksum
	mkdir -p $pkg_path
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# extract checksum for file
	cat $pkg_sums | grep -e "^.*${pkg_rsrc}/${pkg_file}$" >$pkg_md5f
	[ $? -ne 0 ] &&
		echo "[ERROR] Cannot create checksum for '$pkg_file'!" >&2 && exit 1
	# fix path in checksum file
	sed -i "s|${pkg_rsrc}||g" $pkg_md5f
	cd - >>/dev/null
	# go to package path
	cd $pkg_path
	# fix download path
	pkg_root=${pkg_root}${pkg_rsrc}
	# check if valid package exists
	if [ -r $pkg_file.md5 ]; then
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -eq 0 ] && echo "[INFO] Valid $pkg_file found!" && return
	fi
	# download if not found or invalid
	do_download $pkg_root/$pkg_file $pkg_file
	[ ! -r "$pkg_file" ] && rm -f $pkg_file.md5 &&
		echo "[ERROR] Cannot find $pkg_file!" >&2 && exit 1
	md5sum --check $pkg_file.md5 >/dev/null 2>&1
	[ $? -ne 0 ] && rm -f $pkg_file && rm -f $pkg_file.md5 &&
		echo "[ERROR] $pkg_file: Checksum failed!" >&2 && exit 1
	cd - >/dev/null
}

function do_readconf()
{
	# default repo
	local pkg_root="$DEF_ROOT"
	local pkg_repo="$DEF_REPO"
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--alien)
				pkg_root="http://taper.alienbase.nl"
				pkg_root="${pkg_root}/mirrors/people/alien/slackbuilds"
				pkg_repo="alien"
				;;
			--slack)
				pkg_root="http://mirrors.slackware.com"
				pkg_root="${pkg_root}/slackware/$SLACKFULL"
				pkg_repo="slack"
				;;
			-*)
				echo "Unknown repo '$1'!" >&2 && exit 1
				;;
			*)
				echo "${pkg_root},${pkg_repo},$1"
				;;
		esac
		shift
	done
}

function do_execthis()
{
	local pkg_root pkg_repo pkg_name pkg_this
	local pkg_file pkg_rsrc pkg_path=$SLACKPATH
	local pkg_arch=$SLACKARCH
	local pkg_vers=$SLACKVERS
	local ifs_save=$IFS
	IFS=$'\n'
	local pkg_list=($(echo "$@"))
	IFS=$ifs_save
	echo "[INFO] Package Count: ${#pkg_list[@]}"
	local loop
	for (( loop=0;loop<${#pkg_list[@]};loop++ )); do
		IFS=$'\n'
		local pkg_test=($(echo "${pkg_list[$loop]}" | sed 's/,/\n/g'))
		IFS=$ifs_save
		pkg_root="${pkg_test[0]}"
		pkg_repo="${pkg_test[1]}"
		pkg_name="${pkg_test[2]}"
		# load package info
		go_loadinfo $pkg_root $pkg_repo
		echo "[INFO] Looking in $pkg_repo repo for $pkg_name..."
		pkg_this=($(go_findpack $pkg_repo $pkg_name $pkg_arch $pkg_vers))
		if [ "$pkg_this" != "" ]; then
			pkg_file=${pkg_this[0]}
			pkg_rsrc=${pkg_this[1]}
			if [ "$OPT_CHECK" == "YES" ] ; then
				echo "[INFO] Package '$pkg_name' found ('$pkg_file')!"
			else
				go_loadpack $pkg_root $pkg_rsrc $pkg_repo $pkg_path $pkg_file
			fi
		else
			echo "[INFO] Package '$pkg_name' not found!"
		fi
	done
}

function chk_param()
{
	local chk_valid="--$DEF_REPO"
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--alien)
				chk_valid="$1"
				;;
			--slack)
				chk_valid="$1"
				;;
			--default)
				THIS_CONF="--$DEF_REPO $DEF_PACK ${THIS_CONF}"
				;;
			--check)
				OPT_CHECK="YES"
				;;
			--clean)
				OPT_CLEAN="YES"
				;;
			-*)
				echo "[ERROR] Unknown option '$1'!" >&2 && exit 1
				;;
			*)
				THIS_CONF="${THIS_CONF} ${chk_valid} $1 "
				;;
		esac
		shift
	done
}

# duh!
chk_param "$@"
# do your thing!
do_execthis "$(do_readconf $THIS_CONF)"

# look for duplicate and delete old???

exit 0
