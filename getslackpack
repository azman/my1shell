#!/bin/bash

# getslackpack
# - written by azman@my1matrix.net
# - standalone slackware package retriever

MY1TOOL="$(basename $0 .sh)"
MY1PATH="$(dirname $0)"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1TOOL
	[ -r $config ] && source $config && break
done

# setup path to slackware tree
SLACKROOT=${SLACKROOT:="$(pwd)"}
[ -z "$SLACKARCH" ] && [ -n "$ARCH" ] && SLACKARCH=$ARCH
SLACKARCH=${SLACKARCH:="$(uname -m)"}
SLACKSUFX=${SLACKSUFX:=""}
[ "$SLACKARCH" == "x86_64" ] && SLACKSUFX="64"
SLACKFULL=${SLACKFULL:="slackware${SLACKSUFX}"}
[ -z "$SLACKVERS" ] && [ -n "$RELEASE" ] && SLACKVERS=$RELEASE
SLACKVERS=${SLACKVERS:=""}
if [ "$SLACKVERS" == "" ]; then
	if [ ! -f /etc/slackware-version ]; then
		# if running from other than slack
		SLACKVERS="current"
	else
		SLACKVERS=$(cat /etc/slackware-version)
		SLACKVERS=${SLACKVERS#Slackware }
		SLACKVMAJ=${SLACKVERS%%.*}
		SLACKVMIN=${SLACKVERS#*.}
		[ "${SLACKVMIN//./}" != "$SLACKVMIN" ] && SLACKVMIN=${SLACKVMIN%%.*}
		SLACKVERS=${SLACKVMAJ}.${SLACKVMIN}
	fi
fi
SLACKFULL=${SLACKFULL}-${SLACKVERS}
SLACKPATH=${SLACKROOT}/slackpack${SLACKSUFX}-${SLACKVERS}

# x86 packages usually target specific arch
ARCH_X86=${ARCH_X86:="i486"}
case $SLACKARCH in
	x86|i*86) SLACKARCH=${ARCH_X86} ;;
esac

# default repo - alien stuffs!
BOB_ROOT="http://bear.alienbase.nl"
DEF_ROOT="${BOB_ROOT}/mirrors/people/alien/slackbuilds"
DEF_REPO="alien"
DEF_PACK="libreoffice libreoffice-dict-en openjdk icedtea-web rhino"
MTL_REPO="multilib"
MTL_PACK="compat32-tools"
MTL_PACK="$MTL_PACK glibc glibc-i18n glibc-profile glibc-solibs glibc-zoneinfo"
MTL_PACK="$MTL_PACK gcc gcc-g++ gcc-gfortran gcc-gnat gcc-go gcc-java gcc-objc"

# tool options - allow config file to set these...
OPT_CHECK=${OPT_CHECK:="YES"}
OPT_CLEAN=${OPT_CLEAN:="NO"}
THIS_CONF=${THIS_CONF:=""}

function do_download()
{
	local fname="$1"
	local label="$2"
	local cpath="$(pwd)"
	local cname=""
	[ "$fname" == "" ] && exit 1 # shouldn't be here?
	[ "$label" == "" ] && label="$fname"
	[ "${fname//$label/}" == "${fname}" ] && cname="--output-document=$label"
	echo -n "Downloading $label:     "
	wget $cname --no-use-server-timestamps --progress=dot "$fname" 2>&1 | \
		grep --line-buffered "%" | sed -u -e "s,\.,,g" | \
		awk '{printf("\b\b\b\b%4s", $2)}'
	[ ! -r "$label" ] &&
		echo -e "\nCannot download source $fname to $cpath/$label!" && exit 1
	echo -ne "\b\b\b\b DONE!\n"
}

function go_loadsums()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	# check clean option
	if [ "$OPT_CLEAN" == "YES" ] ; then
		rm -rf /tmp/$MY1TOOL
		[ $? -eq 0 ] && OPT_CLEAN="NO"
	fi
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# if not found OR nothing modified last 120 minutes
	if [ "$(find $pkg_sums -mmin -120 2>/dev/null)" == "" ]; then
		rm -rf ${pkg_sums}* # just in case, delete old one
		wget --spider $pkg_root/$pkg_sums.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download $pkg_root/$pkg_sums.gz $pkg_sums.gz
			gzip -d $pkg_sums.gz
		else
			do_download $pkg_root/$pkg_sums $pkg_sums
		fi
		# we must have it!
		[ ! -r "$pkg_sums" ] &&
			echo "[ERROR] Cannot find $pkg_sums!" >&2 && exit 1
	fi
	cd - >/dev/null
}

function go_loadinfo()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	local pkg_file="PACKAGES.TXT"
	# obtain checksum
	go_loadsums $pkg_root $pkg_repo
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# if not found OR nothing modified last 24x60 minutes
	if [ "$(find $pkg_file -mmin -1440 2>/dev/null)" == "" ]; then
		rm -rf ${pkg_file}* # just in case, delete old one
		wget --spider $pkg_root/$pkg_file.gz >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download $pkg_root/$pkg_file.gz $pkg_file.gz
			gzip -d $pkg_file.gz
		else
			do_download $pkg_root/$pkg_file $pkg_file
		fi
		# we must have it!
		[ ! -r "$pkg_file" ] &&
			echo "[ERROR] Cannot find $pkg_file!" >&2 && exit 1
		# check validity
		cat $pkg_sums | grep -e " ./${pkg_file}$" >$pkg_file.md5
		if [ -r "${pkg_file}.md5" -a "$(cat ${pkg_file}.md5)" != "" ]; then
			md5sum --check $pkg_file.md5 >/dev/null 2>&1
			[ $? -ne 0 ] && rm -f $pkg_file &&
				echo "[ERROR] $pkg_file: Checksum failed!" >&2 && exit 1
		else
			echo "[WARN] $pkg_file validity not checked! (no md5)"
		fi
	fi
	cd - >/dev/null
}

function go_findpack()
{
	local pkg_repo=$1
	local pkg_name=$2
	local pkg_arch=$3
	local pkg_vers=$4
	local pkg_temp=""
	local pkgs_txt="/tmp/$MY1TOOL/$pkg_repo/PACKAGES.TXT"
	# info structure?
	local pkg_file pkg_path
	local pkg_temp="${pkg_name}-[^-]*-[^-]*-[^-]*.t[gx]z$"
	local pkg_text="$(cat $pkgs_txt | grep -e "$pkg_temp" -A2 | tr '\n' ';')"
	[ "$pkg_text" = "" ] && return
	local ifs_save=$IFS
	IFS=$'\n'
	local pkg_list=($(echo "${pkg_text}" | sed 's/--/\n/g'))
	IFS=$ifs_save
	local loop
	for (( loop=0;loop<${#pkg_list[@]};loop++ )); do
		local pkg_test="$(echo ${pkg_list[$loop]} | sed 's/;/\n/g')"
		# extract basic info
		local chk_name="PACKAGE NAME:"
		pkg_file=$(echo "$pkg_test" | grep "^$chk_name")
		pkg_file="${pkg_file##${check_name}* }"
		local tmp_arch=$pkg_arch
		[ "$pkg_arch" == "i486" ] && [ "$pkg_repo" == "salix" ] &&
			tmp_arch="i686"
		[ "$(echo $pkg_file|grep -e "$tmp_arch")" == "" ] &&
			[ "$(echo $pkg_file|grep -e "noarch")" == "" ] && continue;
		chk_name="PACKAGE LOCATION:"
		pkg_path=$(echo "$pkg_test" | grep "^$chk_name")
		pkg_path="${pkg_path##${check_name}* }"
		pkg_path=$(echo $pkg_path|sed 's/^.\(.*\)$/\1/')
		[ "$pkg_repo" == "alien" ] &&
			[ "$(echo $pkg_path|grep -e "$pkg_vers")" == "" ] && continue;
		[ "$pkg_repo" == "aliensec" ] &&
			[ "$(echo $pkg_path|grep -e "$pkg_vers")" == "" ] && continue;
		[ "$pkg_repo" == "multilib" ] &&
			[ "$(echo $pkg_path|grep -e "$pkg_vers")" == "" ] && continue;
		# first found - send and exit
		echo "$pkg_file $pkg_path"
		break;
	done
}

function go_loadpack()
{
	local pkg_root=$1
	local pkg_rsrc=$2
	local pkg_repo=$3
	local pkg_path=$4
	local pkg_file=$5
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo"
	local pkg_sums="CHECKSUMS.md5"
	local pkg_md5f="$pkg_path/$pkg_file.md5"
	# obtain checksum
	go_loadsums $pkg_root $pkg_repo
	# prepare pack path for checksum
	mkdir -p $pkg_path
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# extract checksum for file
	cat $pkg_sums | grep -e "^.*${pkg_rsrc}/${pkg_file}$" >$pkg_md5f
	[ $? -ne 0 ] &&
		echo "Cannot create checksum for '$pkg_file'!" && exit 1
	# fix path in checksum file
	sed -i "s|${pkg_rsrc}||g" $pkg_md5f
	cd - >/dev/null
	# go to package path
	cd $pkg_path
	# fix download path
	pkg_root=${pkg_root}${pkg_rsrc}
	local pkg_test="KO"
	# tell them...
	echo -n "$pkg_file"
	# check if valid package exists
	if [ -r $pkg_file.md5 ]; then
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -eq 0 ] && pkg_test="OK"
		if [ "$pkg_test" == "OK" ]; then
			echo -n " (LOCAL)"
		else
			if [ -f "${pkg_file}" ] ; then
				rm -rf ${pkg_file}
				echo -n " ..."
			fi
		fi
	fi
	echo
	# find old files?
	pkg_name=${pkg_file%-*} # strip build
	pkg_name=${pkg_name%-*} # strip arch
	pkg_name=${pkg_name%-*} # strip vers
	for tmp in ${pkg_name}* ; do
		# make sure same package name (not extended)
		tmp_name=${tmp%-*} # strip build
		tmp_name=${tmp_name%-*} # strip arch
		tmp_name=${tmp_name%-*} # strip vers
		[ "$tmp_name" != "$pkg_name" ] && continue;
		# leave the current ones
		[ "$tmp" == "${pkg_file}" ] && continue;
		[ "$tmp" == "${pkg_file}.md5" ] && continue;
		echo -n "Found '$tmp'"
		[ "$OPT_CHECK" == "YES" -o "$OPT_CLEAN" == "NO" ] &&
			echo && continue
		rm -rf $tmp
		echo ": REMOVED."
	done
	if [ "$OPT_CHECK" != "YES" ] && [ "$pkg_test" == "KO" ]; then
		# download if not found or invalid
		do_download $pkg_root/$pkg_file $pkg_file
		[ ! -r "$pkg_file" ] && rm -f $pkg_file.md5 &&
			echo "[ERROR] Download error?!" && exit 1
		md5sum --check $pkg_file.md5 >/dev/null 2>&1
		[ $? -ne 0 ] && rm -f $pkg_file && rm -f $pkg_file.md5 &&
			echo "[ERROR] Checksum failed!" && exit 1
	fi
	cd - >/dev/null
}

function do_readconf()
{
	# default repo
	local pkg_root="$DEF_ROOT"
	local pkg_repo="$DEF_REPO"
	local pkg_rawp=""
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--alien)
				pkg_root="${BOB_ROOT}"
				pkg_root="${pkg_root}/mirrors/people/alien/slackbuilds"
				pkg_repo="alien"
				pkg_rawp=""
				;;
			--aliensec)
				pkg_root="${BOB_ROOT}"
				pkg_root="${pkg_root}/mirrors/people/alien"
				pkg_root="${pkg_root}/restricted_slackbuilds"
				pkg_repo="aliensec"
				pkg_rawp=""
				;;
			--slack)
				pkg_root="http://mirrors.slackware.com"
				pkg_root="${pkg_root}/slackware/$SLACKFULL"
				pkg_repo="slack"
				pkg_rawp=""
				;;
			--salix)
				pkg_root="http://download.salixos.org"
				pkg_root="${pkg_root}/$SLACKARCH/$SLACKVERS"
				pkg_repo="salix"
				pkg_rawp=""
				;;
			--rwork)
				pkg_root="http://rlworkman.net"
				pkg_root="${pkg_root}/pkgs/$SLACKVERS/$SLACKARCH"
				pkg_repo="rwork"
				pkg_rawp=",go_raw"
				;;
			--multilib)
				pkg_root="${BOB_ROOT}"
				pkg_root="${pkg_root}/mirrors/people/alien/multilib"
				pkg_repo="multilib"
				pkg_rawp=""
				;;
			-*)
				echo "Unknown repo '$1'!" >&2 && exit 1
				;;
			*)
				echo "${pkg_root},${pkg_repo},$1${pkg_rawp}"
				;;
		esac
		shift
	done
}

function go_loadrawl()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_arch=$3
	local pkg_temp="/tmp/$MY1TOOL/$pkg_repo/$pkg_arch"
	local pkg_list="index.html"
	# check clean option
	if [ "$OPT_CLEAN" == "YES" ] ; then
		rm -rf /tmp/$MY1TOOL
		[ $? -eq 0 ] && OPT_CLEAN="NO"
	fi
	# prepare temp
	mkdir -p $pkg_temp ; cd $pkg_temp
	# if not found OR nothing modified last 120 minutes
	if [ "$(find $pkg_list -mmin -120 2>/dev/null)" == "" ]; then
		rm -rf $pkg_list # just in case, delete old one
		wget --spider $pkg_root >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			do_download $pkg_root $pkg_list
		fi
		# we must have it!
		[ ! -r "$pkg_list" ] &&
			echo "[ERROR] Cannot get $pkg_list!" >&2 && exit 1
	fi
	cd - >/dev/null
}

function go_findrawl()
{
	local pkg_repo=$1
	local pkg_name=$2
	local pkg_arch=$3
	local pkg_vers=$4
	local pkgs_txt="/tmp/$MY1TOOL/$pkg_repo/$pkg_arch/index.html"
	# info structure?
	local pkg_temp="${pkg_name}-[^-]*-${pkg_arch}-[^-]*.t[gx]z "
	local pkg_text="$(cat $pkgs_txt | sed -e :a -e 's/<[^>]*>//g;/</N;//ba')"
	local pkg_test="$(echo "$pkg_text" | grep -e 't[gx]z\s' | grep $pkg_name)"
	[ "$pkg_test" = "" ] && return
	local pkg_file="$(echo ${pkg_test} | cut -d " " -f 1)"
	[ "$pkg_file" = "" ] && return
	# check for md5 file
	pkg_temp="${pkg_name}-[^-]*-${pkg_arch}-[^-]*.t[gx]z.md5"
	pkg_test="$(echo "$pkg_text" | grep -e "$pkg_temp" )"
	local pkg_md5s="$(echo ${pkg_test} | cut -d " " -f 1)"
	# send it out
	[ "$pkg_md5s" != "" ] && pkg_md5s=",$pkg_md5s"
	echo "${pkg_file}${pkg_md5s}"
}

function go_packrawl()
{
	local pkg_root=$1
	local pkg_repo=$2
	local pkg_path=$3
	local pkg_file=$4
	local pkg_rsrc=$5
	local pkg_test="KO"
	# tell them...
	echo -n "$pkg_file"
	# prepare / change to pack path
	mkdir -p $pkg_path ; cd $pkg_path
	if [ -f "${pkg_file}.md5" ]; then
		md5sum --check ${pkg_file}.md5 >/dev/null 2>&1
		[ $? -eq 0 ] && pkg_test="OK"
		if [ "$pkg_test" == "OK" ]; then
			echo -n " (LOCAL)"
		else
			if [ -f "${pkg_file}" ] ; then
				rm -rf ${pkg_file}
				echo -n " ..."
			fi
		fi
	fi
	echo
	if [ "$OPT_CHECK" != "YES" ] && [ "$pkg_test" == "KO" ]; then
		# download if old?
		if [ "$(find $pkg_file -mmin -1440 2>/dev/null)" == "" ]; then
			rm -rf $pkg_file # just in case, delete old one
			do_download $pkg_root/$pkg_file $pkg_file
			if [ "$pkg_rsrc" == "${pkg_file}.md5" ]; then
				rm -rf $pkg_rsrc # just in case, delete old one
				do_download $pkg_root/$pkg_rsrc $pkg_rsrc
			fi
			if [ ! -r "$pkg_file" ]; then
				echo "[ERROR] Download Error?!"
			elif [ -r "$pkg_rsrc" ]; then
				pkg_test="KO"
				md5sum --check $pkg_rsrc >/dev/null 2>&1
				[ $? -eq 0 ] && pkg_test="OK"
				if [ "$pkg_test" != "OK" ]; then
					echo "[ERROR] Checksum failed!" &&
						rm -f $pkg_file && rm -f $pkg_rsrc
				fi
			fi
		fi
	fi
	cd - >/dev/null
}

function do_execthis()
{
	local pkg_root pkg_repo pkg_name pkg_this
	local pkg_file pkg_rsrc pkg_path=$SLACKPATH
	local pkg_arch=$SLACKARCH
	local pkg_vers=$SLACKVERS
	local ifs_save=$IFS
	IFS=$'\n'
	local pkg_list=($(echo "$@"))
	IFS=$ifs_save
	echo "Package Path: ${pkg_path}"
	echo "Package Count: ${#pkg_list[@]}"
	local loop
	for (( loop=0;loop<${#pkg_list[@]};loop++ )); do
		IFS=$'\n'
		local pkg_test=($(echo "${pkg_list[$loop]}" | sed 's/,/\n/g'))
		IFS=$ifs_save
		pkg_root="${pkg_test[0]}"
		pkg_repo="${pkg_test[1]}"
		pkg_name="${pkg_test[2]}"
		pkg_rawp="${pkg_test[3]}"
		pkg_file=""
		#echo "[DEBUG] '$pkg_root','$pkg_repo','$pkg_name','$pkg_rawp'"
		if [ "$pkg_rawp" == "go_raw" ]; then
			go_loadrawl $pkg_root $pkg_repo $pkg_arch
			echo -n "{$pkg_repo} '$pkg_name': "
			pkg_this="$(go_findrawl $pkg_repo $pkg_name $pkg_arch $pkg_vers)"
			if [ "$pkg_this" != "" ]; then
				if [ "${pkg_this//,/;}" != "${pkg_this}" ]; then
					pkg_rsrc="$(echo ${pkg_this//,/;} | cut -d ";" -f 2)"
					pkg_file="${pkg_this//,${pkg_rsrc}/}"
				else
					pkg_rsrc=""
					pkg_file=${pkg_this}
				fi
				go_packrawl $pkg_root $pkg_repo $pkg_path $pkg_file $pkg_rsrc
			else
				echo "not found!"
			fi
		else
			go_loadinfo $pkg_root $pkg_repo
			echo -n "{$pkg_repo} '$pkg_name': "
			pkg_this=($(go_findpack $pkg_repo $pkg_name $pkg_arch $pkg_vers))
			if [ "$pkg_this" != "" ]; then
				pkg_file=${pkg_this[0]}
				pkg_rsrc=${pkg_this[1]}
				go_loadpack $pkg_root $pkg_rsrc $pkg_repo $pkg_path $pkg_file
			else
				echo "not found!"
			fi
		fi
	done
}

function chk_param()
{
	local chk_valid="--$DEF_REPO"
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--alien)
				chk_valid="$1"
				;;
			--aliensec)
				chk_valid="$1"
				;;
			--slack)
				chk_valid="$1"
				;;
			--salix)
				chk_valid="$1"
				;;
			--rwork)
				chk_valid="$1"
				;;
			--reset)
				THIS_CONF=""
				;;
			--default)
				THIS_CONF="${THIS_CONF} --$DEF_REPO $DEF_PACK"
				;;
			--multilib)
				THIS_CONF="${THIS_CONF} --$MTL_REPO $MTL_PACK"
				;;
			--xfburn)
				THIS_CONF="${THIS_CONF} --rwork xfburn libburn libisofs"
				;;
			--exec)
				OPT_CHECK="NO"
				;;
			--clean)
				OPT_CLEAN="YES"
				;;
			--path)
				shift
				[ ! -d "$1" ] &&
					echo "[ERROR] Invalid path '$1'!" && exit 1
				SLACKPATH=`cd $1; pwd`
				;;
			-*)
				echo "[ERROR] Unknown option '$1'!"
				exit 1
				;;
			*)
				THIS_CONF="${THIS_CONF} ${chk_valid} $1 "
				;;
		esac
		shift
	done
}

# duh!
chk_param "$@"
# do your thing!
do_execthis "$(do_readconf $THIS_CONF)"

# look for duplicate and delete old???

exit 0
