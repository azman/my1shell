#!/bin/bash

# slackroot
# - written by azman@my1matrix.org
# - slackware 32-bit chroot install and update

# standard tool info
MY1_TOOLNAME="my1 Slackware chroot32 Tool"
MY1_TOOLVERS="2019.06.01"
MY1_TOOLBASE=`basename $0 .sh`
MY1_TOOLPATH=`dirname $0`
MY1_TOOLPATH=`cd $MY1_TOOLPATH;pwd`
MY1_TLIBNAME="libmy1slack"
MY1_TLIBFULL="$MY1_TOOLPATH/$MY1_TLIBNAME"
# look for my1slack library
[ -r "$MY1_TLIBFULL" ] && . $MY1_TLIBFULL
# get slackware tree info - make sure 32-bit?
SLACKNAME="slackware"
call_setup
# tool specific
MY1_TOOL_LOG=${MY1_TOOL_LOG:="/tmp/${MY1_TOOLBASE}.log"}
MY1_ROOT_DEF=${MY1_ROOT_DEF:="/opt/chroot32"}
# global options & settings
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  create : Creates a custom root installation
  update : Updates a custom root installation
Options:
  -v | --verbose : More info
  -x | --execute : Execute (else just dry run!)
  -r | --root <path> : Specify root path (default: $MY1_ROOT_DEF)
  -p | --path <path> : Specify path for packages
  -f | --file <file> : Specify file containing package list
       --core    : Select basic system tool packages
       --console : Select console application packages
       --desktop : Select desktop application packages
Log File:
  $MY1_TOOL_LOG
SETHELPMSG
)

do_root_update()
{
	local chk_root=$1
	local chk_exec="NO"
	local chk_syyy="YES"
	local pkg_list pkg_temp pkg_opts="--reinstall --install-new"
	# check 'command-line'
	shift # first param is chk_root
	while [ "$1" != "" ]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			--verbose) chk_syyy="NO" ;;
			*)
				if [ ! -f $pkg_temp ] ; then
					warn_msg "File '$pkg_temp' not found! Not included!\n"
				else
					pkg_list="${pkg_list}$pkg_temp "
				fi
				;;
		esac
		shift
	done
	# check valid root path... if executing!
	[ "$chk_exec" == "YES" ] &&
		must_have_path "$chk_root" "Root path '$chk_root' not found!"
	# install packages in list to given root
	if [ "$chk_exec" == "YES" ]; then
		echo "$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)" >$MY1_TOOL_LOG
		echo "ExecTime: $(date +%Y%m%d%H%M)" >>$MY1_TOOL_LOG
	fi
	for pkg_file in $pkg_list; do
		[ "$chk_syyy" != "YES" ] && echo &&
			info_msg "Updating $(basename $pkg_file) in $chk_root ..."
		[ "$chk_exec" == "YES" ] &&
			ROOT=$chk_root upgradepkg $pkg_opts $pkg_file >>$MY1_TOOL_LOG
		[ "$chk_syyy" != "YES" ] && info_msg --no-tag " done!"
	done
	[ "$chk_syyy" != "YES" ] && echo
}

do_root_install()
{
	local chk_root=$1
	local chk_exec="NO"
	local chk_syyy="YES"
	local pkg_list pkg_temp
	# check 'command-line'
	shift # first param is chk_root
	while [ "$1" != "" ]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			--verbose) chk_syyy="NO" ;;
			*)
				if [ ! -f $pkg_temp ] ; then
					warn_msg "File '$pkg_temp' not found! Not included!\n"
				else
					pkg_list="${pkg_list}$pkg_temp "
				fi
				;;
		esac
		shift
	done
	# check valid root path... if executing!
	[ "$chk_exec" == "YES" ] &&
		must_have_path "$chk_root" "Root path '$chk_root' not found!"
	# install packages in list to given root
	if [ "$chk_exec" == "YES" ]; then
		echo "$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)" >$MY1_TOOL_LOG
		echo "ExecTime: $(date +%Y%m%d%H%M)" >>$MY1_TOOL_LOG
	fi
	for pkg_file in $pkg_list; do
		[ "$chk_syyy" != "YES" ] && echo &&
			info_msg "Installing $(basename $pkg_file) to $chk_root ..."
		[ "$chk_exec" == "YES" ] &&
			installpkg --root $chk_root $pkg_file >>$MY1_TOOL_LOG
		[ "$chk_syyy" != "YES" ] && info_msg --no-tag " done!"
	done
	[ "$chk_syyy" != "YES" ] && echo
}

do_pack_list()
{
	local pkg_core="a d k l n"
	local pkg_apps="ap t tcl"
	local pkg_xgui="x xap"
	local pkg_path=$1
	local pkg_opts=$2
	local pkg_list pkg_file
	# check package option
	case "$pkg_opts" in
		CORE) pkg_opts="$pkg_core" ;;
		CONS) pkg_opts="$pkg_core $pkg_apps" ;;
		DESK) pkg_opts="$pkg_core $pkg_apps $pkg_xgui" ;;
		*) error_exit "Unknown package option!\n\n" ;;
	esac
	# check valid pkg path
	must_have_path "$pkg_path" "Package(s) path '$pkg_path' not found!"
	# select packages
	for pkg_soft in $pkg_opts; do
		cd $pkg_path
		if [ -d $pkg_soft ] ; then
			cd $pkg_soft
			for pkg_name in $(find . -name "*.t[xg]z"|uniq|sort); do
				pkg_file=${pkg_path}/${pkg_soft}/${pkg_name//.\//}
				pkg_list="${pkg_list}${pkg_file} "
			done
		fi
	done
	echo -n "$pkg_list"
}

rootfs_create()
{
	local pkg_path="$SLACKPACK"
	local pkg_opts="CORE" # default package set
	local chk_root="$MY1_ROOT_DEF"
	local chk_file=""
	local chk_exec=""
	local chk_syyy=""
	local pkg_list pkg_temp tmp_list pkg_name pkg_base
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--path)
				shift
				pkg_path="$(cd $1;pwd)"
				;;
			--root)
				shift
				chk_root=$1
				;;
			--file)
				shift
				chk_file=$1
				pkg_opts="FILE"
				;;
			--core)
				pkg_opts="CORE"
				;;
			--console)
				pkg_opts="CONS"
				;;
			--desktop)
				pkg_opts="DESK"
				;;
			--verbose)
				chk_syyy="--verbose"
				;;
			--exec)
				chk_exec="--exec"
				;;
			*)
				error_exit "Unknown parameter '$1'!\n\n"
				;;
		esac
		shift
	done
	# must be root to exec!
	[ "$chk_exec" == "--exec" ] && must_be_root
	# check in case we're only simulating target root (need not exist!)
	if [ "$chk_exec" != "--exec" ] ; then
		if [ "${chk_root:0:1}" != "/" ] ; then
			[ "${chk_root:0:2}" == "./" ] && chk_root=${chk_root:2}
			chk_root="$(pwd)/${chk_root}"
		fi
	fi
	# check paths
	[ ! -d "$pkg_path" ] && error_exit "Cannot find pkg path '$pkg_path'!\n\n"
	[ -d "$chk_root" ] && error_exit "Existing root path '$chk_root'!\n\n"
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	info_msg "Pack option: '$pkg_opts'\n"
	# start main info msg
	info_msg "Creating root filesystem... "
	# if executing, check/create root path
	if [ "$chk_exec" == "--exec" ] ; then
		mkdir -p $chk_root
		chk_root=$(cd $chk_root;pwd)
		[ "$chk_syyy" == "--verbose" ] &&
			info_msg "(Target path: '$chk_root') "
	fi
	# if package list given, use it!
	if [ "$pkg_opts" == "FILE" ]; then
		[ ! -r $chk_file ] &&
			error_msg "Cannot open package file '$chk_file'!\n" && return
		ifs_save=$IFS
		IFS=$'\n'
		tmp_list=($(cat $chk_file))
		IFS=$ifs_save
		for (( x=0;x<${#tmp_list[@]};x++ )); do
			pkg_base=${tmp_list[$x]}
			pkg_name=${pkg_base#*!}
			pkg_base=$(find_package $pkg_name)
			pkg_temp=$(find $pkg_path -name "${pkg_base}.t[xg]z")
			pkg_list="${pkg_list}${pkg_temp} "
		done
	else
		# create package list based on pkg_opts
		pkg_list=$(do_pack_list $pkg_path $pkg_opts $chk_file)
	fi
	# install the packages
	do_root_install $chk_root $pkg_list $chk_syyy $chk_exec
	# end main info msg
	info_msg --no-tag "done.\n"
}

rootfs_update()
{
	local pkg_path="$SLACKPACK"
	local chk_root="$MY1_ROOT_DEF"
	local chk_exec=""
	local chk_syyy=""
	local pkg_list pkg_temp pkg_name pkg_base
	local chk_list chk_stat chk_temp
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--path)
				shift
				pkg_path="$(cd $1;pwd)"
				;;
			--root)
				shift
				chk_root=$1
				;;
			--verbose)
				chk_syyy="--verbose"
				;;
			--exec)
				chk_exec="--exec"
				;;
			*)
				error_exit "Unknown parameter '$1'!\n\n"
				;;
		esac
		shift
	done
	# must be root to exec!
	[ "$chk_exec" == "--exec" ] && must_be_root
	# ensure full path for chk_root
	if [ "${chk_root:0:1}" != "/" ] ; then
		[ "${chk_root:0:2}" == "./" ] && chk_root=${chk_root:2}
		chk_root="$(pwd)/${chk_root}"
	fi
	# check paths
	[ ! -d "$pkg_path" ] && error_exit "Cannot find pkg path '$pkg_path'!\n\n"
	[ ! -d "$chk_root" ] && error_exit "Cannot find root path '$chk_root'!\n\n"
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	# start main info msg
	info_msg "Updating root filesystem... "
	# find patches
	chk_list=`list_patches --root $chk_root | tr ';' ' '`
	for pkg_that in $chk_list ; do
		chk_stat=`echo $pkg_that | cut -d':' -f2`
		chk_temp=`echo $pkg_that | cut -d':' -f3`
		[ "$chk_stat" == "check" ] && pkg_list="${pkg_list}${chk_temp} "
	done
	if [ "$pkg_list" == "" ] ; then
		info_msg --no-tag "Nothing to update.\n"
		return
	fi
	# install the packages
	do_root_update $chk_root $pkg_list $chk_syyy $chk_exec
	# end main info msg
	info_msg --no-tag "done.\n"
}

function process_command()
{
	local chk_task=$1 ; shift
	[ -z "$chk_task" ] && echo -e "$MSG_THISHELP\n" && exit 0
	case $chk_task in
		create) rootfs_create $@ ;;
		update) rootfs_update $@ ;;
		*) echo -e "Unknown command '$chk_task'\n" && exit 1 ;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
