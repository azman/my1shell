#!/bin/bash

# slackroot
# - written by azman@my1matrix.org
# - slackware root install and update

# standard tool info
TOOL_NAME=`basename $0 .sh`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH;pwd`
TOOL_DESC="my1 Slackware RootFS Tool"
TOOL_VERS="2020.03.00"
TOOL_HELP=$(cat <<SETHELPMSG
Usage:
  $TOOL_NAME <command> [options]
Commands:
  create : Creates a custom root installation (also inserts)
  update : Updates a custom root installation
Options:
  -x | --execute : Execute (else just dry run!)
       --root <path> : Specify root path
       --path <path> : Specify path for packages
       --file <file> : Specify file containing package list
       --core    : Select basic system tool packages
       --console : Select console application packages
       --desktop : Select desktop application packages
SETHELPMSG
)

source_lib()
{
	local name=$1
	local full=$TOOL_PATH/$name
	[ ! -f "$full" ] && echo "Cannot find $full!" && exit 1
	. $full
}

source_lib libmy1slack
source_lib libmy1echo
source_lib libmy1file

do_root_update()
{
	local chk_root=$1
	local chk_exec="NO"
	local pkg_list pkg_temp pkg_opts
	# check 'command-line'
	shift # first param is chk_root
	while [ "$1" != "" ]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			--reinstall) pkg_opts="${pkg_opts}${pkg_temp} " ;;
			--install-new) pkg_opts="${pkg_opts}${pkg_temp} " ;;
			*) [ -f $pkg_temp ] && pkg_list="${pkg_list}$pkg_temp " ||
					warn_msg "File '$pkg_temp' not found!\n" ;;
		esac
		shift
	done
	# must be root to exec!
	[ "$chk_exec" = "YES" ] && must_be_root
	local chk_logs=$chk_root/install.logs
	# install packages in list to given root
	for pkg_file in $pkg_list; do
		echo -n "-- Updating $(basename $pkg_file)... "
		[ "$chk_exec" == "YES" ] &&
			ROOT=$chk_root upgradepkg $pkg_opts $pkg_file >>$chk_logs
		echo "done!"
	done
}

do_root_install()
{
	local chk_root=$1
	local chk_exec="NO"
	local pkg_list pkg_temp
	# check 'command-line'
	shift # first param is chk_root
	while [ "$1" != "" ]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			*) [ -f $pkg_temp ] && pkg_list="${pkg_list}$pkg_temp " ||
					warn_msg "File '$pkg_temp' not found!\n" ;;
		esac
		shift
	done
	# must be root to exec!
	[ "$chk_exec" = "YES" ] && must_be_root
	# ensure root path... if executing!
	[ "$chk_exec" = "YES" ] && make_path "$chk_root"
	local chk_logs=$chk_root/install.logs
	# install packages in list to given root
	local pkg_file pkg_base pkg_name
	local chk_path=$(pwd)
	local chk_inst=`which installpkg 2>/dev/null`
	for pkg_file in $pkg_list; do
		# use {grep -E -- "^-- "} to view these lines
		pkg_base=$(basename $pkg_file)
		pkg_name=$(basename $(dirname $pkg_file))
		pkg_name=${pkg_name}-${pkg_base%.*}
		echo -n "-- Installing ${pkg_base}... "
		if [ "$chk_exec" == "YES" ] ; then
			if [ -z "$chk_inst" ] ; then
				echo -n "[tar]... "
				cd $chk_root
				tar xf $pkg_file >>$chk_logs 2>>&1
				[ $? -ne 0 ] && echo -n "<???>... "
				if [ -d install ] ; then
					mv install install-${pkg_name}
					mkdir -p tmp/${TOOL_NAME}
					rm -rf tmp/${TOOL_NAME}/install-${pkg_name}
					mv install-${pkg_name} tmp/${TOOL_NAME}/
				fi
				cd $chk_path
			else
				echo -n "[pkg]... "
				installpkg --root $chk_root $pkg_file >>$chk_logs
			fi
		fi
		echo "done!"
	done
}

do_pack_list()
{
	local pkg_core="a d k l n"
	local pkg_apps="ap t tcl"
	local pkg_xgui="x xap"
	local pkg_path=$1
	local pkg_opts=$2
	local pkg_list pkg_file
	# check package option
	case "$pkg_opts" in
		CORE) pkg_opts="$pkg_core" ;;
		CONS) pkg_opts="$pkg_core $pkg_apps" ;;
		DESK) pkg_opts="$pkg_core $pkg_apps $pkg_xgui" ;;
		*) error_exit "Unknown package option!\n\n" ;;
	esac
	# check valid pkg path
	must_have_path "$pkg_path" "Package(s) path '$pkg_path' not found!"
	# select packages
	for pkg_soft in $pkg_opts; do
		cd $pkg_path
		if [ -d $pkg_soft ] ; then
			cd $pkg_soft
			for pkg_name in $(find . -name "*.t[xg]z"|uniq|sort); do
				pkg_file=${pkg_path}/${pkg_soft}/${pkg_name//.\//}
				pkg_list="${pkg_list}${pkg_file} "
			done
		fi
	done
	echo -n "$pkg_list"
}

rootfs_create()
{
	local pkg_opts="CORE" # default package set
	local chk_root=`pwd`
	local chk_file chk_exec chk_arch
	# get defaults from running system
	local chk_path="/home"
	local chk_name=`find_slackname`
	local chk_vers=`find_slackvers`
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--root) shift ; chk_root=$1 ;;
			--path) shift ; chk_path=$1 ;;
			--arch) shift ; chk_arch=$1 ;;
			--vers) shift ; chk_vers=$1 ;;
			--file) shift ; chk_file=$1 ; pkg_opts="FILE" ;;
			--core) pkg_opts="CORE" ;;
			--console) pkg_opts="CONS" ;;
			--desktop) pkg_opts="DESK" ;;
			--execute|--exec|-x) chk_exec="--exec" ;;
			-*|*) error_exit "Unknown parameter '$1'!\n\n" ;;
		esac
		shift
	done
	# check specified arch!
	if [ ! -z "$chk_arch" ] ; then
		case "$chk_arch" in
			x86|i386) chk_name="slackware" ;;
			x86_64) chk_name="slackware64" ;;
			# ignore the rest!
		esac
	fi
	[ -z "$chk_vers" ] && chk_vers="current"
	local chk_full="$chk_name-$chk_vers"
	local chk_tree=`find_slacktree $chk_full $chk_path`
	[ ! -d "$chk_tree" ] && error_exit "Cannot find tree for '$chk_full'!\n\n"
	# check paths
	local pkg_path="$chk_tree/$chk_name"
	local pkg_list pkg_temp tmp_list pkg_name pkg_base
	[ ! -d "$pkg_path" ] && error_exit "Cannot find pkg path '$pkg_path'!\n\n"
	[ -d "${chk_root}" -a -f "${chk_root}/etc/slackware-version" ] &&
		error_exit "Found an installation in '$chk_root'!\n\n"
	[ "${chk_root:0:1}" != "/" ]  && chk_root=`pwd`"$chk_root"
	# provide info
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	info_msg "Pack option: '$pkg_opts'\n"
	# start main info msg
	info_msg "Creating root filesystem...\n"
	# if package list given, use it!
	if [ "$pkg_opts" == "FILE" ]; then
		[ ! -r $chk_file ] && error_exit "Cannot open file '$chk_file'!\n\n"
		ifs_save=$IFS
		IFS=$'\n'
		tmp_list=($(cat $chk_file))
		IFS=$ifs_save
		for (( x=0;x<${#tmp_list[@]};x++ )); do
			pkg_base=${tmp_list[$x]}
			pkg_name=${pkg_base#*!}
			pkg_base=$(find_package $pkg_name)
			pkg_temp=$(find $pkg_path -name "${pkg_base}.t[xg]z")
			pkg_list="${pkg_list}${pkg_temp} "
		done
	else
		# create package list based on pkg_opts
		pkg_list=$(do_pack_list $pkg_path $pkg_opts $chk_file)
	fi
	# install the packages
	do_root_install $chk_root $pkg_list $chk_exec
	# end main info msg
	info_msg "-- Done ($chk_full@$chk_root)\n"
}

rootfs_update()
{
	local chk_root pkg_opts chk_exec
	# check parameters
	while [ "$1" != "" ]; do
		case "$1" in
			--root) shift ; [ -d "$1" ] && chk_root="$(cd $1;pwd)" ;;
			--reinstall) pkg_opts="${pkg_opts}$1 " ;;
			--install-new) pkg_opts="${pkg_opts}$1 " ;;
			--execute|-x) chk_exec="--exec" ;;
			-*|*) error_exit "Unknown parameter '$1'!\n\n" ;;
		esac
		shift
	done
	[ ! -d "$chk_root" ] && error_exit "Cannot find root path '$chk_root'!\n\n"
	chk_root="$(cd $chk_root;pwd)"
	local chk_name=`find_slackname $chk_root`
	local chk_vers=`find_slackvers $chk_root`
	local chk_full="$chk_name-$chk_vers"
	local chk_tree=`find_slacktree $chk_full`
	[ ! -d "$chk_tree" ] && error_exit "Cannot find tree for '$chk_full'!\n\n"
	# check paths
	local pkg_path="$chk_tree/$chk_name"
	[ ! -d "$pkg_path" ] && error_exit "Cannot find pkg path '$pkg_path'!\n\n"
	# provide info
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	# start main info msg
	info_msg "Updating root filesystem...\n"
	# find patches
	local chk_list=`list_patches --root $chk_root | tr ';' ' '`
	local pkg_that chk_stat chk_temp pkg_list
	for pkg_that in $chk_list ; do
		chk_stat=`echo $pkg_that | cut -d':' -f2`
		chk_temp=`echo $pkg_that | cut -d':' -f3`
		[ "$chk_stat" == "check" ] && pkg_list="${pkg_list}${chk_temp} "
	done
	if [ "$pkg_list" == "" ] ; then
		info_msg "-- Nothing to update ($chk_full@$chk_root)\n"
		return
	fi
	# install the packages
	do_root_update $chk_root $pkg_list $pkg_opts $chk_exec
	# end main info msg
	info_msg "-- Done ($chk_full@$chk_root)\n"
}

process_command()
{
	local task=$1 ; shift
	[ -z "$task" ] && echo -e "$TOOL_HELP\n" && exit 0
	case $task in
		create) rootfs_create "$@" ;;
		update) rootfs_update "$@" ;;
		*) echo -e "Unknown command '$task'\n" && exit 1 ;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_NAME - $TOOL_DESC ($TOOL_VERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
