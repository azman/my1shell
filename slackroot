#!/bin/bash

# slackroot
# - written by azman@my1matrix.net
# - slackware 32-bit chroot (through ssh) installation
# - general rootfs (opt: module) builder

# standard tool info
MY1_TOOLNAME="my1 Slackware chroot32 Tool"
MY1_TOOLVERS="2012.03.00"
MY1_TOOLBASE=$(basename $0 .sh)
MY1_TOOLPATH=$(cd $(dirname $0);pwd)
MY1_TOOL_LIB="libmy1slack"
# look for config file
for config in $(pwd) $HOME; do
	config=$config/.$MY1_TOOLBASE
	[[ -r $config ]] && source $config && break
done
# look for my1slack library
SLACKARCH=${SLACKARCH:="x86"} # force 32-bit slackware!
[[ -r "$MY1_TOOLPATH/$MY1_TOOL_LIB" ]] && source $MY1_TOOLPATH/$MY1_TOOL_LIB

# my1slack tool specific
MY1_TOOL_LOG=${MY1_TOOL_LOG:="/tmp/${MY1_TOOLBASE}.log"}
MY1_ROOT_DEF=${MY1_ROOT_DEF:="/opt/chroot32"}
MY1_LIVE_DEF=${MY1_LIVE_DEF:="$(pwd)/live"}
MY1_USER_DEF=${MY1_USER_DEF:="user"}
MY1_PACK_DEF=${MY1_PACK_DEF:="00-core"}
# global options & settings
MSG_THISHELP=$(cat <<SETHELPMSG
Usage:
  $MY1_TOOLBASE <command> [options]
Commands:
  create : Create a custom root installation
  config : Configure for chroot32 installation
  chroot : Do create & config in one command
  squash : Squash root installation
  livefs : Do create & squash in one command
  update : Updates chroot installation
Options:
  --verbose : More info
  --exec    : Execute (else just dry run!)
  --root <path> : Specify root path (default: $MY1_ROOT_DEF)
Options (create):
  --path <path> : Specify path for packages
  --file <file> : Specify file containing package list
  --core    : Select basic system tool packages
  --console : Select console application packages
  --desktop : Select desktop application packages
Options (squash):
  --live <path> : Specify live path (default: $MY1_LIVE_DEF)
  --user <user> : Specify user name (default: $MY1_USER_DEF)
  --pack <name> : Specify pack name (default: $MY1_PACK_DEF)
  --custom  : Customize root installation
Log File:
  $MY1_TOOL_LOG
SETHELPMSG
)

function do_root_update()
{
	local chk_root=$1
	local chk_exec="NO"
	local chk_syyy="YES"
	local pkg_list pkg_temp pkg_opts="--reinstall --install-new"
	# check 'command-line'
	shift # first param is chk_root
	while [[ "$1" != "" ]]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			--verbose) chk_syyy="NO" ;;
			*)
				if [[ ! -f $pkg_temp ]] ; then
					warn_msg "File '$pkg_temp' not found! Not included!\n"
				else
					pkg_list="${pkg_list}$pkg_temp "
				fi
				;;
		esac
		shift
	done
	# check valid root path... if executing!
	[[ "$chk_exec" == "YES" ]] &&
		must_have_path "$chk_root" "Root path '$chk_root' not found!"
	# install packages in list to given root
	if [[ "$chk_exec" == "YES" ]]; then
		echo "$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)" >$MY1_TOOL_LOG
		echo "ExecTime: $(date +%Y%m%d%H%M)" >>$MY1_TOOL_LOG
	fi
	for pkg_file in $pkg_list; do
		[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag "\n"
		[[ "$chk_syyy" != "YES" ]] &&
			info_msg "Updating $(basename $pkg_file) to $chk_root ..."
		[[ "$chk_exec" == "YES" ]] &&
			ROOT=$chk_root upgradepkg $pkg_opts $pkg_file >>$MY1_TOOL_LOG
		[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag " done!"
	done
	[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag "\n"
}

function do_root_install()
{
	local chk_root=$1
	local chk_exec="NO"
	local chk_syyy="YES"
	local pkg_list pkg_temp
	# check 'command-line'
	shift # first param is chk_root
	while [[ "$1" != "" ]]; do
		pkg_temp=$1
		case $pkg_temp in
			--exec) chk_exec="YES" ;;
			--verbose) chk_syyy="NO" ;;
			*)
				if [[ ! -f $pkg_temp ]] ; then
					warn_msg "File '$pkg_temp' not found! Not included!\n"
				else
					pkg_list="${pkg_list}$pkg_temp "
				fi
				;;
		esac
		shift
	done
	# check valid root path... if executing!
	[[ "$chk_exec" == "YES" ]] &&
		must_have_path "$chk_root" "Root path '$chk_root' not found!"
	# install packages in list to given root
	if [[ "$chk_exec" == "YES" ]]; then
		echo "$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)" >$MY1_TOOL_LOG
		echo "ExecTime: $(date +%Y%m%d%H%M)" >>$MY1_TOOL_LOG
	fi
	for pkg_file in $pkg_list; do
		[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag "\n"
		[[ "$chk_syyy" != "YES" ]] &&
			info_msg "Installing $(basename $pkg_file) to $chk_root ..."
		[[ "$chk_exec" == "YES" ]] &&
			installpkg --root $chk_root $pkg_file >>$MY1_TOOL_LOG
		[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag " done!"
	done
	[[ "$chk_syyy" != "YES" ]] && info_msg --no-tag "\n"
}

function do_pack_list()
{
	local pkg_core="a d k l n"
	local pkg_apps="ap t tcl"
	local pkg_xgui="x xap"
	local pkg_path=$1
	local pkg_opts=$2
	local pkg_list pkg_file
	# check package option
	case "$pkg_opts" in
		CORE) pkg_opts="$pkg_core" ;;
		CONS) pkg_opts="$pkg_core $pkg_apps" ;;
		DESK) pkg_opts="$pkg_core $pkg_apps $pkg_xgui" ;;
		*) error_exit "Unknown package option!" ;;
	esac
	# check valid pkg path
	must_have_path "$pkg_path" "Package(s) path '$pkg_path' not found!"
	# select packages
	for pkg_soft in $pkg_opts; do
		cd $pkg_path
		if [[ -d $pkg_soft ]] ; then
			cd $pkg_soft
			for pkg_name in $(find . -name "*.t[xg]z"|uniq|sort); do
				pkg_file=${pkg_path}/${pkg_soft}/${pkg_name//.\//}
				pkg_list="${pkg_list}${pkg_file} "
			done
		fi
	done
	echo -n "$pkg_list"
}

function rootfs_create()
{
	local pkg_path="$SLACKPKGPATH"
	local pkg_opts="CORE" # default package set
	local chk_root="$MY1_ROOT_DEF"
	local chk_file=""
	local chk_exec=""
	local chk_syyy=""
	local pkg_list pkg_temp tmp_list pkg_name pkg_base
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--path)
				shift
				pkg_path="$(cd $1;pwd)"
				;;
			--root)
				shift
				chk_root=$1
				;;
			--file)
				shift
				chk_file=$1
				pkg_opts="FILE"
				;;
			--core)
				pkg_opts="CORE"
				;;
			--console)
				pkg_opts="CONS"
				;;
			--desktop)
				pkg_opts="DESK"
				;;
			--verbose)
				chk_syyy="--verbose"
				;;
			--exec)
				chk_exec="--exec"
				;;
			# ignore the rest!
		esac
		shift
	done
	# must be root to exec!
	[[ "$chk_exec" == "--exec" ]] && must_be_root
	# check in case we're only simulating target root (need not exist!)
	if [[ "$chk_exec" != "--exec" ]] ; then
		if [[ "${chk_root:0:1}" != "/" ]] ; then
			[[ "${chk_root:0:2}" == "./" ]] && chk_root=${chk_root:2}
			chk_root="$(pwd)/${chk_root}"
		fi
	fi
	# check paths
	[[ ! -d "$pkg_path" ]] && error_exit "Cannot find pkg path '$pkg_path'!"
	[[ -d "$chk_root" ]] && error_exit "Existing root path '$chk_root'!"
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	info_msg "Pack option: '$pkg_opts'\n"
	# start main info msg
	info_msg "Creating root filesystem... "
	# if executing, check/create root path
	if [[ "$chk_exec" == "--exec" ]] ; then
		mkdir -p $chk_root
		chk_root=$(cd $chk_root;pwd)
		[[ "$chk_syyy" == "--verbose" ]] &&
			info_msg "(Target path: '$chk_root') "
	fi
	# if package list given, use it!
	if [[ "$pkg_opts" == "FILE" ]]; then
		[[ ! -r $chk_file ]] &&
			error_msg "Cannot open package file '$chk_file'!\n" && return
		ifs_save=$IFS
		IFS=$'\n'
		tmp_list=($(cat $chk_file))
		IFS=$ifs_save
		for (( x=0;x<${#tmp_list[@]};x++ )); do
			pkg_base=${tmp_list[$x]}
			pkg_name=${pkg_base#*!}
			pkg_base=$(find_package $pkg_name)
			pkg_temp=$(find $pkg_path -name "${pkg_base}.t[xg]z")
			pkg_list="${pkg_list}${pkg_temp} "
		done
	else
		# create package list based on pkg_opts
		pkg_list=$(do_pack_list $pkg_path $pkg_opts $chk_file)
	fi
	# install the packages
	do_root_install $chk_root $pkg_list $chk_syyy $chk_exec
	# end main info msg
	info_msg --no-tag "done.\n"
}

function chroot_config()
{
	local chk_root="$MY1_ROOT_DEF"
	local chk_exec="NO"
	local chk_syyy="YES"
	local chk_file
	# check parameters (just look for root and exec)_
	while [[ "$1" != "" ]]; do
		case "$1" in
			--root)
				shift
				chk_root=$1
				# ensure full pathname
				if [[ "${chk_root:0:1}" != "/" ]] ; then
					[[ "${chk_root:0:2}" == "./" ]] && chk_root=${chk_root:2}
					chk_root="$(pwd)/${chk_root}"
				fi
				;;
			--verbose|-v)
				chk_syyy="NO"
				;;
			--exec)
				chk_exec="YES"
				;;
			# ignore the rest!
		esac
		shift
	done
	# create entries for fstab and sshd (also rc.local_shutdown command)
local FSTAB_ENTRY=$(cat <<FSTAB_LINES
# for chroot
proc            $chk_root/proc     proc    defaults        0 0
sysfs           $chk_root/sys      sysfs   defaults        0 0
/home           $chk_root/home     none    bind            0 0
/tmp            $chk_root/tmp      none    bind            0 0
/etc            $chk_root/etc      none    bind            0 0
/dev            $chk_root/dev      none    rbind           0 0
FSTAB_LINES
)
local SSHD_ENTRY=$(cat <<SSHD_LINES
# local ssh means chroot?
Match Address 127.0.0.1
	ChrootDirectory $chk_root
	X11Forwarding yes
SSHD_LINES
)
local SHUTDOWN_ENTRY=$(cat <<SHUTDOWN_LINES
# unbind $chk_root/dev 'recursively'
chkpath=$chk_root/dev
[[ "\$(cat /proc/mounts|grep \$chkpath)" != "" ]] &&
	umount \$(cat /proc/mounts|awk '{print \$2}'|grep "^$chk_root/dev"|sort -r)
# unmount chroot mounts manually
for a in etc tmp home sys proc; do
	chkpath=$chk_root/\$a
	[[ "\$(cat /proc/mounts|grep \$chkpath)" != "" ]] && umount \$chkpath
done
SHUTDOWN_LINES
)
	# start main info msg
	info_msg "Configuring chroot environment..."
	# must be root to exec!
	[[ "$chk_exec" == "YES" ]] && must_be_root
	# check valid root path - only if executing
	[[ "$chk_exec" == "YES" ]] &&
		must_have_path "$chk_root" "Root path '$chk_root' not found!"
	local do_echo="no"
	# check fstab
	if [[ "$(cat /etc/fstab | grep $chk_root)" == "" ]]; then
		if [[ "$chk_syyy" == "NO" ]] ; then
			check_msg --no-tag "\n"
			check_msg "Adding text to /etc/fstab:"
			echo -ne "\n$FSTAB_ENTRY"
			do_echo="yes"
		fi
		[[ "$chk_exec" == "YES" ]] &&
			echo -e "\n$FSTAB_ENTRY" >> /etc/fstab
	fi
	# check sshd_config
	if [[ "$(cat /etc/ssh/sshd_config | grep $chk_root)" == "" ]]; then
		if [[ "$chk_syyy" == "NO" ]] ; then
			check_msg --no-tag "\n"
			check_msg "Adding text to /etc/ssh/sshd_config:"
			echo -ne "\n$SSHD_ENTRY"
			do_echo="yes"
		fi
		[[ "$chk_exec" == "YES" ]] &&
			echo -e "\n$SSHD_ENTRY" >> /etc/ssh/sshd_config
	fi
	# check shutdown
	chk_file="/etc/rc.d/rc.local_shutdown"
	[[ "$chk_exec" == "YES" ]] && [[ ! -f "$chk_file" ]] && touch $chk_file
	local chk_out=""
	[[ -r "$chk_file" ]] && chk_out="$(cat $chk_file | grep $chk_root/dev)"
	if [[ ! -f "$chk_file" ]] || [[ "$chk_out" == "" ]]; then
		if [[ "$chk_syyy" == "NO" ]] ; then
			check_msg --no-tag "\n"
			check_msg "Adding text to $chk_file:"
			echo -ne "\n$SHUTDOWN_ENTRY"
			do_echo="yes"
		fi
		[[ "$chk_exec" == "YES" ]] &&
			echo -e "\n$SHUTDOWN_ENTRY" >> $chk_file
	fi
	[[ "$do_echo" == "yes" ]] && check_msg --no-tag "\n"
	# end main info msg
	info_msg --no-tag "done.\n"
}

function rootfs_custom()
{
	local chk_root=$1
	local chk_user=$2
	local chk_exec chk_syyy
	# start main info msg
	info_msg "Preparing root account and a user ('$chk_user')..."
	# check 'command-line' for verbose option!
	[[ "$(echo $@ | grep -e '--exec')" != "" ]] && chk_exec="--exec"
	[[ "$(echo $@ | grep -e '--verbose')" != "" ]] && chk_syyy="--verbose"
	# change root password
	[[ "$chk_syyy" == "--verbose" ]] && echo
	[[ "$chk_syyy" == "--verbose" ]] && info_msg "Changing root password...\n"
	[[ "$chk_exec" == "--exec" ]] && chroot $chk_root passwd
	# add a user
	[[ "$chk_syyy" == "--verbose" ]] && info_msg "Adding user '$chk_user'...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root useradd -m -g users -s /bin/bash $chk_user
	# Assign user to useful group(s)...
	[[ "$chk_syyy" == "--verbose" ]] &&
		info_msg "Adding user to groups power,plugdev,netdev...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root usermod -a -G power,plugdev,netdev $chk_user
	[[ "$chk_syyy" == "--verbose" ]] &&
		info_msg "Adding user to groups cdrom,floppy...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root usermod -a -G cdrom,floppy $chk_user
	[[ "$chk_syyy" == "--verbose" ]] &&
		info_msg "Adding user to groups audio,video...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root usermod -a -G audio,video $chk_user
	[[ "$chk_syyy" == "--verbose" ]] &&
		info_msg "Adding user to groups scanner,lp,dialout...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root usermod -a -G scanner,lp,dialout $chk_user
	# change user password
	[[ "$chk_syyy" == "--verbose" ]] && info_msg "Changing user password...\n"
	[[ "$chk_exec" == "--exec" ]] &&
		chroot $chk_root passwd $chk_user
	# end main info msg
	info_msg --no-tag "done!\n"
}

# copy_exec unionfs $path_init/bin $path_root

function copy_exec() # for reference
{
	local src_exec=$1
	local tgt_path=$2
	local chk_root=$3 # chroot option!
	local chk_libs ifs_save this_lib chk_path chk_exec opt_root
	[[ -d "$chk_root" ]] && chk_root=$(cd $chk_root;pwd) || chk_root=""
	[[ "$chk_root" != "" ]] && [[ ! -d "$chk_root/proc" ]] &&
		echo -e "'$chk_root' may not be a chroot target?\n" && exit 1
	[[ "$chk_root" != "" ]] && opt_root="chroot $chk_root"
	[[ "$chk_root" != "" ]] && mount --bind /proc $chk_root/proc
	# find full path
	src_exec=$($opt_root which $src_exec 2>/dev/null)
	[[ $? -ne 0 ]] && echo -e "'$1' NOT found! Aborting!\n" && exit 1
	chk_exec=${chk_root}${src_exec}
	[[ ! -e "$chk_exec" ]] &&
		echo -e "'$chk_exec' NOT a valid executable! Aborting!\n" && exit 1
	# check target path
	tgt_path=$(cd $tgt_path;pwd)
	[[ ! -d $tgt_path ]] &&
		echo -e "'$2' NOT a valid path?! Aborting!\n" && exit 1
	# copy exec AND dependencies!
	cp $chk_exec $tgt_path
	ifs_save=$IFS
	IFS=$'\n'
	chk_libs=($($opt_root ldd $src_exec 2>/dev/null))
	IFS=$ifs_save
	for (( x=0;x<${#chk_libs[@]};x++ )); do
		this_lib=${chk_libs[$x]%% (0x*}
		this_lib=${this_lib##*=> }
		[[ "$this_lib" == "" ]] && continue # linux-vdso.so.1!!
		this_lib=${chk_root}$this_lib
		[[ ! -f $this_lib ]] && error_exit "Cannot find lib '$this_lib'?"
		cp $this_lib $tgt_path
	done
	[[ "$chk_root" != "" ]] && umount $chk_root/proc
}

# copy_file busybox $path_init/bin

function copy_file() # for reference
{
	local src_file=$1
	local tgt_path=$2
	# check source file full name
	src_file=$(cd $(dirname $src_file);pwd)/$(basename $src_file)
	[[ ! -e "$src_file" ]] && error_exit "Cannot find '$src_file'!"
	# check target path
	tgt_path=$(cd $tgt_path;pwd)
	must_have_path "$tgt_path" "'$tgt_path' NOT a valid path?!"
	# copy file
	cp $src_file $tgt_path
}

function mkpack_init() # for reference
{
	local path_init=$1
	local path_live=$2
	local path_curr=$(pwd)
	cd $path_init
	rm -f $path_live/boot/initrd.gz
	mkdir -p $path_live/boot
	find . | cpio -o -H newc 2>/dev/null | gzip -9c > $path_live/boot/initrd.gz
	cd $path_curr
}

function unpack_init() # for reference
{
	local file_init=$1
	local path_init=$2
	local path_curr=$(pwd)
	mkdir -p $path_init
	cd $path_init
	zcat $file_init | cpio -i -d -H newc --no-absolute-filenames
	cd $path_curr
}

function get_userngrp()
{
	local chk_this=$1
	local chk_path
	local chk_user chk_grpn
	[[ "$chk_this" == "." ]] && chk_this=$(pwd)
	[[ "$chk_this" == ".." ]] && chk_this=$(cd .. ;pwd)
	[[ ! -r "$chk_this" ]] && echo -e "Cannot read '$chk_this'!" 1>&2 && return
	chk_path=$(cd $(dirname $chk_this);pwd)
	chk_this=$(basename $chk_this)
	chk_user=$(ls -l "${chk_path}/" | grep -e "${chk_this}$")
	set -- $chk_user
	chk_user=$3
	chk_grpn=$4
	echo -n "$chk_user:$chk_grpn"
}

function build_module()
{
	local mod_label=$1
	local path_root=""
	local path_live=""
	local chk_exec="NO"
	local chk_syyy="YES"
	local opt_compress="-comp gzip" # or, "-comp xz -b 1M"
	local mods_path="mods" # $path_live/optional
	local mods_file=${mod_label}.sfs
	local MKSQUASHFS_BIN="mksquashfs"
	# start main info msg
	info_msg "Creating module '$mods_file'..."
	# check 'command-line'
	shift # first param is mod_label
	while [[ "$1" != "" ]]; do
		pkg_temp=$1
		case $pkg_temp in
			--live)
				shift
				path_live=$1
				;;
			--root)
				shift
				path_root=$1
				;;
			--exec) chk_exec="YES" ;;
			--verbose) chk_syyy="NO" ;;
			# ignore the rest!
		esac
		shift
	done
	# if executing, do a sanity check
	mods_path=${path_live}/${mods_path}
	if [[ "$chk_exec" == "YES" ]] ; then
		# exit if cannot find binary!
		find_binary $MKSQUASHFS_BIN >/dev/null &&
		MKSQUASHFS_BIN=$(find_binary $MKSQUASHFS_BIN)
		# prepare paths
		mkdir -p $mods_path
		rm -f ${mods_path}/${mods_file}
		# exit if cannot find root path
		[[ ! -d "$path_root" ]] && error_exit "Root '$path_root' NOT found!"
	else
		[[ "$(which $MKSQUASHFS_BIN 2>/dev/null)" == "" ]] &&
			warn_msg "Cannot find $MKSQUASHFS_BIN! "
	fi
	# process!
	[[ "$chk_syyy" == "NO" ]] && echo && info_msg "Module path: '$mods_path'\n"
	[[ "$chk_syyy" == "NO" ]] && info_msg "Preparing module '$mods_file'..."
	if [[ "$chk_exec" == "YES" ]] ; then
		$MKSQUASHFS_BIN $path_root $mods_path/$mods_file \
			$opt_compress -e tmp dev proc sys $mods_path >/dev/null 2>&1
		local chk_perm=$(get_userngrp $path_live)
		[[ "$chk_perm" != "" ]] && chown $chk_perm -R $path_live
	fi
	[[ "$chk_syyy" == "NO" ]] && info_msg --no-tag " done! ($?)\n"
	# end main info msg
	info_msg --no-tag "done!\n"
}

function squash_create()
{
	local chk_root="$MY1_ROOT_DEF"
	local chk_live="$MY1_LIVE_DEF"
	local chk_user="user"
	local chk_pack="$MY1_PACK_DEF"
	local chk_exec=""
	local chk_syyy=""
	local chk_init=""
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--root)
				shift
				chk_root=$1
				# ensure full pathname
				if [[ "${chk_root:0:1}" != "/" ]] ; then
					[[ "${chk_root:0:2}" == "./" ]] && chk_root=${chk_root:2}
					chk_root="$(pwd)/${chk_root}"
				fi
				;;
			--live)
				shift
				chk_live=$1
				# ensure full pathname
				if [[ "${chk_live:0:1}" != "/" ]] ; then
					[[ "${chk_live:0:2}" == "./" ]] && chk_live=${chk_live:2}
					chk_live="$(pwd)/${chk_live}"
				fi
				;;
			--pack)
				shift
				chk_pack=$1
				;;
			--user)
				shift
				chk_user=$1
				;;
			--custom)
				chk_init="YES"
				;;
			--verbose)
				chk_syyy=$1
				;;
			--exec)
				chk_exec=$1
				;;
			# ignore the rest!
		esac
		shift
	done
	# show settings
	info_msg "Root path: '$chk_root'\n"
	info_msg "Live path: '$chk_live'\n"
	# do your thing!
	if [[ "$chk_init" == "YES" ]] ; then
		info_msg "User: $chk_user\n"
		rootfs_custom $chk_root $chk_user $chk_exec $chk_syyy
	fi
	build_module $chk_pack --root $chk_root --live $chk_live $chk_exec $chk_syyy
}

function find_patches_root()
{
	local pat_exts pat_base pat_name
	local pat_vers pat_arch pat_extd
	local pkg_temp pkg_base pkg_name
	local pkg_vers pkg_arch pkg_extd
	local chk_name chk_stat chk_file chk_vers
	local pkg_path="$1"
	local log_path="$2"
	local pat_list pat_full pat_path
	# look for all package files
	for pat_full in $(find $pkg_path -name "*.t[gx]z" -type f); do
		pat_file="$(basename $pat_full)"
		pat_path="$(dirname $pat_full)"
		# check extension first
		pat_exts="${pat_file##*.}"
		pat_base="${pat_file%%.${pat_exts}}"
		# get particulars
		pkg_temp=($(get_pkg_info $pat_base))
		pat_name="${pkg_temp[0]}"
		pat_vers="${pkg_temp[1]}"
		pat_arch="${pkg_temp[2]}"
		pat_extd="${pkg_temp[3]}"
		# populate information
		chk_name="$pat_name"
		chk_file="$pat_full"
		chk_vers="[${pat_vers}/${pat_extd}]"
		# DEBUG debug_msg "$pat_full\n"
		# find installed
		pkg_temp="^${pat_name}-[^-]*-[^-]*-[^-]*$"
		pkg_base=$(ls $log_path | grep -e "$pkg_temp")
		[[ "$pkg_base" == "" ]] && continue
		pkg_temp=($(get_pkg_info $pkg_base))
		pkg_name="${pkg_temp[0]}"
		pkg_vers="${pkg_temp[1]}"
		pkg_arch="${pkg_temp[2]}"
		pkg_extd="${pkg_temp[3]}"
		# skip if for different arch!
		[[ "$pkg_arch" != "$pat_arch" ]] && continue
		# check version update
		if [[ "$pkg_vers" == "$pat_vers" ]] &&
			[[ "$pkg_extd" == "$pat_extd" ]]; then
			chk_stat="pdone"
		else
			chk_stat="check"
			chk_vers="[${pkg_vers}/${pkg_extd}]->[${pat_vers}/${pat_extd}]"
		fi
		echo "$chk_name $chk_stat $chk_file $chk_vers "
	done
}

function rootfs_update()
{
	local pkg_path="$SLACKPKGPATH"
	local chk_root="$MY1_ROOT_DEF"
	local chk_exec=""
	local chk_syyy=""
	local pkg_list pkg_temp pkg_name pkg_base tmp_list chk_temp
	# check parameters
	while [[ "$1" != "" ]]; do
		case "$1" in
			--path)
				shift
				pkg_path="$(cd $1;pwd)"
				;;
			--root)
				shift
				chk_root=$1
				;;
			--verbose)
				chk_syyy="--verbose"
				;;
			--exec)
				chk_exec="--exec"
				;;
			# ignore the rest!
		esac
		shift
	done
	# must be root to exec!
	[[ "$chk_exec" == "--exec" ]] && must_be_root
	# ensure full path for chk_root
	if [[ "${chk_root:0:1}" != "/" ]] ; then
		[[ "${chk_root:0:2}" == "./" ]] && chk_root=${chk_root:2}
		chk_root="$(pwd)/${chk_root}"
	fi
	pkg_path="$(cd ${pkg_path}/../patches;pwd)"
	# check paths
	[[ ! -d "$pkg_path" ]] && error_exit "Cannot find pkg path '$pkg_path'!"
	[[ ! -d "$chk_root" ]] && error_exit "Cannot find root path '$chk_root'!"
	info_msg "Source path: '$pkg_path'\n"
	info_msg "Target path: '$chk_root'\n"
	# start main info msg
	info_msg "Updating root filesystem... "
	# find patches
	pkg_list=$(find_patches_root $pkg_path ${chk_root}/var/log/packages)
	local ifs_save=$IFS
	IFS=$'\n'
	tmp_list=($(echo "$pkg_list"))
	IFS=$ifs_save
	#echo "Patch Count: ${#tmp_list[@]}"
	pkg_list=""
	# extract packages list
	for (( a=0;a<${#tmp_list[@]};a++ )); do
		chk_temp=($(echo ${tmp_list[$a]}))
		[ "${chk_temp[1]}" == "check" ] && pkg_list="${pkg_list}${chk_temp[2]} "
	done
	[ "$pkg_list" == "" ] &&
		info_msg --no-tag "Nothing to update.\n" && return
	# install the packages
	do_root_update $chk_root $pkg_list $chk_syyy $chk_exec
	# end main info msg
	info_msg --no-tag "done.\n"
}

function process_command()
{
	local go_commands="create config chroot squash livefs update"
	local chk_command=$1
	local do_command
	shift
	# check command
	for tcommand in $go_commands; do
		[[ "$chk_command" == "$tcommand" ]] && do_command=$chk_command && break
	done
	[[ "$do_command" == "" ]] && echo -e "$MSG_THISHELP\n" && exit 0
	# execute command
	case $do_command in
		create) rootfs_create $@ ;;
		config) chroot_config $@ ;;
		chroot) rootfs_create $@ ; chroot_config $@  ;;
		squash) squash_create $@ ;;
		livefs) rootfs_create $@ ; squash_create $@  ;;
		update) rootfs_update $@ ;;
	esac
}

# BEGIN MAIN SCRIPT

echo -e "\n$MY1_TOOLBASE - $MY1_TOOLNAME ($MY1_TOOLVERS)\n"
process_command "$@"
echo ; exit 0

# END MAIN SCRIPT
