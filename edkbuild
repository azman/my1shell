#!/bin/bash

# edkbuild
# - written by azman@my1matrix.org
# - Xilinx EDK command-line project builder
# - tested on ISE Design Suite 10.1

# check xilinx environment settings
if [ -z "$XILINX_EDK" ] || [ -z "$XILINX" ]; then
	echo "XILINX environment NOT SET! " \
		"Run 'settings<32|64>.sh' script from Xilinx installation."
	exit 1
fi

# standard tool info
TOOL_THISFUNC="MY1 EDK Build Tool"
TOOL_THISVERS="2012.12.00"
# standard tool conf
TOOL_CHECKCMD="$@"
TOOL_COMMANDS=${TOOL_CHECKCMD:=""}
TOOL_THISFILE=$(basename $0 .sh)
TOOL_LOCATION=$(cd $(dirname $0);pwd)
TOOL_CONFFILE="$TOOL_THISFILE.conf"
# look for config file
for conf_path in  $(pwd) $TOOL_LOCATION ; do
	config_file="${conf_path}/${TOOL_CONFFILE}"
	[ -r $config_file ] && source $config_file && break
done
# debug parameters
COMPARE_DEBUG=${COMPARE_DEBUG:="NO"}
SKIP_BITGEN=${SKIP_BITGEN:="NO"}

# HARD-WIRED PARAMETERS?
EDK_SYSTEM=${EDK_SYSTEM:="system"}
BITGEN_UT_FILE=${BITGEN_UT_FILE:="bitgen.ut"}
BD_BMM_FILE="${EDK_SYSTEM}_bd.bmm"
# xps path? maybe only needed IF i use xps? nope - *_routed IS used!
XPS_TEMPPATH=${XPS_TEMPPATH:="__xps"}
XPS_ROUTED=${XPS_ROUTED:="${XPS_TEMPPATH}/${EDK_SYSTEM}_routed"}
XPS_PLATGEN_OPT=${XPS_PLATGEN_OPT:="${XPS_TEMPPATH}/platgen.opt"}
XPS_XFLOW_OPT=${XPS_XFLOW_OPT:="${XPS_TEMPPATH}/xpsxflow.opt"}
# implementation path
IMP_TEMPPATH=${IMP_TEMPPATH:="implementation"} # apparently,a hard-wired path!
IMP_POSTSYN_NETLIST=${IMP_POSTSYN_NETLIST:="${IMP_TEMPPATH}/${EDK_SYSTEM}.ngc"}
IMP_BMM_FILE=${IMP_BMM_FILE:="${IMP_TEMPPATH}/${EDK_SYSTEM}.bmm"}
IMP_UCF_FILE=${IMP_UCF_FILE:="${IMP_TEMPPATH}/${EDK_SYSTEM}.ucf"}
IMP_BITGEN_UT_FILE=${IMP_BITGEN_UT_FILE:="${IMP_TEMPPATH}/${BITGEN_UT_FILE}"}
# etc path
ETC_TEMPPATH=${ETC_TEMPPATH:="etc"}
ETC_XFLOW_OPT=${ETC_XFLOW_OPT:="${ETC_TEMPPATH}/fast_runtime.opt"}
ETC_BITGEN_UT_FILE=${ETC_BITGEN_UT_FILE:="${ETC_TEMPPATH}/$BITGEN_UT_FILE"}
# output files
FPGA_BD_BMM_FILE="${IMP_TEMPPATH}/${BD_BMM_FILE}"
FPGA_BITFILE=${FPGA_BITFILE:="${IMP_TEMPPATH}/${EDK_SYSTEM}.bit"}
FPGA_DOWNLOAD_FILE=${FPGA_DOWNLOAD_FILE:="${IMP_TEMPPATH}/download.bit"}
FPGA_ACEFILE=${FPGA_ACEFILE:="${EDK_SYSTEM}-final.ace"}
# don't know if i need this!
XFLOW_DEPENDS=${XFLOW_DEPENDS:="${XPS_XFLOW_OPT} ${ETC_XFLOW_OPT}"}
FPGA_IMP_DEPENDS="$IMP_BMM_FILE $IMP_POSTSYN_NETLIST $EDK_UCFFILE "
FPGA_IMP_DEPENDS+="-option $XFLOW_DEPENDS"

# THESE ARE READ FROM PROJECT FILE!
# fpga device parameters
FPGA_ARCH=""
FPGA_TYPE=""
FPGA_SPEED_GRADE=""
FPGA_PACKAGE=""
FPGA_DEVICE=""
# EDK specific parameters
EDK_MHSFILE=""
EDK_MSSFILE=""
EDK_LOGFILE=""
EDK_HDLLANG=""
EDK_UCFFILE=""
# BUILD parameters
EDK_MOD_PATH=""
APP_PROCESSOR=""
APP_EXECUTABLE=""
APP_SOURCES=""
APP_HEADERS=""
APP_LIBPATH=""
APP_INCPATH=""
APP_LIBS=""
APP_LINKER_SCRIPT=""

# user break
trap trap_break INT
function trap_break()
{
	echo "User abort request! Aborting!"
	exit 1
}

# error message
function error_exit()
{
	[ -z "$1" ] || echo "$1"
	echo
	exit 1
}

# check dependency list
function check_deplist()
{
	[ -z "$1" ] && return 0

	local do_depends="YES" # default is the dependency list
	local do_options="NO"
	local tgt_files=""
	local dep_files=""
	local opt_files="" # files that can be ignored (NOT A RULE!)

	# parse the input lines
	while [ "$1" != "" ]; do
		case $1 in
			-target)
				do_depends="NO"
				do_options="NO"
				;;
			-depend)
				do_depends="YES"
				do_options="NO"
				;;
			-option)
				do_depends="YES"
				do_options="YES"
				;;
			*)
				if [ ! -f "$1" ]; then
					[ $do_depends == "YES" -a $do_options == "YES" ] &&
						shift && continue
					[ $COMPARE_DEBUG == "YES" ] && echo "File $1 NOT found!"
					return 1
				fi
				if [ "$do_depends" == "NO" ]; then
					tgt_files="$tgt_files $1"
				else
					dep_files="$dep_files $1"
				fi
				;;
		esac
		shift
	done

	# now we can actually check dependencies
	for tgt_file in $tgt_files; do
		for dep_file in $dep_files; do
			if [ "$dep_file" -nt "$tgt_file" ]; then
				[ $COMPARE_DEBUG == "YES" ] &&
					echo "File $dep_file newer than $tgt_file!"
				return 1
			fi
		done
		shift
	done

	return 0
}

# build system netlist
# - creates bmm file and wrapper ngc files in implementation folder
# - also generate post-synthesis system netlist
# - creates main ngc file
function build_sysnet()
{
	local USER_REPO_PATH=${USER_REPO_PATH:="$(pwd)"}
	local USER_IPCORE_PATH=${USER_IPCORE_PATH:="$USER_REPO_PATH/pcores"}
	local CORE_DEV_FILES=$(find $USER_IPCORE_PATH -name *.vhd*)
	local NGC_WRAPPERS=""

	# check coregen in user repo
	local xco_path xco_file xco_name xco_pnet xco_ngcf xco_genp
	for xco_full in $(find $USER_IPCORE_PATH -name *.xco); do
		xco_file=$(basename $xco_full)
		xco_path=$(dirname $xco_full)
		xco_name=$(basename $xco_full .xco)
		xco_pnet=$(dirname $xco_path)/netlist
		xco_ngcf=${xco_name}.ngc
		xco_genp=coregen.cgp
		[ ! -d "$xco_pnet" ] && continue
		[ -r "${xco_pnet}/${xco_ngcf}" ] && continue
		cd $xco_pnet
		[ ! -r "$xco_genp" ] &&
			echo "Cannot find project file '$xco_genp'!" && exit 1
		if [ ! -r "$xco_ngcf" ]; then
			echo -n "Building CoreGen netlist from '$xco_file'... "
			coregen -b $xco_full -p $xco_genp >> $EDK_LOGFILE
			[ ! -r "$xco_ngcf" ] &&
				echo "Cannot find file '$xco_ngcf'! CoreGen failed?" && exit 1
			echo "done!"
		fi
		cd - >/dev/null
	done

	if [ -d "$IMP_TEMPPATH" ]; then
		NGC_WRAPPERS=$(find $IMP_TEMPPATH -maxdepth 1 -name *_wrapper.ngc)
	fi

	if [ "$NGC_WRAPPERS" != "" ]; then
		check_deplist $EDK_MHSFILE $CORE_DEV_FILES \
			-option $XPS_PLATGEN_OPT -target $IMP_BMM_FILE \
			$NGC_WRAPPERS $IMP_POSTSYN_NETLIST
		[ $? -eq 0 ] &&
			echo "Nothing to do. " \
				"NGC wrappers, '$IMP_POSTSYN_NETLIST' and " \
				"'$IMP_BMM_FILE' are up-to-date!" && return
	fi

	local PLATGEN_OPTS="-p $FPGA_DEVICE -lp $EDK_MOD_PATH -lang $EDK_HDLLANG"
	local header_msg="Creating system netlist for hardware specification..."
	local banner_char="*"

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	platgen $PLATGEN_OPTS $EDK_MHSFILE >> $EDK_LOGFILE
	local flag=$?
	[ $flag -ne 0 ] &&
		echo -e "[$TOOL_THISFILE] platgen error? [$flag] Aborting!\n" && exit 1

	local curr_dir="$(pwd)"
	local header_msg="Running synthesis (post-sysnthesis system netlist!)..."
	local banner_char="*"

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	cd synthesis
	./synthesis.sh >> $EDK_LOGFILE
	cd $curr_dir
}

# build route system?
# - executes xflow with ${IMP_TEMPPATH} as working dir
function build_routed()
{
	# make sure dependencies are latest
	build_sysnet

	check_deplist $FPGA_IMP_DEPENDS -target $XPS_ROUTED
	[ $? -eq 0 ] && echo "Nothing to do. '$XPS_ROUTED' is up-to-date!" && return

	local MANAGE_FASTRT_OPTIONS="-reduce_fanout no"
	local header_msg="Running Xilinx Implementation tools..."
	local banner_char="*"
	local check_result

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	cp -f $EDK_UCFFILE $IMP_UCF_FILE
	xilperl ${XILINX_EDK}/data/fpga_impl/manage_fastruntime_opt.pl \
		${MANAGE_FASTRT_OPTIONS} >> $EDK_LOGFILE
	xflow -wd ${IMP_TEMPPATH} -p ${FPGA_DEVICE} -implement xflow.opt \
		${EDK_SYSTEM}.ngc  >> $EDK_LOGFILE # xflow.opt created by perl script above?
	local flag=$?
	[ $flag -ne 0 ] &&
		echo -e "[$TOOL_THISFILE] xflow error? [$flag] Aborting!\n" && exit 1
	touch $XPS_ROUTED
}

# build bitstream
# - create system bitstream
function build_bit()
{
	[ "$SKIP_BITGEN" == "YES" ] && return

	# make sure dependencies are latest
	build_routed

	check_deplist $XPS_ROUTED $ETC_BITGEN_UT_FILE -target $FPGA_BITFILE
	[ $? -eq 0 ] &&
		echo "Nothing to do. '$FPGA_BITFILE' is up-to-date!" && return

	local OBSERVE_PAR_OPTIONS="-error no"
	local header_msg="Running Bitgen..."
	local banner_char="*"
	local check_result
	local curr_dir=$(pwd)

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	xilperl ${XILINX_EDK}/data/fpga_impl/observe_par.pl \
		${OBSERVE_PAR_OPTIONS} ${IMP_TEMPPATH}/${EDK_SYSTEM}.par >> $EDK_LOGFILE
	cp -f $ETC_BITGEN_UT_FILE $IMP_BITGEN_UT_FILE
	cd ${IMP_TEMPPATH}
	bitgen -w -f $BITGEN_UT_FILE ${EDK_SYSTEM} >> $EDK_LOGFILE
	local flag=$?
	[ $flag -ne 0 ] &&
		echo -e "[$TOOL_THISFILE] bitgen error? [$flag] Aborting!\n" && exit 1
	cd $curr_dir
}

# build software libraries
function build_lib()
{
	# check driver updates in user repo
	local USR_SOURCES=""
	for c_src in $(find $(pwd)/drivers -name *.c); do
		USR_SOURCES="$USR_SOURCES $c_src"
	done
	local USR_HEADERS=""
	for c_hdr in $(find $(pwd)/drivers -name *.h); do
		USR_HEADERS="$USR_HEADERS $c_hdr"
	done

	check_deplist ${EDK_MHSFILE} ${EDK_MSSFILE} ${APP_SOURCES} \
		${APP_HEADERS} ${USR_SOURCES} ${USR_HEADERS} -target $APP_LIBS
	[ $? -eq 0 ] && echo "Nothing to do. Libraries are up-to-date!" && return

	local LIBGEN_OPTS="-p $FPGA_DEVICE -lp $EDK_MOD_PATH -mhs $EDK_MHSFILE"
	local header_msg="Creating software libraries..."
	local banner_char="*"

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	libgen ${LIBGEN_OPTS} ${EDK_MSSFILE} >> $EDK_LOGFILE
	local flag=$?
	[ $flag -ne 0 ] &&
		echo -e "[$TOOL_THISFILE] libgen error? [$flag] Aborting!\n" && exit 1
}

# build soft application
# - create executable file!
function build_app()
{
	# make sure dependencies are latest
	build_lib

	# compilation parameters
	local APP_CC_SEARCH="" # -B
	local APP_CC="mb-gcc"
	local APP_CC_SIZE="mb-size"
	local APP_CC_OPT="-O2"
	local APP_CFLAGS=""
	local APP_LIBFLAG="-L${APP_LIBPATH}/" # -L
	local APP_INCFLAG="-I${APP_INCPATH}/ -I${APP_SOURCEPATH}/" # -I
	local APP_LFLAGS="" # -l
	# soft-compilation flags
	local APP_CC_GLOBPTR_FLAG="-DMY1_BUILD_HOST=\"$(hostname)\" " \
		"-DMY1_CURR_TIME=\"$(date +%Y%m%d%H%M%S)\"" # -mxl-gp-opt
	# read this from xmp file?
	local APP_CC_START_ADDR_FLAG="-Wl,-defsym -Wl,_TEXT_START_ADDR=0x10000000"
	local APP_CC_STACK_SIZE_FLAG="-Wl,-defsym -Wl,_STACK_SIZE=0x4000"
	local APP_CC_HEAP_SIZE_FLAG="-Wl,-defsym -Wl,_HEAP_SIZE=0x4000"
	local APP_CC_INFERRED_FLAGS="-mno-xl-soft-mul -mxl-barrel-shift " \
		"-mxl-pattern-compare -mcpu=v7.10.d"
	local APP_LINKER_SCRIPT_FLAG="" #-Wl,-T -Wl,${APP_LINKER_SCRIPT}
	[ "$APP_LINKER_SCRIPT" != "" ] &&
		APP_LINKER_SCRIPT_FLAG="-Wl,-T -Wl,${APP_LINKER_SCRIPT}"
	local APP_CC_DEBUG_FLAG="" # -g
	local APP_CC_PROFILE_FLAG="" # -pg
	local APP_OTHER_CC_FLAGS="${APP_CC_GLOBPTR_FLAG} " \
		"${APP_CC_START_ADDR_FLAG} ${APP_CC_STACK_SIZE_FLAG} " \
		"${APP_CC_HEAP_SIZE_FLAG} ${APP_CC_INFERRED_FLAGS} " \
		"${APP_LINKER_SCRIPT_FLAG} ${APP_CC_DEBUG_FLAG} ${APP_CC_PROFILE_FLAG}"

	check_deplist ${APP_SOURCES} ${APP_HEADERS} ${APP_LINKER_SCRIPT} \
		${APP_LIBS} -target $APP_EXECUTABLE
	[ $? -eq 0 ] &&
		echo "Nothing to do. '$APP_EXECUTABLE' is up-to-date!" && return

	local header_msg="Creating executable..."
	local banner_char="*"

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	${APP_CC} ${APP_CC_OPT} ${APP_SOURCES} -o ${APP_EXECUTABLE} \
		${APP_OTHER_CC_FLAGS} ${APP_INCFLAG} ${APP_LIBFLAG} \
		${APP_CFLAGS} ${APP_LFLAGS} >> $EDK_LOGFILE
	${APP_CC_SIZE} ${APP_EXECUTABLE} >> $EDK_LOGFILE
}

# build download bitstream
function build_download()
{
	# make sure dependencies are latest
	build_bit
	build_app

	check_deplist $FPGA_BD_BMM_FILE $FPGA_BITFILE \
		$APP_EXECUTABLE -target $FPGA_DOWNLOAD_FILE
	[ $? -eq 0 ] &&
		echo "Nothing to do. '$FPGA_DOWNLOAD_FILE' is up-to-date!" && return

	local header_msg="Initializing BRAM contents of the bitstream..."
	local banner_char="*"
	local check_result

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	cp -f $FPGA_BD_BMM_FILE .
	bitinit ${EDK_MHSFILE} -lp $EDK_MOD_PATH -pe $APP_PROCESSOR \
		$APP_EXECUTABLE -bt $FPGA_BITFILE -o $FPGA_DOWNLOAD_FILE >> $EDK_LOGFILE
	local flag=$?
	[ $flag -ne 0 ] &&
		echo -e "[$TOOL_THISFILE] bitinit error[$flag]? Aborting!\n" && exit 1
	rm -f ${BD_BMM_FILE}
}

# build ace file
# - create ace file
function build_ace()
{
	# make sure dependencies are latest
	build_download

	# genace option
	local VSK_GENACE_OPT="-jprog\n-board user\n-target mdm\n"
	VSK_GENACE_OPT+="-hw $FPGA_DOWNLOAD_FILE\n-elf $APP_EXECUTABLE\n"
	VSK_GENACE_OPT+="-configdevice devicenr 1 idcode 0x0384e093 "
	VSK_GENACE_OPT+="irlength 6 partname xc3sd3400a\n"
	VSK_GENACE_OPT+="-debugdevice devicenr 1 cpunr 0\n-ace $FPGA_ACEFILE\n"
	# options for genace.tcl
	local ACE_GENACE_OPT=${ACE_GENACE_OPT:="$VSK_GENACE_OPT"}
	local TEMP_GENACE_OPT=${TEMP_GENACE_OPT:="genace.opt"}

	check_deplist ${FPGA_DOWNLOAD_FILE} -target $FPGA_ACEFILE
	[ $? -eq 0 ] &&
		echo "Nothing to do. '$FPGA_ACEFILE' is up-to-date!" && return

	local header_msg="Creating SystemACE file..."
	local banner_char="*"
	local check_result

	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo "$header_msg"
	for (( a=0;a<${#header_msg};a++ )) ; do echo -n "$banner_char"; done ; echo
	echo -e "$ACE_GENACE_OPT" >$TEMP_GENACE_OPT
	rm -rf $FPGA_ACEFILE
	xmd -tcl genace.tcl -opt $TEMP_GENACE_OPT >> $EDK_LOGFILE
	[ ! -f "$FPGA_ACEFILE" ] &&
		echo -e "[$TOOL_THISFILE] xmd error? Aborting...\n" && exit 1
	rm $TEMP_GENACE_OPT
}

function get_deviceinfo()
{
	local xmp_file=$1
	local dev_arch_str="Architecture: "
	local dev_dev_str="Device: "
	local dev_pack_str="Package: "
	local dev_grade_str="SpeedGrade: -"

	# read xmp file
	FPGA_ARCH=$(cat $xmp_file | grep "$dev_arch_str")
	FPGA_TYPE=$(cat $xmp_file | grep "$dev_dev_str")
	FPGA_PACKAGE=$(cat $xmp_file | grep "$dev_pack_str")
	FPGA_SPEED_GRADE=$(cat $xmp_file | grep "$dev_grade_str")

	# check inconsistencies
	if [ "$FPGA_ARCH" == "" ] || [ "$FPGA_TYPE" == "" ] ||
			[ "$FPGA_PACKAGE" == "" ] || [ "$FPGA_SPEED_GRADE" == "" ]; then
		echo "Failed to get device info from $xmp_file!"
		echo "==> $FPGA_ARCH"
		echo "==> $FPGA_TYPE"
		echo "==> $FPGA_PACKAGE"
		echo "==> $FPGA_SPEED_GRADE"
		exit 1
	fi

	# final assignment
	FPGA_ARCH=${FPGA_ARCH#${dev_arch_str}}
	FPGA_TYPE=${FPGA_TYPE#${dev_dev_str}}
	FPGA_PACKAGE=${FPGA_PACKAGE#${dev_pack_str}}
	FPGA_SPEED_GRADE=${FPGA_SPEED_GRADE#${dev_grade_str}}
	FPGA_PKGNAME=${FPGA_PACKAGE}-${FPGA_SPEED_GRADE}
	FPGA_DEVICE=${FPGA_DEVICE:="${FPGA_TYPE}${FPGA_PKGNAME}"}
}

function get_systeminfo()
{
	local xmp_file=$1
	local mhs_file_str="MHS File: "
	local mss_file_str="MSS File: "
	local hdl_lang_str="HdlLang: "
	local ucf_file_str="UcfFile: "

	# read xmp file
	EDK_MHSFILE=$(cat $xmp_file | grep "$mhs_file_str")
	EDK_MHSFILE=${EDK_MHSFILE#${mhs_file_str}}
	EDK_MSSFILE=$(cat $xmp_file | grep "$mss_file_str")
	EDK_MSSFILE=${EDK_MSSFILE#${mss_file_str}}
	EDK_HDLLANG=$(cat $xmp_file | grep "$hdl_lang_str")
	EDK_UCFFILE=$(cat $xmp_file | grep "$ucf_file_str")
	EDK_UCFFILE=${EDK_UCFFILE#${ucf_file_str}}

	# check file existence AND consistency
	if [ ! -f "$EDK_MHSFILE" ] || [ ! -f "$EDK_MSSFILE" ] ||
			[ "$EDK_HDLLANG" == "" ] || [ ! -f "$EDK_UCFFILE" ]; then
		echo "Failed to get system info from $xmp_file!"
		echo "==> $mhs_file_str $EDK_MHSFILE"
		echo "==> $mss_file_str $EDK_MSSFILE"
		echo "==> $EDK_HDLLANG"
		echo "==> $ucf_file_str $EDK_UCFFILE"
		exit 1
	fi

	# final assignment
	EDK_HDLLANG=$(echo ${EDK_HDLLANG#${hdl_lang_str}} | tr '[A-Z]' '[a-z]')
}

function get_buildinfo()
{
	local xmp_file=$1
	local app_buffer
	local userip_path_str="ModuleSearchPath: "
	local app_prename_str="SwProj: "
	local proc_name_str="Processor: "
	local exec_name_str="Executable: "
	local source_name_str="Source: "
	local header_name_str="Header: "
	local linker_name_str="LinkerScript: "
	local tmp_sources tmp_headers tfile

	# read xmp file
	EDK_MOD_PATH=$(cat $xmp_file | grep "$userip_path_str")
	EDK_MOD_PATH=${EDK_MOD_PATH#${userip_path_str}}
	app_buffer=$(cat $xmp_file | grep -A2 "$app_prename_str")
	APP_PROCESSOR=$(echo "$app_buffer" | grep "$proc_name_str")
	APP_EXECUTABLE=$(echo "$app_buffer" | grep "$exec_name_str")
	APP_LINKER_SCRIPT=$(echo "$app_buffer" | grep "$linker_name_str")
	local ifs_save=$IFS
	IFS=$'\n'
	tmp_sources=($(cat $xmp_file | grep "$source_name_str"))
	tmp_headers=($(cat $xmp_file | grep "$header_name_str"))
	IFS=$ifs_save

	# check consistencies
	if [ ! -d "$EDK_MOD_PATH" ] || [ "$APP_PROCESSOR" == "" ] ||
			[ "$APP_EXECUTABLE" == "" ]; then
		echo "Failed to build info from $xmp_file!"
		echo "==> $userip_path_str $EDK_MOD_PATH"
		echo "==> $APP_PROCESSOR"
		echo "==> $$APP_EXECUTABLE"
		exit 1
	fi

	# check file existence
	APP_SOURCES=""
	for (( a=0;a<${#tmp_sources[@]};a++ )); do
		tfile=${tmp_sources[$a]}
		tfile=$(pwd)/${tfile#${source_name_str}}
		if [ ! -f "$tfile" ]; then
			echo "Failed to get source files info from $xmp_file!"
			echo "==> $tfile"
			exit 1
		fi
		APP_SOURCES="$APP_SOURCES $tfile"
	done

	# check file existence
	APP_HEADERS=""
	for (( a=0;a<${#tmp_headers[@]};a++ )); do
		tfile=${tmp_headers[$a]}
		tfile=$(pwd)/${tfile#${header_name_str}}
		if [ ! -f "$tfile" ]; then
			echo "Failed to get headers files info from $xmp_file!"
			echo "==> $tfile"
			exit 1
		fi
		APP_HEADERS="$APP_HEADERS $tfile"
	done

	# final assignment
	EDK_MOD_PATH=$(cd $EDK_MOD_PATH;pwd)
	APP_PROCESSOR=${APP_PROCESSOR#${proc_name_str}}
	APP_EXECUTABLE=${APP_EXECUTABLE#${exec_name_str}}
	APP_LIBPATH="$APP_PROCESSOR/lib"
	APP_INCPATH="$APP_PROCESSOR/include"
	APP_LIBS="$APP_LIBPATH/libxil.a"
	APP_LINKER_SCRIPT=${APP_LINKER_SCRIPT#${linker_name_str}}
}

function get_remote_app()
{
	local remote_app=$1
	local libdir=$(dirname $APP_LIBS)
	local appdir=$(dirname $APP_EXECUTABLE)

	# make sure library path exists
	[ -d "$libdir" ] || mkdir -pv $libdir >>$EDK_LOGFILE
	# get main library file
	scp $remote_app/$APP_LIBS $APP_LIBS >>$EDK_LOGFILE
	# make sure application path exists
	[ -d "$appdir" ] || mkdir -pv $appdir >>$EDK_LOGFILE
	# get main application file
	scp $remote_app/$APP_EXECUTABLE $APP_EXECUTABLE >>$EDK_LOGFILE
	# update time info?
	touch $APP_LIBS $APP_EXECUTABLE
}

function get_remote_bit()
{
	local remote_bit=$1
	local bitdir=$(dirname $FPGA_BITFILE)
	local bmmdir=$(dirname $FPGA_BD_BMM_FILE)

	# make sure bmmfile path exists
	[ -d "$bmmdir" ] || mkdir -pv $bmmdir >>$EDK_LOGFILE
	# get bmmfile
	scp $remote_bit/$FPGA_BD_BMM_FILE $FPGA_BD_BMM_FILE >>$EDK_LOGFILE
	# make sure bitfile path exists
	[ -d "$bitdir" ] || mkdir -pv $bitdir >>$EDK_LOGFILE
	# get bitfile
	scp $remote_bit/$FPGA_BITFILE $FPGA_BITFILE >>$EDK_LOGFILE
	# update time info?
	touch $FPGA_BD_BMM_FILE $FPGA_BITFILE
}

function process_command()
{
	local do_command=""
	local opt_conf_file=""
	local valid_builds="bit app dow ace dum"
	local curr_dir=$(pwd)
	local work_dir="$curr_dir"
	local xmp_file="system.xmp"
	local do_clear=""
	local remote_app=""
	local remote_bit=""

	while [ "$1" != "" ]; do
		case $1 in
			-c | --clear-log )
				do_clear="YES"
				;;
			--remote-app )
				shift
				remote_app=$1
				;;
			--remote-bit )
				shift
				remote_bit=$1
				;;
			-s | --silent )
				EDK_LOGFILE="/dev/null"
				;;
			-l | --log-file )
				shift
				EDK_LOGFILE=$1
				;;
			-f | --xmp-file )
				shift
				xmp_file=$1
				;;
			-w | --work-dir )
				shift
				work_dir=$1
				[ ! -d "$work_dir" ] &&
					echo "Not a valid path ('$work_dir')!" && exit 1
				work_dir=$(cd $work_dir;pwd)
				;;
			* )
				[ "$do_command" != "" ] &&
					echo "Build command already given ($do_command)!" && exit 1
				for a in $valid_builds; do
					if [ $1 == $a ]; then
						do_command=$1
						break;
					fi
				done
				[ "$do_command" == "" ] &&
					echo "Unknown build command ($1)!" && exit 1
				;;
		esac
		shift
	done

	[ ! -f "$work_dir/$xmp_file" ] &&
		echo "Maybe not a valid EDK project location ('$work_dir')!" && exit 1
	cd $work_dir
	get_deviceinfo $xmp_file
	get_systeminfo $xmp_file
	get_buildinfo $xmp_file
	[ "$EDK_LOGFILE" == "" ] && EDK_LOGFILE="$(basename $xmp_file .xmp).log"
	[ "$do_clear" == "YES" ] && echo -n "" >$EDK_LOGFILE
	[ "$remote_app" == "" ] || get_remote_app $remote_app
	[ "$remote_bit" == "" ] || get_remote_bit $remote_bit
	[ "$do_command" == "bit" ] && build_bit
	[ "$do_command" == "app" ] && build_app
	[ "$do_command" == "dow" ] && build_download
	[ "$do_command" == "ace" ] && build_ace
	[ "$do_command" == "dum" ] && echo "[DUMMY] ==> Write Your Text Here"
	[ "$do_command" == "" ] && echo "No command given?"
	cd $curr_dir
	echo
	echo "[$TOOL_THISFILE] ==> Done."
	echo
}

# BEGIN MAIN SCRIPT

echo -e "\n$TOOL_THISFILE - $TOOL_THISFUNC ($TOOL_THISVERS)\n"
process_command $TOOL_COMMANDS

# END MAIN SCRIPT
