#!/bin/bash

# depstool
# - written by azman@my1matrix.org
# - slackware tool to help find dependencies of specific binary and/or package
# - based on info gathered from the internet - kudos to the original source

TOOL_NAME=`basename $0`
TOOL_PATH=`dirname $0`
TOOL_PATH=`cd $TOOL_PATH;pwd`

list_package_file()
{
	local info=$1
	[ ! -f "$info" ] && return
	cat $info | sed -e '1,/FILE LIST/d'
}

# list all files in a package
show_file_list()
{
	local pick=$1
	local temp="${pick}-[^-]*-[^-]*-[^-]*$"
	local logs="/var/log/packages"
	local info=`find $logs -type f | grep -e "/$temp"`
	[ ! -f "$info" ] && echo "Cannot find package '$pick'! ($info)" && exit 1
	local base=`basename $info`
	echo "Listing all files in for package '$base'"
	list_package_file $info
}

find_package_file()
{
	local test find pack full=$1
	for pack in /var/log/packages/* ; do
		test=`cat $pack | sed -e '1,/FILE LIST/d' | grep "$full"`
		[ "$test" != "" ] && find=`basename $pack` && break
	done
	echo -n "$find"
}

# shows package for file - OK
show_file_pack()
{
	local pick=$1
	echo -n "Looking for package containing '$pick'... "
	local that=`find_package_file $pick`
	[ "$that" = "" ] && echo "not found!" && exit 1
	echo "done."
	echo "File:'$pick'"
	echo "Pack:'$that'"
}

exec_NOT_binary()
{
	local test=`file -b $1 | cut -d' ' -f1`
	[ "$test" != "ELF" ] && return 0 || return 1
}

find_exec_fullpath()
{
	local func="find_exec_fullpath()"
	[ ! -z "${exec+x}" ] && echo "$func: Var 'exec' NOT defined!" && exit 1
	local pick=$1
	local full=`which $pick 2>/dev/null`
	[ ! -x "$full" ] && echo "$func: Cannot find executable '$pick'!" && exit 1
	# check if a link
	if [ -L "$full" ] ; then
		full=`readlink -f $full`
		echo "Executable '$pick' is a link to '$full'!"
	fi
	exec_NOT_binary $full && echo "$func: $full NOT in ELF format!" && exit 1
	exec=$full
}

# shows package for exec - OK
show_exec_pack()
{
	local pick=$1
	local exec ; find_exec_fullpath $pick
	local test=`echo $exec | sed 's|^/\(.*\)$|\1|'`
	echo -n "Looking for package containing '$pick' ($test)... "
	local that=`find_package_file $test`
	[ "$that" = "" ] && echo "not found!" && exit 1
	echo "done."
	echo "Binary: '$pick' ($exec)"
	echo "Package: $that"
}

list_that_deps()
{
	local exec=$1
	local list=`ldd $exec 2>/dev/null | awk '{print $1}'`
	[ "$list" = "" ] && return
	local that test deps
	for that in $list ; do
		that=`basename $that`
		test=${that%%.*}
		[ "$test" = "linux-vdso" ] && continue
		[ "${test//ld-linux-/}" != "$test" ] && continue
		[ "$deps" = "" ] && deps=$that || deps="$deps $that"
	done
	echo -n "$deps"
}

# shows deps list - 4DEBUG - OK
show_deps_raw()
{
	local pick=$1
	exec_NOT_binary $pick && echo "$pick NOT in ELF format!" && exit 1
	echo "Binary: '$pick'"
	echo -n "Deps: "
	list_that_deps $pick ; echo
}

show_waiting()
{
	[ -z "$wait" ] && return
	if [ $wait -eq 1 ] ; then echo -ne "\b|" ; wait=2
	elif [ $wait -eq 2 ] ; then echo -ne "\b/" ; wait=3
	elif [ $wait -eq 3 ] ; then echo -ne "\b-" ; wait=4
	elif [ $wait -eq 4 ] ; then echo -ne "\b\\" ; wait=1
	else echo -ne "\b done.\n" ; fi
}

find_deps_package()
{
	local exec=$1
	local tlib pack libz
	local temp=`list_that_deps $exec`
	[ "$temp" = "" ] && return
	local wait=1
	for tlib in $temp ; do
		show_waiting
		pack=`find_package_file $tlib`
		[ "$pack" = "" ] && continue
		#pack="$pack{$tlib}" # for debugging
		[ "$libz" = "" ] && libz="$pack" || libz="${libz} $pack"
	done
	wait=0 ; show_waiting
	[ "$libz" = "" ] && return
	# sorted and unique!
	[ -z "${libs+x}" ] &&
		libs=`echo $libz | tr ' ' '\n' | sort -u | tr '\n' ' '`
}

# shows package for exec, and all package deps
show_exec_deps()
{
	local pick=$1
	local exec ; find_exec_fullpath $pick
	local test=`echo $exec | sed 's|^/\(.*\)$|\1|'`
	echo -n "Looking for package containing '$pick' ($test)... "
	local that=`find_package_file $test`
	[ "$that" = "" ] && echo "not found!" && exit 1
	echo "done."
	echo -n "Looking for package(s) '$pick' depends on... "
	local libs ; find_deps_package $full
	echo "Binary: '$pick' ($exec)"
	echo "Package: $that"
	echo -n "Dependencies: "
	[ -z "$libs" ] && echo "None" && return
	local pack
	for pack in $libs ; do echo -ne "\n  $pack" ; done ; echo
}

exec_is_static()
{
	local test=`file -b $1 | grep "statically linked"`
	[ "$test" = "" ] && return 1 || return 0
}

# shows deps for file (single exec)
show_file_deps()
{
	local func="show_file_deps()"
	local pick=$1
	[ ! -f "$pick" ] && echo "$func: Cannot find $pick!" && exit 1
	local base=`basename $pick`
	local path=`dirname $pick`
	path=`cd $path;pwd`
	local full=$path/$base
	exec_NOT_binary $full && echo "$func: $pick NOT in ELF format!" && exit 1
	exec_is_static $full &&  echo "$pick ($full) is a static binary!" && return
	echo -n "Looking for package(s) '$pick' depends on... "
	local libs ; find_deps_package $full
	echo "Binary: '$pick' ($full)"
	echo -n "Dependencies: "
	[ -z "$libs" ] && echo "None" && return
	local pack
	for pack in $libs ; do echo -ne "\n  $pack" ; done ; echo
}

list_package_shared()
{
	local base=$1 # e.g. aaa_base-14.2-x86_64-2
	local info="/var/log/packages/$base"
	[ ! -f "$info" ] && return
	local that full wait=1
	for that in `cat $info | sed -e '1,/FILE LIST/d'` ; do
		show_waiting
		[ "${that//.so./}" = "$that" ] && continue
		[ "$full" = "" ] && full=$that || full="$full $that"
	done
	wait=0 ; show_waiting
	[ -z "${list+x}" ] && list=$full
}

find_install_name()
{
	local name=$1
	local temp="${name}-[^-]*-[^-]*-[^-]*$"
	local logs="/var/log/packages"
	local base=`ls $logs | grep -e "$temp"`
	echo -n "$base"
}

show_find_raw()
{
	local pick=$1 # can be any name to look for
	# WORK IN PROGRESS... NOT WORKING
	local name=$1
	[ -z "$name" ] && echo "No package name given!" && exit 1
	local full=`find_install_name $name`
	echo "Package: '$name' => '$full'"
	echo -n "Looking for shared objects... "
	local list ; list_package_shared $full
	[ -z "$list" ] && echo "-- No shared library." && return
	local that
	for that in $list ; do echo "-- $that" ; done
}

list_package_exec()
{
	local base=$1 # e.g. aaa_base-14.2-x86_64-2
	local info="/var/log/packages/$base"
	[ ! -f "$info" ] && return
	local tbin temp type full wait=1
	for tbin in `cat $info | sed -e '1,/FILE LIST/d'` ; do
		show_waiting
		[ "$tbin" = "./" ] && continue
		temp="/$tbin"
		[ ! -x "$temp" ] && continue
		type=`file -b $temp | cut -d' ' -f1`
		[ "$type" != "ELF" ] && continue
		[ "$full" = "" ] && full=$temp || full="$full $temp"
	done
	wait=0 ; show_waiting
	[ -z "${list+x}" ] && list=$full
}

# show all binaries in a package
show_pack_bins()
{
	local pick=$1
	local base=`find_install_name $pick`
	[ "$base" = "" ] && echo "Cannot find package '$pick'!" && exit 1
	echo -n "Looking for binaries in '$base'... "
	local list ; list_package_exec $base
	list=`echo $list | tr ' ' '\n' | sort -u | tr '\n' ' '`
	local that
	for that in $list ; do echo "  Binary: $that" ; done
}

# show deps for a package
show_pack_deps()
{
	local func="show_pack_deps()"
	local pick=$1
	local base=`find_install_name $pick`
	[ "$base" = "" ] && echo "Cannot find package '$pick'!" && exit 1
	echo -n "Looking for binaries in '$base'... "
	local list ; list_package_exec $base
	[ "$libs" != "" ] &&
		echo "Looking for dependencies of all binaries in '$base'."
	local that libz
	for that in "$list" ; do
		echo "Looking for packages '$that' depends on... "
		local libs ; find_deps_package $that
		[ "$libs" = "" ] && continue
		[ "$libz" = "" ] && libz="$libs" || libz="$libz $libs"
		libz=`echo $libz | tr ' ' '\n' | sort -u | tr '\n' ' '`
	done
	echo "Package: $base ($pick)"
	echo -n "Dependencies: "
	[ -z "$libz" ] && echo "None" && exit 0
	local pack
	for pack in $libz ; do echo -ne "\n  $pack" ; done ; echo
}

THAT_TASK=$1 ; shift
THAT_PICK=$1 ; shift

case "$THAT_TASK" in
	pack4file) show_file_pack $THAT_PICK ;;
	pack4exec) show_exec_pack $THAT_PICK ;;
	raw_deps) show_deps_raw $THAT_PICK ;; # 4DEBUG
	deps4exec) show_exec_deps $THAT_PICK ;;
	deps4file) show_file_deps $THAT_PICK ;;
	bins4pack) show_pack_bins $THAT_PICK ;;
	deps4pack) show_pack_deps $THAT_PICK ;;
	raw_find) show_find_raw $THAT_PICK ;;
	list_pack) show_file_list $THAT_PICK ;;
	*) [ "$THAT_TASK" != "" ] && echo "Unknown task '$THAT_TASK'!" ;;
esac

exit 0

#To list dependencies:
# echo ${BINARY_EXECS[@]} | xargs ldd 2>/dev/null | grep -vi "not found\|dynamic\|statically\|:$" \
    | awk -F '=>' '{printf $NF"\n"}' | sed -e 's/^	//;s/^ //;s/\(0x\w.......\)//' \
    | cut -f1 -d \ | sort | uniq

#To list missing dependencies:
# echo ${BINARY_EXECS[@]} | xargs ldd 2>/dev/null | grep -i "not found" | cut -f1 -d \ | cut -b 2- | sort | uniq
