#!/bin/bash

# libmy1file
# - written by azman@my1matrix.org
# - library functions for file/path checking
# - the must_* functions require libmy1echo

find_binary()
{
	local chk_exec=$1
	local set_exec=`which $chk_exec 2>/dev/null`
	echo -n $set_exec
}

must_have_exec()
{
	local chk_exec=$1 ; shift
	local msg_fail=$@
	local chk_full=`find_binary $chk_exec`
	[ "$msg_fail" == "" ] && msg_fail="Executable '$chk_exec' not found!"
	[ ! -x "$chk_full"  ] && error_exit "$msg_fail\n\n"
}

must_have_path()
{
	local chk_path=$1 ; shift
	local msg_fail=$@
	[ "$msg_fail" == "" ] && msg_fail="Path '$chk_path' not found!"
	[ ! -d "$chk_path"  ] && error_exit "$msg_fail\n\n"
}

must_have_file()
{
	local chk_file=$1 ; shift
	local msg_fail=$@
	[ "$msg_fail" == "" ] && msg_fail="File '$chk_file' not found!"
	[ ! -f "$chk_file"  ] && error_exit "$msg_fail\n\n"
}

must_be_root()
{
	local msg_fail=$@
	[ -z "$msg_fail" ] && msg_fail="Must run as root!"
	[ $UID -ne 0 ] && error_exit "$msg_fail\n\n"
}

get_path_owner()
{
	local chk_user chk_grpn
	local chk_path
	local chk_this=$1
	[ "$chk_this" == "/" ] && echo -n "root:root" && return
	[ "$chk_this" == "." ] && chk_this=`pwd`
	[ "$chk_this" == ".." ] && chk_this=`cd .. ; pwd`
	[ -L "$chk_this" ] && chk_this=`readlink -e $chk_this`
	[ ! -r "$chk_this" ] && return
	chk_path=`dirname $chk_this`
	chk_path=`cd $chk_path ; pwd`
	chk_this=`basename $chk_this`
	[ ! -r "$chk_path" ] && return
	chk_user=`ls -l "${chk_path}/" | grep -e "${chk_this}$"`
	set -- $chk_user
	chk_user=$3
	chk_grpn=$4
	echo -n "$chk_user:$chk_grpn"
}

fix_path_owner()
{
	local path=$1 ; shift
	[ ! -f "$path" -a ! -d "$path" ] && error_exit "Invalid path '$path'!\n\n"
	local name=$1
	[ "$name" = "--basename" ] && { name=1 ; shift ; } || name=0
	local show=$path
	[ $name -ne 0 ] && show=`basename $path`
	local subs=$1
	[ "$subs" = "--all" ] && { subs="-R" ; shift ; } || unset subs
	[ ! -z "$subs" ] && shift
	local pdir=`dirname $path`
	local perm=`get_path_owner $pdir`
	local temp=`get_path_owner $path`
	if [ "$temp" != "$perm" -a "$perm" != "" ] ; then
		info_msg "Fixing permission for '$show' ($subs)... "
		chown $subs $perm $path
		info_msg --no-tag "done.\n"
	fi
	if [ -d $path -a "$subs" != "" ] ; then # also check contents
		# in case some content far far away still not owned
		local user=`echo $perm | cut -d':' -f1`
		local list=`find $path ! -user $user`
		if [ "$list" != "" ] ; then
			#warn_msg "{$list}\n"
			info_msg "Fixing permission for contents in '$show' ($subs)... "
			chown $subs $perm $path
			info_msg --no-tag "done.\n"
		fi
	fi
}

prompt_to_continue()
{
	local what
	read -p "Continue? [y/N] " -n 1 what && echo
	[ "$what" = "y" ] && what="Y"
	[ -z "$what" -o "$what" != "Y" ] && what="N"
	[ "$what" = "N" ] && exit 0
}

make_path()
{
	local path=$1
	local init=$2
	[ ! -d "$path" ] && mkdir -p $path && return
	[ "$init" = "--init" ] &&  rm -rf $path/* $path/.[!.]*
}

make_mark()
{
	local init name mark form path=$1 ; shift
	while [ "$1" != "" ]; do
		case "$1" in
			--init) init=$1 ;;
			--name) shift ; name=$1 ;;
			--mark) shift ; mark=$1 ;;
			--date) shift ; form=$1 ;;
		esac
		shift
	done
	make_path $path $init
	[ -z "$name" -o -z "$mark" ] && return
	echo `date $form`" $name" > $path/$mark
}
