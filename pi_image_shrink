#!/bin/bash

DISK_FILE="$1"
[ -z "$DISK_FILE" ] && echo "No image file given!" && exit 1
[ ! -f "$DISK_FILE" ] && echo "Cannot find '$DISK_FILE'!" && exit 1
echo "ImageFile:$DISK_FILE"

MAKE_EXEC="$2"
[ "$MAKE_EXEC" == "-x" ] && MAKE_EXEC="YES" || MAKE_EXEC="NO"

DISK_SIZE=`ls -lh "$DISK_FILE" | cut -d ' ' -f 5`
echo "DiskSize:$DISK_SIZE"

# must run as root
[ $UID -ne 0 ] && echo "Must run as root!" && exit 1

# --partscan @ -P
LOOP_DISK=`losetup -P --show -f "$DISK_FILE"`
echo "LoopDisk:$LOOP_DISK"

# show disk
TEST_THAT=`lsblk ; sync ; sync ; sync`
LOOP_SIZE=`lsblk -l -p | grep "$LOOP_DISK " | tr -s ' ' | cut -d ' ' -f 4`
echo "LoopSize:$LOOP_SIZE"

# get loop device for boot partition
PART_BOOT=`lsblk -l -p -f | grep "$LOOP_DISK" | grep "boot" | tr -s ' '`
LOOP_BOOT=`echo "$PART_BOOT" | cut -d ' ' -f 1`
#echo "PartBoot:$PART_BOOT"
echo "LoopBoot:$LOOP_BOOT"

# get loop device for rootfs partition
PART_ROOT=`lsblk -l -p -f | grep "$LOOP_DISK" | grep "rootfs" | tr -s ' '`
LOOP_ROOT=`echo "$PART_ROOT" | cut -d ' ' -f 1`
#echo "PartRoot:$PART_ROOT"
echo "LoopRoot:$LOOP_ROOT"

# tune2fs
PART_TEST=`tune2fs -l "$LOOP_ROOT"`
PART_FULL=`echo "$PART_TEST" | grep '^Block count:' | sed 's/.*:\s*\(.*\)$/\1/'`
PART_SIZE=`echo "$PART_TEST" | grep '^Block size:' | sed 's/.*:\s*\(.*\)$/\1/'`
#echo "PartSectSize:$PART_SIZE(byte)"
#echo "PartSectNums:$PART_FULL"
# final size must be multiples of 10MB
SECT_MAKE=$((10*1024*1024/PART_SIZE))
#echo "PartSectMake:$SECT_MAKE"
SECT_HALF=$((SECT_MAKE/2))

# cleanup fs
if [ "$MAKE_EXEC" = "YES" ] ; then
echo "Checking $LOOP_ROOT..."
e2fsck -f "$LOOP_ROOT"
fi

# get used block
PART_MINS=`resize2fs -P "$LOOP_ROOT" 2>&1`
[ $? -ne 0 ] && echo "Error getting minimum size!"
PART_MINS=`echo $PART_MINS | sed 's/.*:\s*\(.*\)$/\1/'`
#echo "PartMins:$PART_MINS"
PART_MAKE=$((PART_MINS%SECT_MAKE))
#echo "PartMake:$PART_MAKE"
PART_XTRA=$((SECT_MAKE-PART_MAKE))
[ $PART_XTRA -lt $SECT_HALF ] && PART_XTRA=$((PART_XTRA+SECT_MAKE))
#echo "PartXtra:$PART_XTRA"
PART_MINS=$((PART_MINS+PART_XTRA))
echo "PartMins:$PART_MINS"

# shrink fs
if [ "$MAKE_EXEC" = "YES" ] ; then
echo "Shrinking $LOOP_ROOT..."
resize2fs -M $LOOP_ROOT $PART_MINS
fi

PART_DISK=`fdisk -l "$LOOP_DISK"`
SECT_SIZE=`echo "$PART_DISK" | grep "Sector size"`
SECT_SIZE=`echo "$SECT_SIZE" | grep "512 bytes / 512 bytes"`
[ "$SECT_SIZE" = "" ] &&
	echo "[WARN] Sector size in $LOOP_DISK is NOT 512!"
PART_ROOT=`echo "$PART_DISK" | tail -n 1 | tr -s ' '`
#echo "PartRoot:$PART_ROOT"
PART_TEST=`echo $PART_ROOT | cut -d ' ' -f 1`
[ "$PART_TEST" != "$LOOP_ROOT" ] &&
	echo "Partition mismatch ($PART_TEST!=$LOOP_ROOT)!"
PART_INIT=`echo $PART_ROOT | cut -d ' ' -f 2`
echo "PartInit:$PART_INIT"
PART_ENDS=`echo $PART_ROOT | cut -d ' ' -f 3`
echo "PartEnds:$PART_ENDS"
PART_THAT=`echo $PART_ROOT | cut -d ' ' -f 4`
echo "PartThat:$PART_THAT"

PART_BYTE=$((PART_MINS*PART_SIZE))
#echo "PartByte:$PART_BYTE"
PART_SECT=$((PART_BYTE/512))
echo "PartSect:$PART_SECT(512b sectors)"
PART_ENDS=$((PART_INIT+PART_SECT-1))
echo "PartEnds:$PART_ENDS(NEW)"
DISK_FULL=$((PART_ENDS+1))
echo "DiskFull:$DISK_FULL(NEW)"

if [ "$MAKE_EXEC" = "YES" ] ; then
echo "Resizing $LOOP_ROOT..."
fdisk $LOOP_DISK >/dev/null 2>&1 <<EOF
d

n
p

$PART_INIT
$PART_ENDS
w
EOF
fi

echo "[RECHECK]"
PART_DISK=`fdisk -l "$LOOP_DISK"`
PART_ROOT=`echo "$PART_DISK" | tail -n 1 | tr -s ' '`
PART_INIT=`echo $PART_ROOT | cut -d ' ' -f 2`
echo "PartInit:$PART_INIT"
PART_ENDS=`echo $PART_ROOT | cut -d ' ' -f 3`
echo "PartEnds:$PART_ENDS"
PART_THAT=`echo $PART_ROOT | cut -d ' ' -f 4`
echo "PartThat:$PART_THAT"

TEST_FLAG=0
TEST_PATH="mnt"
[ ! -d $TEST_PATH ] && TEST_FLAG=1 && mkdir -p $TEST_PATH
mount $LOOP_BOOT $TEST_PATH
TEST_FILE="$TEST_PATH/cmdline.txt"
TEST_INIT="init=/usr/lib/raspi-config/init_resize.sh"
OPTS="-e"
if [ -f $TEST_FILE ] ; then
	echo "[CMDLINE]"
	cat $TEST_FILE
	PART_UUID=`lsblk -l -p -o NAME,LABEL,PARTUUID | grep "$LOOP_ROOT"`
	PART_UUID=`echo "$PART_UUID" | cut -d ' ' -f 3`
	echo "PartUUID=$PART_UUID"
	[ "$MAKE_EXEC" = "YES" ] && OPTS="-i -e"
	sed $OPTS "s/^\(.*PARTUUID=\)[^\s]*\(\s.*\)$/\1$PART_UUID\2/g" $TEST_FILE
	TEST_WHAT=`cat $TEST_FILE | grep "init="`
	[ "$TEST_WHAT" = "" ] &&
		sed $OPTS "s|root=|$TEST_INIT root=|g" $TEST_FILE
fi
sync ; sync ; sync
umount $TEST_PATH
mount $LOOP_ROOT $TEST_PATH
if [ "$MAKE_EXEC" = "YES" ] ; then
	echo "Creating new $TEST_PATH/etc/rc.local ..."
	[ ! -f "$TEST_PATH/etc/rc.local-saved" ] &&
		mv "$TEST_PATH/etc/rc.local" "$TEST_PATH/etc/rc.local-saved"
	cat <<EOF > "$TEST_PATH/etc/rc.local"
#!/bin/bash
root_part=\$(mount | sed -n 's|^/dev/\(.*\) on / .*|\1|p')
resize2fs /dev/\$root_part
rm -f /etc/rc.local
mv /etc/rc.local-saved /etc/rc.local
reboot
EOF
	#cp $TEST_PATH/etc/rc.local $TEST_PATH/etc/rc.local-debug
	chmod +x $TEST_PATH/etc/rc.local
	cat $TEST_PATH/etc/rc.local
fi
sync ; sync ; sync
umount $TEST_PATH
[ $TEST_FLAG -ne 0 ] && rmdir $TEST_PATH

# release loop device
losetup -D

DISK_FULL=$((DISK_FULL*512))
echo "DiskFull:$DISK_FULL(bytes)"

if [ "$MAKE_EXEC" = "YES" ] ; then
echo "Resizing image $DISK_FILE..."
truncate -s $DISK_FULL $DISK_FILE
fi

DISK_FULL=$((DISK_FULL/1048576))
echo "DiskFull:$DISK_FULL(M)"
