#!/bin/bash

# libmy1slack
# - written by azman@my1matrix.net
# - library functions for slackware system management

MY1_LIBNAME="libmy1slack"
MY1_LIBVERS="2016.12.00"
MY1_LIBCALL=`basename $0 .sh`

# determine slackware architecture, NOT machine's!
SLACKARCH=${SLACKARCH:=""}
case $SLACKARCH in
	x86) SLACKARCH="" ;;
	x86_64) SLACKARCH="64" ;;
	*)
		SLACKARCH=`find / -maxdepth 1 -name 'lib64' -type d 2>/dev/null`
		if [ "$SLACKARCH" == "/lib64" ] ; then SLACKARCH="64"
		else SLACKARCH="" ; fi ;;
esac
# get slackware release version - not sure if current is supported!
SLACKNAME=${SLACKNAME:="slackware$SLACKARCH"}
SLACKVERS=${SLACKVERS:=""}
if [ "$SLACKVERS" == "" ]; then
	SLACKVERS=`cat /etc/slackware-version | sed 's/Slackware //'`
	SLACKVMAJ=`echo $SLACKVERS | cut -d. -f1`
	SLACKVMIN=`echo $SLACKVERS | cut -d. -f2`
	# just in case?
	SLACKVREL=`echo $SLACKVERS | cut -d. -f3`
fi
# find slackware tree
SLACKRELEASE=${SLACKRELEASE:="$SLACKNAME-$SLACKVERS"}
SLACKROOTDIR=${SLACKROOTDIR:=""}
if [ "$SLACKROOTDIR" == "" ]; then
	SLACKFINDDIR=${SLACKFINDDIR:="/home"} # default path to look for
	SLACKFINDOPT="-maxdepth 3 -name $SLACKRELEASE -type d"
	SLACKROOTDIR=`find $SLACKFINDDIR $SLACKFINDOPT 2>/dev/null`
	[ ! -d "$SLACKROOTDIR" ] &&
		echo "Cannot find Slackware Tree!" >&2 && exit 1
	SLACKROOTDIR=`dirname $SLACKROOTDIR`
fi
SLACKRELPATH=${SLACKRELPATH:="${SLACKROOTDIR}/${SLACKRELEASE}"}
SLACKPKGPATH=${SLACKPKGPATH:="${SLACKRELPATH}/slackware$SLACKARCH"}
SLACKEXTPATH=${SLACKEXTPATH:="${SLACKRELPATH}/extra"}
SLACKPKGFILE=${SLACKPKGFILE:="${SLACKPKGPATH}/PACKAGES.TXT"}
SLACKEXTFILE=${SLACKEXTFILE:="${SLACKEXTPATH}/PACKAGES.TXT"}
SLACKINSTLOG="/var/log/packages"

function tag_msg()
{
	local msg_tag=$1 ; shift
	local col_tag=$1 ; shift
	local out_err="yes"
	[ "$1" == "--stdout" ] && out_err="" && shift
	[ "$1" == "--no-tag" ] && msg_tag="" && shift
	if [ "$out_err" == "yes" ]; then
		echo -ne "\033[1;${col_tag}m${msg_tag}\033[0;${col_tag}m $1\033[0m" 1>&2
	else
		echo -ne "\033[1;${col_tag}m${msg_tag}\033[0;${col_tag}m $1\033[0m"
	fi
}

function error_msg()
{
	local error_tag="[ERROR]"
	local color_tag="31"
	tag_msg "$error_tag" "$color_tag" "$@"
}

function error_exit()
{
	error_msg "--no-tag" "\n"
	error_msg "$@ Aborting!\n\n"
	exit 1
}

function debug_msg()
{
	local debug_tag="[DEBUG]"
	local color_tag="33"
	tag_msg "$debug_tag" "$color_tag" "$@"
}

function check_msg()
{
	local check_tag="[CHECK]"
	local color_tag="34"
	tag_msg "$check_tag" "$color_tag" "$@"
}

function warn_msg()
{
	local warn0_tag="[WARN]"
	local color_tag="33"
	tag_msg "$warn0_tag" "$color_tag" "$@"
}

function info_msg()
{
	local info0_tag="[INFO]"
	local color_tag="32"
	tag_msg "$info0_tag" "$color_tag" "--stdout" "$@"
}

if [ "$MY1_DEBUG" == "YES" ]; then
	echo
	debug_msg "my1slack Library Name is $MY1_LIBNAME\n"
	debug_msg "my1slack Library Version is $MY1_LIBVERS\n"
	debug_msg "System machine is $(uname -m)\n"
	debug_msg "Slack Version is $(cat /etc/slackware-version)\n"
	debug_msg "Slack Release is $SLACKRELEASE\n"
	debug_msg "Slack Tree is at $SLACKROOTDIR\n"
	debug_msg "Command Call '$MY1_LIBCALL'\n"
fi

function find_binary()
{
	local chk_exec=$1
	local set_exec=$(which $chk_exec 2>/dev/null)
	echo -n $set_exec
	[ "$msg_fail" == "" ] && msg_fail="Binary '$chk_exec' not found!"
	[ "$set_exec" == "" ] && error_exit "$msg_fail"
}

function must_have_path()
{
	local chk_path=$1 ; shift
	local msg_fail=$@
	[ "$msg_fail" == "" ] && msg_fail="Path '$chk_path' not found!"
	[ ! -d "$chk_path"  ] && error_exit "$msg_fail"
}

function must_be_root()
{
	[ $UID -ne 0 ] && error_exit "Must run as root!"
}

function get_pkg_info()
{
	# get pkg info from basename (i.e. filename minus extension!)
	local pkg_name pkg_vers pkg_arch pkg_extd
	local pkg_base="$1"
	pkg_extd=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_base=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	pkg_arch=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_base=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	pkg_vers=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_name=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	echo -n "$pkg_name $pkg_vers $pkg_arch $pkg_extd"
}

function get_pathpack()
{
	# make a package list from custom path
	local pkg_list=""
	if [ -d "$1" ]; then
		cd $1
		for pkg_file in *.t[gx]z; do
			pkg_temp=`echo $pkg_file | sed 's/\.t[xg]z//'`
			pkg_list="${pkg_list}${pkg_temp} "
		done
		cd - >/dev/null
	fi
	echo -n "$pkg_list"
}

function get_softpack()
{
	# make a package list from official software set (e.g. a,d,l...)
	echo -n `get_pathpack ${SLACKPKGPATH}/$1`
}

function get_packsoft()
{
	# get official software set for given package
	local pkg_name="$1"
	local pkg_soft="z" # defaulf unknown set
	for pkg_path in ${SLACKPKGPATH}/* ; do
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z$"
		local pkg_test=`ls $pkg_path | grep -e "$pkg_temp"`
		if [ "$pkg_test" != "" ] ; then
			pkg_soft=`basename ${pkg_path}`
			break
		fi
	done
	echo -n "$pkg_soft"
}

function comp_package()
{
	# compare 2 package basenames, returns non-zero if different!
	local pkg1_base="$1"
	local pkg2_base="$2"
	local pkg_temp
	local pkg1_name pkg1_vers pkg1_arch pkg1_extd
	local pkg2_name pkg2_vers pkg2_arch pkg2_extd
	# extract info components
	pkg_temp=`get_pkg_info $pkg1_base`
	pkg1_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg1_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg1_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg1_extd=`echo $pkg_temp | cut -d' ' -f4`
	pkg_temp=`get_pkg_info $pkg2_base`
	pkg2_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg2_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg2_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg2_extd=`echo $pkg_temp | cut -d' ' -f4`
	# do compare!
	[ "$pkg1_name" == "$pkg2_name" ] || return 1
	[ "$pkg1_vers" == "$pkg2_vers" ] || return 2
	[ "$pkg1_arch" == "$pkg2_arch" ] || return 3
	[ "$pkg1_extd" == "$pkg2_extd" ] || return 4
	# okay.. the same!
	return 0
}

function find_desc()
{
	# get package description from a PACKAGES.TXT file
	local pkg_name="$1"
	local pkgs_txt="$2"
	local pkg_desc=`grep -e "^$pkg_name:" $pkgs_txt`
	echo -n "$pkg_desc"
}

function find_package_desc()
{
	# get package entry from mirror tree
	local pkg_name="$1"
	local pkg_desc=`find_desc $pkg_name $SLACKPKGFILE`
	echo -n "$pkg_desc"
}

function find_install_desc()
{
	# get package entry from current installation
	local pkg_name="$1"
	local pkg_temp="\<${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_test=`ls $SLACKINSTLOG | grep -e "$pkg_temp"`
	[ "$pkg_test" = "" ] && return
	local pkgs_txt="$SLACKINSTLOG/$pkg_test"
	local pkg_desc=`find_desc $pkg_name $pkgs_txt`
	echo -n "$pkg_desc"
}

function find_info()
{
	# get package info from a PACKAGES.TXT file or /var/log entry
	local pkg_name="$1"
	local pkgs_txt="$2"
	# info structure?
	local pkg_base pkg_file pkg_path pkg_size pkg_full
	# pattern search?
	#local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_temp="${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_test=`cat $pkgs_txt | grep -e "$pkg_temp" -A3`
	[ "$pkg_test" = "" ] && return
	# extract basic info
	local chk_name="PACKAGE NAME:"
	pkg_file=`echo "$pkg_test" | grep "^$chk_name"`
	pkg_file=`echo "$pkg_file" | sed "s/$chk_name[[:space:]]*//"`
	chk_name="PACKAGE LOCATION:"
	pkg_path=`echo "$pkg_test" | grep "^$chk_name"`
	pkg_path=`echo "$pkg_path" | sed "s/$chk_name[[:space:]]*//"`
	# check if location provided by /var/log/packages entry
	pkg_temp=`echo $pkg_path | grep "/var/log/mount/"`
	if [ "$pkg_temp" != "" ] ; then
		pkg_file=`basename $pkg_path`
		pkg_path=`dirname $pkg_path | sed 's|/var/log/mount/||'`
		pkg_path=${SLACKPKGPATH}/${pkg_path}
	else
		pkg_temp=`echo $pkg_path | sed 's|^\./||'`
		[ "$pkg_path" != "$pkg_temp" ] &&
			pkg_path="${SLACKRELPATH}/${pkg_temp}"
	fi
	#installed packages have package file info in location!
	pkg_base=`echo $pkg_file | sed 's/\.t[xg]z//'`
	if [ "$pkg_base" == "$pkg_file" ]; then
		pkg_file=`basename $pkg_path`
		pkg_path=`dirname $pkg_path`
	fi
	chk_name="PACKAGE SIZE (compressed): "
	pkg_size=`echo "$pkg_test" | grep "^$chk_name"`
	if [ "$pkg_size" == "" ] ; then
		chk_name="COMPRESSED PACKAGE SIZE:"
		pkg_size=`echo "$pkg_test" | grep -e "^$chk_name"`
		pkg_size=`echo "$pkg_size" | sed "s/$chk_name[[:space:]]*//"`
	else
		pkg_size=`echo "$pkg_size" | sed "s/$chk_name[[:space:]]*//"`
		pkg_size=`echo $pkg_size | sed 's/ K.*//'`"K"
	fi
	chk_name="PACKAGE SIZE (uncompressed):"
	pkg_full=`echo "$pkg_test" | grep "^$chk_name"`
	if [ "$pkg_full" == "" ] ; then
		chk_name="UNCOMPRESSED PACKAGE SIZE:"
		pkg_full=`echo "$pkg_test" | grep -e "^$chk_name"`
		pkg_full=`echo "$pkg_full" | sed "s/$chk_name[[:space:]]*//"`
	else
		pkg_full=`echo "$pkg_full" | sed "s/$chk_name[[:space:]]*//"`
		pkg_full=`echo $pkg_full | sed 's/ K.*//'`"K"
	fi
	# arrange output
	echo -n "$pkg_base $pkg_file $pkg_path $pkg_size $pkg_full"
}

function find_package()
{
	# get package entry from mirror tree
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_base=`cat $SLACKPKGFILE | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && [ -r "$SLACKEXTFILE" ] &&
		pkg_base=`cat $SLACKEXTFILE | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && return
	#pkg_base=`echo $pkg_base | sed 's/PACKAGE NAME:[[:space:]]*//'`
	pkg_base=`echo $pkg_base | sed 's|.*/||'`
	pkg_base=`echo $pkg_base | sed 's/\.t[gx]z//'`
	[ "$pkg_flag" != "--full" ] && echo -n "$pkg_base" && return
	local pkg_test=`find_info $pkg_name $SLACKPKGFILE`
	[ "$pkg_test" = "" ] && [ -r "$SLACKEXTFILE" ] &&
		pkg_test=`find_info $pkg_name $SLACKEXTFILE`
	echo -n "$pkg_test"
}

function find_install()
{
	# get package entry from current installation
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_base=`ls $SLACKINSTLOG | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && return
	[ "$pkg_flag" != "--full" ] && echo -n "$pkg_base" && return
	local pkgs_txt="$SLACKINSTLOG/$pkg_base"
	pkg_temp=`find_info $pkg_name $pkgs_txt`
	echo -n "$pkg_temp"
}

function show_info()
{
	# get package info
	local pkg_name="$1"
	local pkg_flag=""
	local pkg_stat=""
	local pkg_info=`find_install $pkg_name --full`
	local pkg_test=`find_package $pkg_name --full`
	[ "$pkg_info" == "" ] && pkg_flag="NOT " && pkg_info=$pkg_test
	[ "$pkg_info" == "" ] && return 1
	[ "$pkg_test" == "" ] && pkg_stat=" (ALIEN!)"
	# info structure?
	local pkg_base pkg_file pkg_path pkg_size pkg_full
	pkg_base=`echo $pkg_info | cut -d' ' -f1`
	pkg_file=`echo $pkg_info | cut -d' ' -f2`
	pkg_path=`echo $pkg_info | cut -d' ' -f3`
	pkg_size=`echo $pkg_info | cut -d' ' -f4`
	pkg_full=`echo $pkg_info | cut -d' ' -f5`
	local pkg_temp pkg_name pkg_vers pkg_arch pkg_extd
	pkg_temp=`get_pkg_info $pkg_base`
	pkg_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg_extd=`echo $pkg_temp | cut -d' ' -f4`
	# do the printing
	local title="PACKAGE <$pkg_name> - BEGIN"
	local trail="PACKAGE <$pkg_name> - END"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "$title"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "FILE               : ${pkg_file}${pkg_stat}"
	echo "LOCATION           : $pkg_path"
	echo "VERSION            : $pkg_vers"
	echo "ARCHITECTURE       : $pkg_arch"
	echo "BUILD TAG          : $pkg_extd"
	echo "SIZE (Compressed)  : $pkg_size"
	echo "SIZE (Uncompressed): $pkg_full"
	echo "INSTALL STATUS     : ${pkg_flag}INSTALLED"
	local pkg_desc=`find_install_desc $pkg_name`
	[ "$pkg_desc" == "" ] && pkg_desc=`find_package_desc $pkg_name`
	[ "$pkg_desc" != "" ] &&
	echo "DESCRIPTION        : " && echo -e "$pkg_desc"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	echo "$trail"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	return 0
}

function list_package_path()
{
	# get all packages in given path
	local lst_path="$1"
	local log_path="$2"
	# get the rest of parameters
	shift ; shift
	# process all package file(s) in path
	for pkg_full in `find $lst_path -name "*.t[gx]z" -type f -maxdepth 1` ; do
		local pkg_file=`basename $pkg_full`
		local pkg_path=`dirname $pkg_full`
		# check extension first
		local pkg_exts=`echo $pkg_file | sed 's/\(.*\)\.\(.*\)$/\2/'`
		local pkg_base=`echo $pkg_file | sed 's/\(.*\)\.\(.*\)$/\1/'`
		# get particulars
		local pkg_temp=`get_pkg_info $pkg_base`
		local pkg_name=`echo $pkg_temp | cut -d' ' -f1`
		local pkg_vers=`echo $pkg_temp | cut -d' ' -f2`
		local pkg_arch=`echo $pkg_temp | cut -d' ' -f3`
		local pkg_extd=`echo $pkg_temp | cut -d' ' -f4`
		# check ignore list
		pkg_temp=`echo "$@" | grep "$pkg_name"`
		[ "$pkg_temp" != "" ] && continue
		# populate information
		chk_name="$pkg_name"
		chk_file="$pkg_full"
		chk_vers="[${pkg_vers}/${pkg_extd}]"
		# are we checking for patches? check installed version
		if [ -d "$log_path" ] ; then
			# find installed
			local pkg2temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
			local pkg2base=`ls $log_path | grep -e "$pkg2temp"`
			[ "$pkg2base" == "" ] && continue
			pkg2temp=`get_pkg_info $pkg2base`
			local pkg2name=`echo $pkg2temp | cut -d' ' -f1`
			local pkg2vers=`echo $pkg2temp | cut -d' ' -f2`
			local pkg2arch=`echo $pkg2temp | cut -d' ' -f3`
			local pkg2extd=`echo $pkg2temp | cut -d' ' -f4`
			# skip if for different arch!
			[ "$pkg2arch" != "$pkg_arch" ] && continue
			# check version update
			if [ "$pkg2vers" == "$pkg_vers" ] &&
				[ "$pkg2extd" == "$pkg_extd" ]; then
				chk_stat="pdone"
			else
				#pkg2temp=`echo $pkg_name | sed 's/kernel-//'`
				#if [ "$pkg2temp" != "$pkg_name" ] ; then
				#	chk_stat="pdone"
				#else
					chk_stat="check"
					chk_vers="[${pkg2vers}/${pkg2extd}($pkg2base)]->"
					chk_vers="${chk_vers}[${pkg_vers}/${pkg_extd}($pkg_base)]"
				#fi
			fi
			# DEBUG debug_msg "$pkg_full\n" && continue
		else
			local chk_arch sys_arch="x86"
			[ "$SLACKARCH" == "64" ] && sys_arch="x86_64"
			case $pkg_arch in
				i*86) chk_arch="x86" ;;
				x86) chk_arch="x86" ;;
				x86_64) chk_arch="x86_64" ;;
				noarch) chk_arch="$sys_arch" ;;
				*) chk_arch="" ;;
			esac
			# DEBUG debug_msg "$pkg_full '$chk_arch'/'$sys_arch'\n" && continue
			[ "$chk_arch" != "$sys_arch" ] && continue
			chk_stat="nlist"
		fi
		echo -n "$chk_name:$chk_stat:$chk_file:$chk_vers;"
	done
}

function format_text()
{
	# oooh! blinking color text!
	# format is "\033[<attr>;<textcolor>;<backcolor>m" \033 = \e (ESC char)
	local ends="\033[0m"
	# attributes
	local bold="1" # bright (bold on xterm?)
	local dim="2" # dim
	local uline="4"
	local blink="5" # doesn't work on xterm (only real console!)
	local reverse="7"
	local hidden="8"
	# text colors
	local black="30" # for background Xm + 10m
	local red="31"
	local green="32"
	local yellow="33"
	local blue="34"
	local magenta="35"
	local cyan="36"
	local white="37"
	local default="39"
	# check options
	local attr color text
	while [ "$1" != "" ] ; do
		case "$1" in
		--reset) attr="0" ;;
		--bold) attr=$bold ;;
		--blink) attr=$blink ;;
		--color)
			shift; color="$1"
			case "$color" in
				black) color="$black" ;;
				red) color="$red" ;;
				green) color="$green" ;;
				yellow) color="$yellow" ;;
				blue) color="$blue" ;;
				magenta) color="$magenta" ;;
				cyan) color="$cyan" ;;
				white) color="$white" ;;
				*) color="$default" ;;
			esac
			;;
		*)
			[ "$MY1_DEBUG" == "YES" ] &&
				echo "Attribute: $attr, Color: $color"
			if [ "$color" != "" ] ; then
				[ "$attr" == "" ] && attr="0"
				color="\033[${attr};${color}m"
			else
				[ "$attr" != "" ] &&
					color="\033[${attr}m"
			fi
			if [ "$color" == "" ] ;  then
				text="${text}${1} "
			else
				text="${text}${color}${1}${ends} "
			fi
			attr="" color=""
			;;
		esac
		shift
	done
	echo -e "$text"
}
