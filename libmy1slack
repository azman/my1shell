#!/bin/bash

# libmy1slack
# - written by azman@my1matrix.net
# - library functions for slackware system management

MY1_LIBNAME="libmy1slack"
MY1_LIBVERS="2012.07.00"
MY1_LIBCALL="$(basename $0 .sh)"

# determine slackware architecture, NOT machine's!
SLACKARCH=${SLACKARCH:=""}
case $SLACKARCH in
	x86) SLACKARCH="" ;;
	x86_64) SLACKARCH="64" ;;
	*)
		SLACKARCH=$(find / -maxdepth 1 -name 'lib64' -type d 2>/dev/null)
		if [[ "$SLACKARCH" == "/lib64" ]] ; then SLACKARCH="64"
		else SLACKARCH="" ; fi ;;
esac
# get slackware release version - not sure if current is supported!
SLACKNAME=${SLACKNAME:="slackware$SLACKARCH"}
SLACKVERS=${SLACKVERS:=""}
if [[ "$SLACKVERS" == "" ]]; then
	SLACKVERS=$(cat /etc/slackware-version)
	SLACKVERS=${SLACKVERS#Slackware }
	SLACKVMAJ=${SLACKVERS%%.*}
	SLACKVMIN=${SLACKVERS#*.}
	[[ "${SLACKVMIN//./}" != "$SLACKVMIN" ]] && SLACKVMIN=${SLACKVMIN%%.*}
	SLACKVERS=${SLACKVMAJ}.${SLACKVMIN}
fi
# find slackware tree
SLACKRELEASE=${SLACKRELEASE:="$SLACKNAME-$SLACKVERS"}
SLACKROOTDIR=${SLACKROOTDIR:=""}
if [[ "$SLACKROOTDIR" == "" ]]; then
	SLACKFIND=${SLACKFIND:="/home"} # default path to look for
	SLACKROOTDIR=$(find $SLACKFIND -maxdepth 3 -name "$SLACKRELEASE" -type d 2>/dev/null)
	SLACKROOTDIR=${SLACKROOTDIR%"/$SLACKRELEASE"}
fi
SLACKRELPATH=${SLACKRELPATH:="${SLACKROOTDIR}/${SLACKRELEASE}"}
SLACKPKGPATH=${SLACKPKGPATH:="${SLACKRELPATH}/slackware$SLACKARCH"}
SLACKEXTPATH=${SLACKEXTPATH:="${SLACKRELPATH}/extra"}
SLACKPKGFILE=${SLACKPKGFILE:="${SLACKPKGPATH}/PACKAGES.TXT"}
SLACKEXTFILE=${SLACKEXTFILE:="${SLACKEXTPATH}/PACKAGES.TXT"}
SLACKINSTLOG="/var/log/packages"

function tag_msg()
{
	local msg_tag=$1 ; shift
	local col_tag=$1 ; shift
	local out_err="yes"
	[[ "$1" == "--stdout" ]] && out_err="" && shift
	[[ "$1" == "--no-tag" ]] && msg_tag="" && shift
	if [[ "$out_err" == "yes" ]]; then
		echo -ne "\033[1;${col_tag}m${msg_tag}\033[0;${col_tag}m $1\033[0m" 1>&2
	else
		echo -ne "\033[1;${col_tag}m${msg_tag}\033[0;${col_tag}m $1\033[0m"
	fi
}

function error_msg()
{
	local error_tag="[ERROR]"
	local color_tag="31"
	tag_msg "$error_tag" "$color_tag" "$@"
}

function error_exit()
{
	error_msg "--no-tag" "\n"
	error_msg "$@ Aborting!\n\n"
	exit 1
}

function debug_msg()
{
	local debug_tag="[DEBUG]"
	local color_tag="33"
	tag_msg "$check_tag" "$color_tag" "$@"
}

function check_msg()
{
	local check_tag="[CHECK]"
	local color_tag="34"
	tag_msg "$check_tag" "$color_tag" "$@"
}

function warn_msg()
{
	local warn0_tag="[WARN]"
	local color_tag="33"
	tag_msg "$warn0_tag" "$color_tag" "$@"
}

function info_msg()
{
	local info0_tag="[INFO]"
	local color_tag="32"
	tag_msg "$info0_tag" "$color_tag" "--stdout" "$@"
}

if [[ "$MY1_DEBUG" == "YES" ]]; then
	echo
	debug_msg "my1slack Library Name is $MY1_LIBNAME"
	debug_msg "my1slack Library Version is $MY1_LIBVERS"
	debug_msg "System machine is $(uname -m)"
	debug_msg "Slack Version is $(cat /etc/slackware-version)"
	debug_msg "Slack Release is $SLACKRELEASE"
	debug_msg "Slack Tree is at $SLACKROOTDIR"
	debug_msg "Command Call '$MY1_LIBCALL'"
fi

function find_binary()
{
	local chk_exec=$1
	local set_exec=$(which $chk_exec 2>/dev/null)
	echo -n $set_exec
	[[ "$msg_fail" == "" ]] && msg_fail="Binary '$chk_exec' not found!"
	[[ "$set_exec" == "" ]] && error_exit "$msg_fail"
}

function must_have_path()
{
	local chk_path=$1 ; shift
	local msg_fail=$@
	[[ "$msg_fail" == "" ]] && msg_fail="Path '$chk_path' not found!"
	[[ ! -d "$chk_path"  ]] && error_exit "$msg_fail"
}

function must_be_root()
{
	[[ $UID -ne 0 ]] && error_exit "Must run as root!"
}

function get_pkg_info()
{
	# get pkg info from name (i.e. filename minus extension!)
	local pkg_name pkg_vers pkg_arch pkg_extd pkg_temp
	local pkg_base="$1"
	pkg_extd="${pkg_base##*-}"
	pkg_temp="${pkg_base%-${pkg_extd}}"
	pkg_arch="${pkg_temp##*-}"
	pkg_temp="${pkg_temp%-${pkg_arch}}"
	pkg_vers="${pkg_temp##*-}"
	pkg_name="${pkg_temp%-${pkg_vers}}"
	echo -n "$pkg_name $pkg_vers $pkg_arch $pkg_extd"
}

function get_pathpack()
{
	# make a package list from custom path
	local pkg_list=""
	local pkg_pack="$(cd $1;pwd)"
	if [[ -d $pkg_pack ]]; then
		cd $pkg_pack
		for pkg_file in *.t[gx]z; do
			pkg_list="$pkg_list ${pkg_file%.t[gx]z}" # trim extension
		done
		cd - >/dev/null
	fi
	echo -n "$pkg_list"
}

function get_softpack()
{
	# make a package list from official software set (e.g. a,d,l...)
	echo -n "$(get_pathpack ${SLACKPKGPATH}/$1)"
}

function comp_package()
{
	# compare 2 packages (based on filename), returns 0 if the same!
	local pkg1_file="$1"
	local pkg2_file="$2"
	local pkg_temp
	local pkg1_name pkg1_vers pkg1_arch pkg1_extd
	local pkg2_name pkg2_vers pkg2_arch pkg2_extd
	# extract info components
	pkg_temp=($(get_pkg_info $pkg1_file))
	pkg1_name="${pkg_temp[0]}"
	pkg1_vers="${pkg_temp[1]}"
	pkg1_arch="${pkg_temp[2]}"
	pkg1_extd="${pkg_temp[3]}"
	pkg_temp=($(get_pkg_info $pkg2_file))
	pkg2_name="${pkg_temp[0]}"
	pkg2_vers="${pkg_temp[1]}"
	pkg2_arch="${pkg_temp[2]}"
	pkg2_extd="${pkg_temp[3]}"
	# do compare!
	[[ "$pkg1_name" == "$pkg2_name" ]] || return 1
	[[ "$pkg1_vers" == "$pkg2_vers" ]] || return 2
	[[ "$pkg1_arch" == "$pkg2_arch" ]] || return 3
	[[ "$pkg1_extd" == "$pkg2_extd" ]] || return 4
	# okay.. the same!
	return 0
}

function pkg_db_package()
{
	# get package info from mirror tree and put into db!
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_info pkg_long pkg_file pkg_path
	local pkg_size pkg_full pkg_base pkg_desc
	local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_test=$(cat $SLACKPKGFILE | grep -e "$pkg_temp" -A3)
	if [[ "$pkg_test" = "" ]] ; then # look in extra, if available
		[[ ! -f $SLACKEXTFILE ]] && return 1
		pkg_test=$(cat $SLACKEXTFILE | grep -e "$pkg_temp" -A3)
		[[ "$pkg_test" = "" ]] && return 1
	fi
	[[ "$pkg_flag" == "--check" ]] && echo -n "$pkg_name" && return 0
	# extract info
	pkg_file=$(echo "$pkg_test" | grep 'PACKAGE NAME')
	pkg_file="${pkg_file##* }"
	pkg_path=$(echo "$pkg_test" | grep 'PACKAGE LOCATION')
	pkg_path="${pkg_path##*./}"
	pkg_size=$(echo "$pkg_test" | grep 'PACKAGE SIZE (compressed)')
	pkg_size="${pkg_size%% K*}"
	pkg_size="${pkg_size##* }K"
	pkg_full=$(echo "$pkg_test" | grep 'PACKAGE SIZE (uncompressed)')
	pkg_full="${pkg_full%% K*}"
	pkg_full="${pkg_full##* }K"
	pkg_base=${pkg_file%.t[gx]z}
	[[ "$pkg_flag" == "--all" ]] &&
		pkg_desc=$(grep -e "^$pkg_name:" $SLACKPKGFILE)
	# build db
	eval pkgfile_${pkg_name//[-.]/_}="$pkg_file"
	eval pkgpath_${pkg_name//[-.]/_}="$pkg_path"
	eval pkgsize_${pkg_name//[-.]/_}="$pkg_size"
	eval pkgfull_${pkg_name//[-.]/_}="$pkg_full"
	eval pkgbase_${pkg_name//[-.]/_}="$pkg_base"
	eval pkgdesc_${pkg_name//[-.]/_}='$pkg_desc'
	# done!
	return 0
}

function pkg_db_install()
{
	# get package info from current installation and put into db!
	# CHECKED20120324: HAVE TO DO THIS IN DIFFERENT FUNCTION FROM ABOVE!
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_base pkg_file pkg_path
	local pkg_size pkg_full
	local pkg_temp="\<${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_test=$(ls $SLACKINSTLOG | grep -e "$pkg_temp")
	[[ "$pkg_test" = "" ]] && return 1
	[[ "$pkg_flag" == "--check" ]] && echo -n "$pkg_name" && return 0
	# extract info
	pkg_temp="$SLACKINSTLOG/$pkg_test"
	pkg_test=$(cat $pkg_temp | grep -e "^PACKAGE NAME:" -A3)
	pkg_base=$(echo "$pkg_test" | grep 'PACKAGE NAME')
	pkg_base="${pkg_base##* }"
	pkg_file=$(echo "$pkg_test" | grep 'PACKAGE LOCATION')
	pkg_file="${pkg_file##* }"
	pkg_path=${pkg_file%${pkg_base}.t[gx]z}
	[[ "$pkg_path" == "" ]] || pkg_file=${pkg_file##${pkg_path}}
	pkg_size=$(echo "$pkg_test" | grep -e "^COMPRESSED PACKAGE SIZE")
	pkg_size="${pkg_size##* }"
	pkg_full=$(echo "$pkg_test" | grep -e "^UNCOMPRESSED PACKAGE SIZE")
	pkg_full="${pkg_full##* }"
	[[ "$pkg_flag" == "--all" ]] && pkg_desc=$(grep "$pkg_name:" $pkg_temp)
	# build db
	eval pkgfile_${pkg_name//[-.]/_}="$pkg_file"
	eval pkgpath_${pkg_name//[-.]/_}="$pkg_path"
	eval pkgsize_${pkg_name//[-.]/_}="$pkg_size"
	eval pkgfull_${pkg_name//[-.]/_}="$pkg_full"
	eval pkgbase_${pkg_name//[-.]/_}="$pkg_base"
	eval pkgdesc_${pkg_name//[-.]/_}='$pkg_desc'
	# done!
	return 0
}

function find_infile()
{
	# get package entry from a file
	local pkg_base="$1"
	local pkg_test="$2"
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*$"
	local pkg_file=$(cat $pkg_base | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_inpath()
{
	# get package entry from file(s) in a path (filename)
	local pkg_test="$1"
	local tgt_path="$2"
	[[ -d "$tgt_path" ]] || tgt_path="."
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_file=$(find $tgt_path -name *.t[gx]z | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_install()
{
	# get package entry from current installation
	local pkg_test="$1"
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*$"
	local pkg_file=$(ls $SLACKINSTLOG | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_package()
{
	# get package entry from mirror tree
	local pkg_test="$1"
	local pkg_temp="\<PACKAGE NAME:  ${pkg_test}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_file=$(cat $SLACKPKGFILE | grep -e "$pkg_temp")
	[[ "$pkg_file" == "" ]] && [[ -f $SLACKEXTFILE ]] &&
		pkg_file=$(cat $SLACKEXTFILE | grep -e "$pkg_temp")
	[[ "$pkg_file" == "" ]] && return
	pkg_file="${pkg_file##* }"
	pkg_file="${pkg_file%.t[gx]z}"
	echo -n "$pkg_file"
}

function show_info()
{
	# print package info (including desc entry!)
	local pkg_test="$1"
	local pkg_path pkg_size pkg_full
	local pkg_stat pkg_flag pkg_base
	local pkg_temp pkg_desc pkg_log pkg_file
	local pkg_name pkg_vers pkg_arch pkg_extd
	# extracting information
	pkg_temp="pkgbase_${pkg_test//-/_}"
	[[ -z "${!pkg_temp}" ]] && return
	pkg_base="${!pkg_temp}"
	pkg_temp=($(get_pkg_info $pkg_base))
	pkg_name="${pkg_temp[0]}"
	pkg_vers="${pkg_temp[1]}"
	pkg_arch="${pkg_temp[2]}"
	pkg_extd="${pkg_temp[3]}"
	pkg_temp="pkgfile_${pkg_test//-/_}"
	pkg_file="${!pkg_temp}"
	pkg_temp="pkgpath_${pkg_test//-/_}"
	pkg_path="${!pkg_temp}"
	pkg_temp="pkgsize_${pkg_test//-/_}"
	pkg_size="${!pkg_temp}"
	pkg_temp="pkgfull_${pkg_test//-/_}"
	pkg_full="${!pkg_temp}"
	pkg_temp="pkgdesc_${pkg_test//-/_}"
	pkg_desc="${!pkg_temp}"
	[[ "$pkg_path" == "" ]] && pkg_path="Unknown"
	[[ "$pkg_size" == "" ]] && pkg_size="Unknown"
	[[ "$pkg_full" == "" ]] && pkg_full="Unknown"
	pkg_flag=""
	[[ "$(find_install $pkg_name)" == "" ]] && pkg_flag="NOT "
		pkg_stat=""
	[[ "$(find_package $pkg_name)" == "" ]] && pkg_stat=" (ALIEN!)"
	# do the printing
	local title="PACKAGE <$pkg_name> - BEGIN"
	local trail="PACKAGE <$pkg_name> - END"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "$title"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "FILE               : ${pkg_file}${pkg_stat}"
	echo "LOCATION           : $pkg_path"
	echo "VERSION            : $pkg_vers"
	echo "ARCHITECTURE       : $pkg_arch"
	echo "BUILD TAG          : $pkg_extd"
	echo "SIZE (Compressed)  : $pkg_size"
	echo "SIZE (Uncompressed): $pkg_full"
	echo "INSTALL STATUS     : ${pkg_flag}INSTALLED"
	[[ "$pkg_desc" != "" ]] &&
	echo "DESCRIPTION        : " && echo -e "$pkg_desc"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	echo "$trail"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo ; echo
}

function format_text()
{
	# oooh! blinking color text!
	# format is "\033[<attr>;<textcolor>;<backcolor>m" \033 = \e (ESC char)
	local ends="\033[0m"
	# attributes
	local bold="1" # bright (bold on xterm?)
	local dim="2" # dim
	local uline="4"
	local blink="5" # doesn't work on xterm (only real console!)
	local reverse="7"
	local hidden="8"
	# text colors
	local black="30" # for background Xm + 10m
	local red="31"
	local green="32"
	local yellow="33"
	local blue="34"
	local magenta="35"
	local cyan="36"
	local white="37"
	local default="39"
	# check options
	local attr color text
	while [[ "$1" != "" ]] ; do
		case "$1" in
		--reset) attr="0" ;;
		--bold) attr=$bold ;;
		--blink) attr=$blink ;;
		--color)
			shift; color="$1"
			case "$color" in
				black) color="$black" ;;
				red) color="$red" ;;
				green) color="$green" ;;
				yellow) color="$yellow" ;;
				blue) color="$blue" ;;
				magenta) color="$magenta" ;;
				cyan) color="$cyan" ;;
				white) color="$white" ;;
				*) color="$default" ;;
			esac
			;;
		*)
			[[ "$MY1_DEBUG" == "YES" ]] &&
				echo "Attribute: $attr, Color: $color"
			if [[ "$color" != "" ]] ; then
				[[ "$attr" == "" ]] && attr="0"
				color="\033[${attr};${color}m"
			else
				[[ "$attr" != "" ]] &&
					color="\033[${attr}m"
			fi
			if [[ "$color" == "" ]] ;  then
				text="${text}${1} "
			else
				text="${text}${color}${1}${ends} "
			fi
			attr="" color=""
			;;
		esac
		shift
	done
	echo -e "$text"
}
