#!/bin/bash

# libmy1slack
# - written by azman@my1matrix.net
# - library functions for slackware system management

MY1_LIBNAME="libmy1slack"
MY1_LIBVERS="2012.03.00"
MY1_LIBCALL="$(basename $0 .sh)"

# determine slackware architecture, NOT machine's!
SLACKARCH=${SLACKARCH:=""}
case $SLACKARCH in
	x86) SLACKARCH="" ;;
	x86_64) SLACKARCH="64" ;;
	*)
		SLACKARCH=$(find / -maxdepth 1 -name 'lib64' -type d 2>/dev/null)
		if [[ "$SLACKARCH" == "/lib64" ]] ; then SLACKARCH="64"
		else SLACKARCH="" ; fi ;;
esac
# get slackware release version - not sure if current is supported!
SLACKNAME=${SLACKNAME:="slackware$SLACKARCH"}
SLACKVERS=${SLACKVERS:=""}
if [[ "$SLACKVERS" == "" ]]; then
	SLACKVERS=$(cat /etc/slackware-version) # always in the form of "Slackware x.x.x"?
	SLACKVERS=${SLACKVERS#Slackware }
	SLACKVERS=${SLACKVERS//${SLACKVERS#*.*.}/}
	SLACKVERS=${SLACKVERS:0:${#SLACKVERS}-1}
fi
# find slackware tree
SLACKRELEASE=${SLACKRELEASE:="$SLACKNAME-$SLACKVERS"}
SLACKROOTDIR=${SLACKROOTDIR:=""}
if [[ "$SLACKROOTDIR" == "" ]]; then
	SLACKFIND=${SLACKFIND:="/home"} # default path to look for
	SLACKROOTDIR=$(find $SLACKFIND -maxdepth 3 -name "$SLACKRELEASE" -type d 2>/dev/null)
	SLACKROOTDIR=${SLACKROOTDIR%"/$SLACKRELEASE"}
fi
SLACKRELPATH=${SLACKRELPATH:="${SLACKROOTDIR}/${SLACKRELEASE}"}
SLACKPKGPATH=${SLACKPKGPATH:="${SLACKRELPATH}/slackware$SLACKARCH"}
SLACKEXTPATH=${SLACKEXTPATH:="${SLACKRELPATH}/extra"}
SLACKPKGFILE=${SLACKPKGFILE:="${SLACKPKGPATH}/PACKAGES.TXT"}
SLACKEXTFILE=${SLACKEXTFILE:="${SLACKEXTPATH}/PACKAGES.TXT"}
SLACKINSTLOG="/var/log/packages"

if [[ "$MY1_DEBUG" == "YES" ]]; then
	echo
	echo "[DEBUG-$$] ==> my1slack Library Name is $MY1_LIBNAME"
	echo "[DEBUG-$$] ==> my1slack Library Version is $MY1_LIBVERS"
	echo "[DEBUG-$$] ==> Slack Release is $SLACKRELEASE"
	echo "[DEBUG-$$] ==> Slack Tree is at $SLACKROOTDIR"
	echo "[DEBUG-$$] ==> Command Call '$MY1_LIBCALL'"
fi

function must_be_root()
{
	[[ $UID -ne 0 ]] && echo -e "Abort: must run as root!\n" && exit 1
}

function get_pkg_info()
{
	# get pkg info from name (i.e. filename minus extension!)
	local pkg_name pkg_vers pkg_arch pkg_extd pkg_temp
	local pkg_base="$1"
	pkg_extd="${pkg_base##*-}"
	pkg_temp="${pkg_base%-${pkg_extd}}"
	pkg_arch="${pkg_temp##*-}"
	pkg_temp="${pkg_temp%-${pkg_arch}}"
	pkg_vers="${pkg_temp##*-}"
	pkg_name="${pkg_temp%-${pkg_vers}}"
	echo -n "$pkg_name $pkg_vers $pkg_arch $pkg_extd"
}

function get_pathpack()
{
	# make a package list from custom path
	local pkg_list=""
	local pkg_pack="$(cd $1;pwd)"
	if [[ -d $pkg_pack ]]; then
		cd $pkg_pack
		for pkg_file in *.t[gx]z; do
			pkg_list="$pkg_list ${pkg_file%.t[gx]z}" # trim extension
		done
		cd - >/dev/null
	fi
	echo -n "$pkg_list"
}

function get_softpack()
{
	# make a package list from official software set (e.g. a,d,l...)
	echo -n "$(get_pathpack ${SLACKPKGPATH}/$1)"
}

function comp_package()
{
	# compare 2 packages (based on filename), returns 0 if the same!
	local pkg1_file="$1"
	local pkg2_file="$2"
	local pkg_temp
	local pkg1_name pkg1_vers pkg1_arch pkg1_extd
	local pkg2_name pkg2_vers pkg2_arch pkg2_extd
	# extract info components
	pkg_temp=($(get_pkg_info $pkg1_file))
	pkg1_name="${pkg_temp[0]}"
	pkg1_vers="${pkg_temp[1]}"
	pkg1_arch="${pkg_temp[2]}"
	pkg1_extd="${pkg_temp[3]}"
	pkg_temp=($(get_pkg_info $pkg2_file))
	pkg2_name="${pkg_temp[0]}"
	pkg2_vers="${pkg_temp[1]}"
	pkg2_arch="${pkg_temp[2]}"
	pkg2_extd="${pkg_temp[3]}"
	# do compare!
	[[ "$pkg1_name" == "$pkg2_name" ]] || return 1
	[[ "$pkg1_vers" == "$pkg2_vers" ]] || return 2
	[[ "$pkg1_arch" == "$pkg2_arch" ]] || return 3
	[[ "$pkg1_extd" == "$pkg2_extd" ]] || return 4
	# okay.. the same!
	return 0
}

function pkg_db_package()
{
	# get package info from mirror tree and put into db!
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_info pkg_long pkg_file pkg_path
	local pkg_size pkg_full pkg_base pkg_desc
	local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_test=$(cat $SLACKPKGFILE | grep -e "$pkg_temp" -A3)
	if [[ "$pkg_test" = "" ]] ; then # look in extra, if available
		[[ ! -f $SLACKEXTFILE ]] && return 1
		pkg_test=$(cat $SLACKEXTFILE | grep -e "$pkg_temp" -A3)
		[[ "$pkg_test" = "" ]] && return 1
	fi
	[[ "$pkg_flag" == "--check" ]] && echo -n "$pkg_name" && return 0
	# extract info
	pkg_file=$(echo "$pkg_test" | grep 'PACKAGE NAME')
	pkg_file="${pkg_file##* }"
	pkg_path=$(echo "$pkg_test" | grep 'PACKAGE LOCATION')
	pkg_path="${pkg_path##*./}"
	pkg_size=$(echo "$pkg_test" | grep 'PACKAGE SIZE (compressed)')
	pkg_size="${pkg_size%% K*}"
	pkg_size="${pkg_size##* }K"
	pkg_full=$(echo "$pkg_test" | grep 'PACKAGE SIZE (uncompressed)')
	pkg_full="${pkg_full%% K*}"
	pkg_full="${pkg_full##* }K"
	pkg_base=${pkg_file%.t[gx]z}
	[[ "$pkg_flag" == "--all" ]] &&
		pkg_desc=$(grep -e "^$pkg_name:" $SLACKPKGFILE)
	# build db
	eval pkgfile_${pkg_name//[-.]/_}="$pkg_file"
	eval pkgpath_${pkg_name//[-.]/_}="$pkg_path"
	eval pkgsize_${pkg_name//[-.]/_}="$pkg_size"
	eval pkgfull_${pkg_name//[-.]/_}="$pkg_full"
	eval pkgbase_${pkg_name//[-.]/_}="$pkg_base"
	eval pkgdesc_${pkg_name//[-.]/_}='$pkg_desc'
	# done!
	return 0
}

function pkg_db_install()
{
	# get package info from current installation and put into db!
	# CHECKED20120324: HAVE TO DO THIS IN DIFFERENT FUNCTION FROM ABOVE!
	local pkg_name="$1"
	local pkg_flag="$2"
	local pkg_base pkg_file pkg_path
	local pkg_size pkg_full
	local pkg_temp="\<${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_test=$(ls $SLACKINSTLOG | grep -e "$pkg_temp")
	[[ "$pkg_test" = "" ]] && return 1
	[[ "$pkg_flag" == "--check" ]] && echo -n "$pkg_name" && return 0
	# extract info
	pkg_temp="$SLACKINSTLOG/$pkg_test"
	pkg_test=$(cat $pkg_temp | grep -e "^PACKAGE NAME:" -A3)
	pkg_base=$(echo "$pkg_test" | grep 'PACKAGE NAME')
	pkg_base="${pkg_base##* }"
	pkg_file=$(echo "$pkg_test" | grep 'PACKAGE LOCATION')
	pkg_file="${pkg_file##* }"
	pkg_path=${pkg_file%${pkg_base}.t[gx]z}
	[[ "$pkg_path" == "" ]] || pkg_file=${pkg_file##${pkg_path}}
	pkg_size=$(echo "$pkg_test" | grep -e "^COMPRESSED PACKAGE SIZE")
	pkg_size="${pkg_size##* }"
	pkg_full=$(echo "$pkg_test" | grep -e "^UNCOMPRESSED PACKAGE SIZE")
	pkg_full="${pkg_full##* }"
	[[ "$pkg_flag" == "--all" ]] && pkg_desc=$(grep "$pkg_name:" $pkg_temp)
	# build db
	eval pkgfile_${pkg_name//[-.]/_}="$pkg_file"
	eval pkgpath_${pkg_name//[-.]/_}="$pkg_path"
	eval pkgsize_${pkg_name//[-.]/_}="$pkg_size"
	eval pkgfull_${pkg_name//[-.]/_}="$pkg_full"
	eval pkgbase_${pkg_name//[-.]/_}="$pkg_base"
	eval pkgdesc_${pkg_name//[-.]/_}='$pkg_desc'
	# done!
	return 0
}

function find_infile()
{
	# get package entry from a file
	local pkg_base="$1"
	local pkg_test="$2"
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*$"
	local pkg_file=$(cat $pkg_base | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_inpath()
{
	# get package entry from file(s) in a path (filename)
	local pkg_test="$1"
	local tgt_path="$2"
	[[ -d "$tgt_path" ]] || tgt_path="."
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_file=$(find $tgt_path -name *.t[gx]z | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_install()
{
	# get package entry from current installation
	local pkg_test="$1"
	local pkg_temp="\<${pkg_test}-[^-]*-[^-]*-[^-]*$"
	local pkg_file=$(ls $SLACKINSTLOG | grep -e "$pkg_temp")
	echo -n "$pkg_file"
}

function find_package()
{
	# get package entry from mirror tree
	local pkg_test="$1"
	local pkg_temp="\<PACKAGE NAME:  ${pkg_test}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_file=$(cat $SLACKPKGFILE | grep -e "$pkg_temp")
	[[ "$pkg_file" == "" ]] &&
		pkg_file=$(cat $SLACKEXTFILE | grep -e "$pkg_temp")
	[[ "$pkg_file" == "" ]] && return
	pkg_file="${pkg_file##* }"
	pkg_file="${pkg_file%.t[gx]z}"
	echo -n "$pkg_file"
}

function show_info()
{
	# print package info (including desc entry!)
	local pkg_test="$1"
	local pkg_path pkg_size pkg_full
	local pkg_stat pkg_flag pkg_base
	local pkg_temp pkg_desc pkg_log pkg_file
	local pkg_name pkg_vers pkg_arch pkg_extd
	# extracting information
	pkg_temp="pkgbase_${pkg_test//-/_}"
	[[ -z "${!pkg_temp}" ]] && return
	pkg_base="${!pkg_temp}"
	pkg_temp=($(get_pkg_info $pkg_base))
	pkg_name="${pkg_temp[0]}"
	pkg_vers="${pkg_temp[1]}"
	pkg_arch="${pkg_temp[2]}"
	pkg_extd="${pkg_temp[3]}"
	pkg_temp="pkgfile_${pkg_test//-/_}"
	pkg_file="${!pkg_temp}"
	pkg_temp="pkgpath_${pkg_test//-/_}"
	pkg_path="${!pkg_temp}"
	pkg_temp="pkgsize_${pkg_test//-/_}"
	pkg_size="${!pkg_temp}"
	pkg_temp="pkgfull_${pkg_test//-/_}"
	pkg_full="${!pkg_temp}"
	pkg_temp="pkgdesc_${pkg_test//-/_}"
	pkg_desc="${!pkg_temp}"
	[[ "$pkg_path" == "" ]] && pkg_path="Unknown"
	[[ "$pkg_size" == "" ]] && pkg_size="Unknown"
	[[ "$pkg_full" == "" ]] && pkg_full="Unknown"
	pkg_flag=""
	[[ "$(find_install $pkg_name)" == "" ]] && pkg_flag="NOT "
		pkg_stat=""
	[[ "$(find_package $pkg_name)" == "" ]] && pkg_stat=" (ALIEN!)"
	# do the printing
	local title="PACKAGE <$pkg_name> - BEGIN"
	local trail="PACKAGE <$pkg_name> - END"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "$title"
	for (( a=0;a<${#title};a++ )) ; do echo -n "-"; done ; echo
	echo "FILE               : ${pkg_file}${pkg_stat}"
	echo "LOCATION           : $pkg_path"
	echo "VERSION            : $pkg_vers"
	echo "ARCHITECTURE       : $pkg_arch"
	echo "BUILD TAG          : $pkg_extd"
	echo "SIZE (Compressed)  : $pkg_size"
	echo "SIZE (Uncompressed): $pkg_full"
	echo "INSTALL STATUS     : ${pkg_flag}INSTALLED"
	[[ "$pkg_desc" != "" ]] &&
	echo "DESCRIPTION        : " && echo -e "$pkg_desc"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo
	echo "$trail"
	for (( a=0;a<${#trail};a++ )) ; do echo -n "-"; done ; echo ; echo
}

function format_text()
{
	# oooh! blinking color text!
	local mark="\033[0m"
	local begin=$mark
	local end=$mark
	local bold="\033[1m"
	local uline="\033[4m"
	local blink="\033[5m"
	local inverse="\033[7m"
	local concealed="\033[8m"
	local color=""
	local black="\033[30m"
	local red="\033[31m"
	local green="\033[32m"
	local yellow="\033[33m"
	local blue="\033[34m"
	local magenta="\033[35m"
	local cyan="\033[36m"
	local white="\033[37m"
	local text=""
	# check options
	while [ "$1" != "" ]; do
		case "$1" in
		--bold) begin="${begin}${bold}" ;;
		--blink) begin="${begin}${blink}" ;;
		--color)
			shift; color="$1"
			case "$color" in
				black) color="$black" ;;
				red) color="$red" ;;
				green) color="$green" ;;
				yellow) color="$yellow" ;;
				blue) color="$blue" ;;
				magenta) color="$magenta" ;;
				cyan) color="$cyan" ;;
				white) color="$white" ;;
				*) color="$black" ;;
			esac
			begin="${begin}${color}";;
		*)
			text="${begin}${1}${end}"; begin=$mark;;
		esac
		shift
	done	
	echo -e "$text"
}

function test_param()
{
	# just testing...
	local test="$@"


	echo "Param count: $#"
	echo "Param \$@ is $@"
	echo "Param \$* is $*"
	echo "Param \$1 is $1"
	echo "Param \$test is $test"
	shift
	echo "Params shifted by 1!"
	# $* similar to $@, but use IFS as separator
	test="$@"
	echo "Param count: $#"
	echo "Param \$@ is $@"
	echo "Param \$* is $*"
	echo "Param \$1 is $1"
	echo "Param \$test is $test"
	shift
	echo "Param \$\$ is $$"
}
