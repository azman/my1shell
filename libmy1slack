#!/bin/bash

# libmy1slack
# - written by azman@my1matrix.org
# - library functions for slackware system management
#   = requires libmy1file

MY1_LIBNAME="libmy1slack"
MY1_LIBVERS="2019.11.00"
MY1_LIBCALL=`basename $0 .sh`

# slack info gathering

find_slackname()
{
	local path=$1
	local file="/bin/bash"
	# make sure path is valid
	[ "$path" == "/" ] && path=""
	[ "$path" != "" -a ! -d "$path" ] && return
	# make sure file is valid
	[ ! -f "${path}${file}" ] && return
	# get slackware arch... NOT machine arch!
	local arch=`file ${path}${file} | sed -e "s/^.*: \([^,]*\),.*$/\1/"`
	arch=`echo $arch | cut -d' ' -f2`
	if [ "$arch" = "64-bit" ] ; then arch="64"
	else arch="" ; fi
	echo -n slackware${arch}
}

find_slackvers()
{
	local path=$1
	local file="/etc/slackware-version"
	# make sure path is valid
	[ "$path" == "/" ] && path=""
	[ "$path" != "" -a ! -d "$path" ] && echo -n "" && return
	# make sure file is valid
	[ ! -f "${path}${file}" ] && echo -n "" && return
	# get slackware version
	local vers=`cat ${path}${file} | sed 's/Slackware //'`
	echo -n $vers
}

find_slacktree()
{
	local name=$1
	[ -z "$name" ] && name=`find_slackname`"-"`find_slackvers`
	local path=$2
	[ -z "$path" ] && path="/home" # default path to look for
	[ ! -d "$path" ] && return
	local opts="-maxdepth 3 -name $name -type d"
	local tree=`find $path $opts 2>/dev/null`
	echo -n $tree
}

# find current system info
# - sets SLACK{NAME,VERS,FULL,TREE,ROOT,PACK,LOGS} variables

call_setup()
{
	local sys_root=$1
	local pkg_home=$2
	[ -z "$SLACKNAME" ] && SLACKNAME=`find_slackname $sys_root`
	[ -z "$SLACKVERS" ] && SLACKVERS=`find_slackvers $sys_root`
	SLACKFULL="$SLACKNAME-$SLACKVERS"
	SLACKTREE=`find_slacktree $SLACKFULL $pkg_home`
	[ -d "$SLACKTREE" ] &&
		SLACKROOT=`dirname $SLACKTREE` && SLACKPACK=$SLACKTREE/$SLACKNAME
	SLACKLOGS="/var/log/packages"
}

# slack management functions

get_pkg_info()
{
	# get pkg info from basename (i.e. filename minus extension!)
	local pkg_name pkg_vers pkg_arch pkg_extd
	local pkg_base="$1"
	pkg_extd=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_base=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	pkg_arch=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_base=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	pkg_vers=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\2/'`
	pkg_name=`echo $pkg_base | sed 's/\(.*\)-\(.*\)/\1/'`
	echo -n "$pkg_name $pkg_vers $pkg_arch $pkg_extd"
}

get_pathpack()
{
	# make a package list from custom path
	local pkg_path=$1
	local pkg_list=""
	if [ -d "$pkg_path" ]; then
		cd $pkg_path
		for pkg_file in *.t[gx]z; do
			[ ! -f $pkg_file ] && continue
			pkg_temp=`echo $pkg_file | sed 's/\.t[xg]z//'`
			pkg_list="${pkg_list}${pkg_temp} "
		done
		cd - >/dev/null
	fi
	echo -n "$pkg_list"
}

get_packpath()
{
	# get package file from a path
	local pkg_path=$1
	local pkg_name=$2
	[ ! -d $pkg_path ] && return
	local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z$"
	local pkg_test=`ls $pkg_path | grep -e "$pkg_temp"`
	echo -n "$pkg_test"
}

get_packfind()
{
	# find package file (full path) from a path tree
	local path=$1
	local name=$2
	[ ! -d "$path" ] && return
	path=`cd $path;pwd` # just in case
	local temp="/${name}-[^-]*-[^-]*-[^-]*\.t[gx]z$"
	local test=`find $path -type f -name "*.t[gx]z" | grep -e "$temp"`
	echo -n "$test"
}

get_pathsoft()
{
	# make a package list from official software set (e.g. a,d,l...)
	local pkg_pack=$1 # slackpack
	local pkg_soft=$2
	echo -n `get_pathpack $pkg_pack/$pkg_soft`
}

get_packsoft()
{
	# get official software set for given package
	local pkg_pack=$1 # slackpack
	local pkg_name=$2
	local pkg_soft="z" # default unknown set
	for tmp_path in $pkg_pack/* ; do
		[ ! -d $tmp_path ] && continue
		local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z$"
		local pkg_test=`ls $tmp_path | grep -e "$pkg_temp"`
		if [ "$pkg_test" != "" ] ; then
			pkg_soft=`basename ${tmp_path}`
			break
		fi
	done
	echo -n "$pkg_soft"
}

# review this... only used in slackview?
pkg_compare()
{
	# compare 2 package basenames, returns non-zero if different!
	local pkg1_base=$1
	local pkg2_base=$2
	local pkg_temp
	local pkg1_name pkg1_vers pkg1_arch pkg1_extd
	local pkg2_name pkg2_vers pkg2_arch pkg2_extd
	# extract info components
	pkg_temp=`get_pkg_info $pkg1_base`
	pkg1_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg1_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg1_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg1_extd=`echo $pkg_temp | cut -d' ' -f4`
	pkg_temp=`get_pkg_info $pkg2_base`
	pkg2_name=`echo $pkg_temp | cut -d' ' -f1`
	pkg2_vers=`echo $pkg_temp | cut -d' ' -f2`
	pkg2_arch=`echo $pkg_temp | cut -d' ' -f3`
	pkg2_extd=`echo $pkg_temp | cut -d' ' -f4`
	# do compare!
	[ "$pkg1_name" == "$pkg2_name" ] || return 1
	[ "$pkg1_vers" == "$pkg2_vers" ] || return 2
	[ "$pkg1_arch" == "$pkg2_arch" ] || return 3
	[ "$pkg1_extd" == "$pkg2_extd" ] || return 4
	# okay.. the same!
	return 0
}

find_desc()
{
	# get package description from a PACKAGES.TXT file
	local pkg_name=$1
	local pkgs_txt=$2
	local pkg_desc=`grep -e "^$pkg_name:" $pkgs_txt`
	echo -n "$pkg_desc"
}

find_package_desc()
{
	# get package entry from mirror tree
	local pkg_name=$1
	local pkg_tree=$2 # slacktree OR slackpack
	local pkgs_txt=$pkg_tree/PACKAGES.TXT
	[ ! -f $pkgs_txt ] && return
	local pkg_desc=`find_desc $pkg_name $pkgs_txt`
	echo -n "$pkg_desc"
}

find_install_desc()
{
	# get package entry from current installation
	local pkg_name=$1
	local pkg_temp="\<${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local log_path="/var/log/packages"
	local pkg_test=`ls $log_path | grep -e "$pkg_temp"`
	[ "$pkg_test" = "" ] && return
	local pkgs_txt="$log_path/$pkg_test"
	local pkg_desc=`find_desc $pkg_name $pkgs_txt`
	echo -n "$pkg_desc"
}

find_info()
{
	# get package info from a PACKAGES.TXT file or /var/log/packages entry
	local pkg_name=$1
	local pkgs_txt=$2
	local pkg_pack=$3 # slackpack
	# info structure?
	local pkg_base pkg_file pkg_path pkg_size pkg_full
	# pattern search?
	#local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_temp="\s${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local pkg_test=`cat $pkgs_txt | grep -e "$pkg_temp" -A3`
	[ "$pkg_test" = "" ] && return
	# extract basic info
	local chk_name="PACKAGE NAME:"
	pkg_file=`echo "$pkg_test" | grep "^$chk_name"`
	pkg_file=`echo "$pkg_file" | sed "s/$chk_name[[:space:]]*//"`
	chk_name="PACKAGE LOCATION:"
	pkg_path=`echo "$pkg_test" | grep "^$chk_name"`
	pkg_path=`echo "$pkg_path" | sed "s/$chk_name[[:space:]]*//"`
	# check if location provided is from initial installation
	pkg_temp=`echo $pkg_path | grep "/var/log/mount/"`
	if [ "$pkg_temp" != "" ] ; then
		# yup... get path in slackware tree
		pkg_file=`basename $pkg_path`
		pkg_path=`dirname $pkg_path | sed 's|/var/log/mount/||'`
		pkg_path=${pkg_pack}/${pkg_path}
	else
		# check if relative path
		pkg_temp=`echo $pkg_path | sed 's|^\./||'`
		if [ "$pkg_path" != "$pkg_temp" ] ; then
			pkg_tree=`dirname $pkg_pack`
			pkg_path="${pkg_tree}/${pkg_temp}"
		fi
	fi
	# installed packages have package file info in location!
	pkg_base=`echo $pkg_file | sed 's/\.t[xg]z//'`
	if [ "$pkg_base" == "$pkg_file" ]; then
		pkg_file=`basename $pkg_path`
		pkg_path=`dirname $pkg_path`
	fi
	chk_name="PACKAGE SIZE (compressed): "
	pkg_size=`echo "$pkg_test" | grep "^$chk_name"`
	if [ "$pkg_size" == "" ] ; then
		chk_name="COMPRESSED PACKAGE SIZE:"
		pkg_size=`echo "$pkg_test" | grep -e "^$chk_name"`
		pkg_size=`echo "$pkg_size" | sed "s/$chk_name[[:space:]]*//"`
	else
		pkg_size=`echo "$pkg_size" | sed "s/$chk_name[[:space:]]*//"`
		pkg_size=`echo $pkg_size | sed 's/ K.*//'`"K"
	fi
	chk_name="PACKAGE SIZE (uncompressed):"
	pkg_full=`echo "$pkg_test" | grep "^$chk_name"`
	if [ "$pkg_full" == "" ] ; then
		chk_name="UNCOMPRESSED PACKAGE SIZE:"
		pkg_full=`echo "$pkg_test" | grep -e "^$chk_name"`
		pkg_full=`echo "$pkg_full" | sed "s/$chk_name[[:space:]]*//"`
	else
		pkg_full=`echo "$pkg_full" | sed "s/$chk_name[[:space:]]*//"`
		pkg_full=`echo $pkg_full | sed 's/ K.*//'`"K"
	fi
	# arrange output
	echo -n "$pkg_base $pkg_file $pkg_path $pkg_size $pkg_full"
}

find_package()
{
	# get package entry from mirror tree
	local pkg_name=$1 ; shift
	local pkg_flag=$1
	[ "$pkg_flag" == "--full" ] && shift
	local pkg_pack=$1 # slackpack
	[ ! -d $pkg_pack ] && return
	local pkg_tree=`dirname $pkg_pack`
	local pkgs_txt=$pkg_tree/PACKAGES.TXT
	local pkgs_ext=$pkg_tree/extra/PACKAGES.TXT
	local pkg_temp="\<PACKAGE NAME:  ${pkg_name}-[^-]*-[^-]*-[^-]*\.t[gx]z\>"
	local pkg_base=`cat $pkgs_txt | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && [ -r "$pkgs_ext" ] &&
		pkg_base=`cat $pkgs_ext | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && return
	pkg_base=`echo $pkg_base | sed 's/PACKAGE NAME:[[:space:]]*//'`
	pkg_base=`echo $pkg_base | sed 's|.*/||'`
	pkg_base=`echo $pkg_base | sed 's/\.t[gx]z//'`
	[ "$pkg_flag" != "--full" ] && echo -n "$pkg_base" && return
	local pkg_test=`find_info $pkg_name $pkgs_txt $pkg_pack`
	[ "$pkg_test" = "" ] && [ -r "$pkgs_ext" ] &&
		pkg_test=`find_info $pkg_name $pkgs_ext $pkg_pack`
	echo -n "$pkg_test"
}

find_package_latest()
{
	# get package entry from mirror tree
	local pkg_name=$1 ; shift
	local pkg_pack=$1 # slackpack
	[ ! -d $pkg_pack ] && return
	local pkg_tree=`dirname $pkg_pack`
	local pkgs_txt=$pkg_tree/PACKAGES.TXT
	local pkg_info=`find_info $pkg_name $pkgs_txt $pkg_pack`
	[ "$pkg_info" == "" ] && return
	local pkgs_pat=$pkg_tree/patches/PACKAGES.TXT
	local pkg_test=`find_info $pkg_name $pkgs_pat $pkg_pack`
	[ "$pkg_test" != "" ]  && pkg_info="$pkg_test PATCH"
	echo -n "$pkg_info"
}

find_install()
{
	# get package entry from current installation
	local pkg_name=$1 ; shift
	local pkg_flag=$1
	[ "$pkg_flag" == "--full" ] && shift
	local pkg_pack=$1 # slackpack
	local pkg_temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
	local log_path="/var/log/packages"
	local pkg_base=`ls $log_path | grep -e "$pkg_temp"`
	[ "$pkg_base" == "" ] && return
	[ "$pkg_flag" != "--full" ] && echo -n "$pkg_base" && return
	local pkgs_txt="$log_path/$pkg_base"
	pkg_temp=`find_info $pkg_name $pkgs_txt $pkg_pack`
	echo -n "$pkg_temp"
}

list_package_path()
{
	# get all packages in given path
	local lst_path=$1
	local log_path=$2
	# get the rest of parameters (ignored packages)
	shift ; shift
	# process all package file(s) in path
	for pkg_full in `find $lst_path -name "*.t[gx]z" -type f -maxdepth 1` ; do
		local pkg_file=`basename $pkg_full`
		local pkg_path=`dirname $pkg_full`
		# check extension first
		local pkg_exts=`echo $pkg_file | sed 's/\(.*\)\.\(.*\)$/\2/'`
		local pkg_base=`echo $pkg_file | sed 's/\(.*\)\.\(.*\)$/\1/'`
		# get particulars
		local pkg_temp=`get_pkg_info $pkg_base`
		local pkg_name=`echo $pkg_temp | cut -d' ' -f1`
		local pkg_vers=`echo $pkg_temp | cut -d' ' -f2`
		local pkg_arch=`echo $pkg_temp | cut -d' ' -f3`
		local pkg_extd=`echo $pkg_temp | cut -d' ' -f4`
		# check ignore list
		pkg_temp=`echo "$@" | grep "$pkg_name"`
		[ "$pkg_temp" != "" ] && continue
		# populate information
		chk_name="$pkg_name"
		chk_file="$pkg_full"
		chk_vers="[${pkg_vers}/${pkg_extd}]"
		# are we checking for patches? check installed version
		if [ -d "$log_path" ] ; then
			# find installed
			local pkg2temp="^${pkg_name}-[^-]*-[^-]*-[^-]*$"
			local pkg2base=`ls $log_path | grep -e "$pkg2temp"`
			[ "$pkg2base" == "" ] && continue
			pkg2temp=`get_pkg_info $pkg2base`
			local pkg2name=`echo $pkg2temp | cut -d' ' -f1`
			local pkg2vers=`echo $pkg2temp | cut -d' ' -f2`
			local pkg2arch=`echo $pkg2temp | cut -d' ' -f3`
			local pkg2extd=`echo $pkg2temp | cut -d' ' -f4`
			# skip if for different arch!
			[ "$pkg2arch" != "$pkg_arch" ] && continue
			# check version update
			if [ "$pkg2vers" == "$pkg_vers" ] &&
				[ "$pkg2extd" == "$pkg_extd" ]; then
				chk_stat="pdone"
			else
				chk_stat="check"
				chk_vers="[${pkg2vers}/${pkg2extd}($pkg2base)]->"
				chk_vers="${chk_vers}[${pkg_vers}/${pkg_extd}($pkg_base)]"
			fi
			# DEBUG echo "[DEBUG] $pkg_full" && continue
		else
			local chk_arch sys_arch="x86"
			local tmp_arch=`find_slackname`
			[ "$tmp_arch" == "slackware64" ] && sys_arch="x86_64"
			case $pkg_arch in
				i*86) chk_arch="x86" ;;
				x86) chk_arch="x86" ;;
				x86_64) chk_arch="x86_64" ;;
				noarch) chk_arch="$sys_arch" ;;
				*) chk_arch="" ;;
			esac
			# DEBUG echo "[DEBUG] $pkg_full '$chk_arch'/'$sys_arch'"
			[ "$chk_arch" != "$sys_arch" ] && continue
			chk_stat="nlist"
		fi
		echo -n "$chk_name:$chk_stat:$chk_file:$chk_vers;"
	done
}

list_patches()
{
	local chk_root sys_name sys_vers sys_tree
	local chk_path="/home/share"
	local chk_skip chk_more chk_temp
	while [ "$1" != "" ]; do
		case $1 in
			--tree)
				shift
				[ -d "$1" ] && sys_tree=`cd $1;pwd`
				;;
			--name)
				shift
				sys_name=$1
				;;
			--vers)
				shift
				sys_vers=$1
				;;
			--root)
				shift
				[ -d "$1" ] && chk_root=`cd $1;pwd`
				;;
			--path)
				shift
				[ -d "$1" ] && chk_path=`cd $1;pwd`
				;;
			--more)
				shift
				[ -d "$1" ] && chk_temp=`cd $1;pwd` &&
					chk_more="${chk_more}${chk_temp} "
				;;
			*)
				chk_skip="${chk_skip}$1 "
				;;
		esac
		shift
	done
	# check if we have identified slacktree
	if [ ! -d "$sys_tree" ] ; then
		# make sure these are established
		[ -z "$sys_name" ] && sys_name=`find_slackname $chk_root`
		[ -z "$sys_vers" ] && sys_vers=`find_slackvers $chk_root`
		sys_tree=`find_slacktree $sys_name-$sys_vers $chk_path`
		[ ! -d "$sys_tree" ] && return
	fi
	local sys_logs="$chk_root/var/log/packages"
	# start looking...
	local patchdir="$sys_tree/patches/packages"
	[ ! -d $patchdir ] && return
	list_package_path $patchdir $sys_logs $chk_skip
	# look for paths for kernel patches
	local lnx_path=`find $patchdir -name "linux-*" -type d -maxdepth 1`
	for path in $lnx_path ; do
		list_package_path $path $sys_logs $chk_skip
	done
	# process extra paths?
	for path in $chk_more ; do
		list_package_path $path $sys_logs $chk_skip
	done
}

# oooh! blinking color text!

format_text()
{
	# format is "\033[<attr>;<textcolor>;<backcolor>m" \033 = \e (ESC char)
	local ends="\033[0m"
	# attributes
	local bold="1" # bright (bold on xterm?)
	local dim="2" # dim
	local uline="4"
	local blink="5" # doesn't work on xterm (only real console!)
	local reverse="7"
	local hidden="8"
	# text colors
	local black="30" # for background Xm + 10m
	local red="31"
	local green="32"
	local yellow="33"
	local blue="34"
	local magenta="35"
	local cyan="36"
	local white="37"
	local default="39"
	# check options
	local attr color text
	while [ "$1" != "" ] ; do
		case "$1" in
		--reset) attr="0" ;;
		--bold) attr=$bold ;;
		--blink) attr=$blink ;;
		--color)
			shift; color="$1"
			case "$color" in
				black) color="$black" ;;
				red) color="$red" ;;
				green) color="$green" ;;
				yellow) color="$yellow" ;;
				blue) color="$blue" ;;
				magenta) color="$magenta" ;;
				cyan) color="$cyan" ;;
				white) color="$white" ;;
				*) color="$default" ;;
			esac
			;;
		*)
			[ "$MY1_DEBUG" == "YES" ] &&
				echo "Attribute: $attr, Color: $color"
			if [ "$color" != "" ] ; then
				[ "$attr" == "" ] && attr="0"
				color="\033[${attr};${color}m"
			else
				[ "$attr" != "" ] &&
					color="\033[${attr}m"
			fi
			if [ "$color" == "" ] ;  then
				text="${text}${1} "
			else
				text="${text}${color}${1}${ends} "
			fi
			attr="" color=""
			;;
		esac
		shift
	done
	echo -e "$text"
}
