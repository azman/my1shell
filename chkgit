#!/bin/bash

# chkgit
# - written by azman@my1matrix.net
# - browse folders in current path and check git repos
# - create project from a git bundle

MY1TOOL=`basename $0 .sh`
MY1PATH=`dirname $0`
CURPATH=`pwd`

# look for config file
for conffile in "$CURPATH/.$MY1TOOL" "$HOME/.$MY1TOOL" ; do
	[ ! -f $conffile ] && continue
	source $conffile ; break
done

CLEAN_MSG="nothing to commit"
AHEAD_MSG="is ahead of"

# tool & env setup
GIT_BIN=${GIT_BIN:="$(which git 2>/dev/null)"}
[ "$GIT_BIN" = "" ] && echo "git binary NOT found! Aborting!" && exit 1
PATH2BUND=${PATH2BUND:="$HOME/archive/project"}
PATH2PROJ=${PATH2PROJ:="$CURPATH"}
PROJ_NAME=${PROJ_NAME:=""}
PROJ_COPY=${PROJ_COPY:=""}
B_VERBOSE="NO"

do_command=""
ok_command="create check origin update remote archive cleanup bundle"

# check parameters for command
while  [ "$1" != "" ]; do
	case $1 in
		--project-path|--path)
			shift
			[ ! -d "$1" ] && echo "Invalid path '$1'!" && exit 1
			PATH2PROJ=`cd $1;pwd`
			;;
		--project-name|--name)
			shift
			PROJ_NAME=$1
			;;
		--project-copy|--copy)
			shift
			PROJ_COPY=$1
			;;
		--bundle-path|--bpath)
			shift
			[ ! -d "$1" ] && echo "Invalid path '$1'!" && exit 1
			PATH2BUND=`cd $1;pwd`
			;;
		--verbose|-v)
			B_VERBOSE="YES"
			;;
		-*)
			echo "Unknown parameter '$1'"
			exit
			;;
		*)
			[ "$do_command" != "" ] &&
				echo "Command already given ($do_command)!" && exit 1
			for a in $ok_command; do
				if [ $1 == $a ]; then
					do_command=$1
					break;
				fi
			done
			[ "$do_command" == "" ] && echo "Unknown command ($1)!" && exit 1
			;;
	esac
	shift
done

# command functions

function chkgit_isclean()
{
	local chk_value=0
	local chk_quiet="NO"
	local chk_path=`pwd`
	[ "$1" == "--silent" ] && chk_quiet="YES"
	# do the actual checking
	if [ -d .git ]; then
		local is_clean=`$GIT_BIN status | grep "$CLEAN_MSG"`
		local is_ahead=`$GIT_BIN status | grep "$AHEAD_MSG"`
		local do_sweep=`$GIT_BIN status --ignored | grep "Ignored files:"`
		if [ "$is_clean" == "" ]; then
			[ "$chk_quiet" != "YES" ] && echo "Check: $chk_path [unclean]"
			chk_value=2
		elif [ "$is_ahead" != "" ]; then
			[ "$chk_quiet" != "YES" ] && echo "Check: $chk_path [ahead]"
			chk_value=3
		elif [ "$do_sweep" != "" ]; then
			[ "$chk_quiet" != "YES" ] && echo "Check: $chk_path [ignored]"
			chk_value=4
		else
			[ "$B_VERBOSE" == "YES"  ] &&
				[ "$chk_quiet" != "YES" ] && echo "GIT: $chk_path"
		fi
	else
		[ "$B_VERBOSE" == "YES"  ] &&
			[ "$chk_quiet" != "YES" ] && echo "NOT: $chk_path"
		chk_value=1
	fi
	return $chk_value
}

function chkgit_origin()
{
	local chk_origin chk_source chk_sedpat
	local chk_value=0
	local chk_path=`pwd`
	local chk_quiet="NO"
	local chk_base=`basename $chk_path`
	[ "$1" == "--silent" ] && chk_quiet="YES"
	[ "$chk_quiet" != "YES" ] && echo -n "${chk_base}: "
	if [ -d .git ]; then
		chk_sedpat="s/^origin[[:space:]]*\([^[:space:]]*\).*$/\1/"
		chk_origin=`$GIT_BIN remote -v | grep origin | grep \(fetch\)`
		if [ "$chk_origin" != "" ]; then
			chk_source=`echo $chk_origin | sed $chk_sedpat`
			[ "$chk_quiet" != "YES" ] && echo "'$chk_source'"
		else
			[ "$chk_quiet" != "YES" ] && echo "No origin repo found!"
			chk_value=2
		fi
	else
		[ "$chk_quiet" != "YES" ] && echo "Not a git repo!"
		chk_value=1
	fi
	return $chk_value
}

function chkgit_remote()
{
	local chk_remote chk_sedpat chk_srcpat
	local chk_path=`pwd`
	local chk_base=`basename $chk_path`
	if [ -d .git ]; then
		chk_srcpat="^\([^[:space:]]*\)[[:space:]]*\([^[:space:]]*\).*$"
		chk_sedpat="s/$chk_srcpat/$chk_base: \2 (\1)/g"
		chk_remote=`$GIT_BIN remote -v | grep \(fetch\)`
		if [ "$chk_remote" != "" ]; then
			echo $chk_remote | sed "$chk_sedpat"
		else
			[ "$B_VERBOSE" == "YES"  ] &&
				echo "$chk_base: No remote repo found!"
		fi
	else
		[ "$B_VERBOSE" == "YES"  ] &&
			echo "$chk_base: Not a git repo!"
	fi
}

function chkgit_update()
{
	local chk_path=`pwd`
	local chk_base=`basename $chk_path`
	local chk_value chk_source
	echo -n "$chk_base: "
	chkgit_isclean --silent
	chk_value=$?
	[ $chk_value -eq 1 ] && echo "Not a git repo!" && return
	[ $chk_value -eq 2 ] && echo "Repo not clean! Skipped!" && return
	[ $chk_value -eq 3 ] && echo "Repo is ahead!"
	chkgit_origin --silent
	chk_value=$?
	[ $chk_value -ne 0 ] && echo "No origin found! Skipped!" && return
	echo -n "Running update... "
	$GIT_BIN pull
}

function chkgit_cleanup()
{
	local chk_path=`pwd`
	local chk_base=`basename $chk_path`
	local chk_value chk_source
	echo -n "$chk_base: "
	chkgit_isclean --silent
	chk_value=$?
	[ $chk_value -eq 0 ] && echo "Clean!" && return
	[ $chk_value -eq 1 ] && echo "Not a git repo!" && return
	[ $chk_value -eq 2 ] && echo "Repo not clean! Skipped!" && return
	[ $chk_value -eq 3 ] && echo "Repo is ahead!" && return
	# reset to HEAD
	echo -n "Cleaning up... "
	$GIT_BIN clean -ffdx >/dev/null
	if [ $? -ne 0 ] ; then echo "something is wrong?! ($?)"
	else echo "done!" ; fi
}

function chkgit_archive()
{
	local chk_path=`pwd`
	local chk_base=`basename $chk_path`
	local chk_full chk_name chk_date
	if [ -d .git ]; then
		chk_date=`$GIT_BIN log -1 --format=%cd --date=format:'%Y%m%d%H%M%S'`
		chk_name=${chk_base}-${chk_date}.git
		chk_full=${PATH2BUND}/${chk_name}
		local that_find=`find ${PATH2BUND} -name ${chk_base}-*.git`
		for this_find in $that_find ; do
			if [ -f "$this_find" -a "$this_find" != "$chk_full" ] ; then
				echo "Old archive '$this_find' found?"
			fi
		done
		if [ -f "$chk_full" ] ; then
			[ "$B_VERBOSE" == "YES"  ] &&
				echo "File '$PATH2BUND/$chk_name' found! Archive is up to date!"
			return
		fi
		echo -n "Creating new archive '$chk_name' in $PATH2BUND... "
		git bundle create ${PATH2BUND}/${chk_name} --all 2>/dev/null
		[ $? -ne 0 ] && echo "Error running git?" && exit 1
		echo "done."
	else
		[ "$B_VERBOSE" == "YES"  ] &&
			echo "$chk_base: Not a git repo!"
	fi
}

# do your thing!

if [ "$do_command" == "check" ] || [ "$do_command" == "" ]; then #default!
	# browse subfolders and report dirty repo!
	for path in `find -L * -maxdepth 0 -type d` ; do
		cd $path
		chkgit_isclean
		cd $CURPATH
	done
elif [ "$do_command" == "origin" ]; then
	# browse subfolders and report origin url
	for path in `find -L * -maxdepth 0 -type d` ; do
		cd $path
		chkgit_origin
		cd $CURPATH
	done
elif [ "$do_command" == "remote" ]; then
	# browse subfolders and report remote fetch url
	for path in `find -L * -maxdepth 0 -type d` ; do
		cd $path
		chkgit_remote
		cd $CURPATH
	done
elif [ "$do_command" == "update" ]; then
	# browse subfolders and update
	for path in `find -L * -maxdepth 0 -type d` ; do
		cd $path
		chkgit_update
		cd $CURPATH
	done
elif [ "$do_command" == "create" ]; then
	[ ! -d "$PATH2BUND" ] &&
		echo "Invalid bundle path '$PATH2BUND'!" && exit 1
	[ ! -d "$PATH2PROJ" ] &&
		echo "Invalid project path '$PATH2PROJ'!" && exit 1
	[ "$PROJ_NAME" == "" ] && echo "No project name given!" && exit 1
	cd $PATH2PROJ
	FULL_PATH=${PATH2BUND}/${PROJ_NAME}.git # dummy ???
	FULL_FIND=`find ${PATH2BUND} -name "${PROJ_NAME}-*.git" | sort`
	for FULL_TEST in $FULL_FIND ; do
		TEMP_TEST=`echo $FULL_TEST | sed 's/\(.*\)-[0-9]\{12,14\}.*$/\1/'`
		TEMP_TEST=`basename $TEMP_TEST`
		[ "$TEMP_TEST" != "$PROJ_NAME" ] && continue;
		FULL_PATH=$FULL_TEST
	done # will get latest???
	if [ ! -f "$FULL_PATH" ] ; then
		echo "Bundle '$FULL_PATH' not found!" && exit 1
	fi
	if [ "$PROJ_COPY" == "" ] ; then
		PROJ_COPY=`basename $FULL_PATH .git`
		PROJ_COPY=`echo $PROJ_COPY | sed 's/\(.*\)-[0-9]\{12,14\}.*$/\1/'`
	fi
	[ -d "$PROJ_COPY" ] &&
		echo "'$PROJ_COPY' exists in '$PATH2PROJ'!" && exit 1
	echo "Bundle: $FULL_PATH"
	echo -n "Cloning '$PROJ_COPY'... "
	$GIT_BIN clone $FULL_PATH $PROJ_COPY >/dev/null 2>&1
	echo "done."
	cd $PROJ_COPY
	LIST_REFS=`git bundle verify $FULL_PATH 2>&1 | grep "refs/heads"`
	LIST_REFS=`echo "$LIST_REFS" | sed 's|^.* refs/heads/\(.*\)$|\1|'`
	for ref in $LIST_REFS ; do
		[ "$ref" == "master" ] && continue
		echo -n "Creating local branch '$ref'... "
		$GIT_BIN checkout $ref >/dev/null 2>&1
		echo "done."
	done
	echo -n "Putting HEAD to master branch... "
	$GIT_BIN checkout master >/dev/null 2>&1
	echo "done."
	echo -n "Removing origin link to bundle... "
	$GIT_BIN remote rm origin >/dev/null 2>&1
	echo "done."
	cd $CURPATH
elif [ "$do_command" == "bundle" ]; then
	[ ! -d "$PATH2BUND" ] &&
		echo "Invalid bundle path '$PATH2BUND'!" && exit 1
	[ ! -d .git ] &&
		echo "Not in a git path '$CURPATH'!" && exit 1
	PROJ_NAME=`basename $CURPATH`
	FULL_FIND=`find ${PATH2BUND} -name "${PROJ_NAME}-*.git" | sort`
	for FULL_TEST in $FULL_FIND ; do
		TEMP_TEST=`echo $FULL_TEST | sed 's/\(.*\)-[0-9]\{12,14\}.*$/\1/'`
		TEMP_TEST=`basename $TEMP_TEST`
		[ "$TEMP_TEST" != "$PROJ_NAME" ] && continue;
		FULL_PATH=$FULL_TEST
	done # will get latest???
	if [ ! -f "$FULL_PATH" ] ; then
		echo "Bundle '$FULL_PATH' not found!" && exit 1
	fi
	echo "Bundle: $FULL_PATH"
	echo -n "Updating $PROJ_NAME from master branch... "
	$GIT_BIN pull $FULL_PATH master 2>/dev/null
elif [ "$do_command" == "archive" ]; then
	[ ! -d "$PATH2BUND" ] &&
		echo "Invalid bundle path '$PATH2BUND'!" && exit 1
	[ ! -d "$PATH2PROJ" ] &&
		echo "Invalid project path '$PATH2PROJ'!" && exit 1
	# single project archive check
	if [ "$PROJ_NAME" != "" -a -d "$PATH2PROJ/$PROJ_NAME" ] ; then
		cd $PATH2PROJ/$PROJ_NAME
		chkgit_archive
		cd $CURPATH
	else
		# browse subfolders and archive
		for path in `find -L $PATH2PROJ/* -maxdepth 0 -type d` ; do
			cd $path
			chkgit_archive
			cd $CURPATH
		done
	fi
elif [ "$do_command" == "cleanup" ]; then
	# browse subfolders and clean up all git repo!
	for path in `find -L * -maxdepth 0 -type d` ; do
		cd $path
		chkgit_cleanup
		cd $CURPATH
	done
fi

exit 0
