#!/bin/bash

# chkgit
# - written by azman@my1matrix.net
# - browse folders in current path and check git repos
# - create project copy from local repo

MY1TOOL="$(basename $0 .sh)"
MY1PATH="$(dirname $0)"
CURPATH="$(pwd)"

# look for config file
for conffile in "$CURPATH/.$MY1TOOL" "$CURPATH/$MY1TOOL.conf" \
		"$HOME/.$MY1TOOL" "$HOME/.$MY1TOOL.conf" ; do
	[[ ! -f $conffile ]] && continue
	source $conffile ; break
done

CLEAN_MSG="nothing to commit"
AHEAD_MSG="is ahead of"

# tool & env setup
GIT_BIN=${GIT_BIN:="$(which git 2>/dev/null)"}
[[ "$GIT_BIN" = "" ]] && echo "git binary NOT found! Aborting!" && exit 1
PATH2REPO=${PATH2REPO:="$HOME/repository"}
PATH2PROJ=${PATH2PROJ:="$HOME/project"}
PROJ_NAME=""
PROJ_COPY=""
OPT_VERBOSE="NO"

do_command=""
ok_command="create check origin update remote"

# check parameters for command
while  [[ "$1" != "" ]]; do
	case $1 in
		--project-path)
			shift
			PATH2PROJ=$1
			;;
		--project-name)
			shift
			PROJ_NAME=$1
			;;
		--project-copy)
			shift
			PROJ_COPY=$1
			;;
		--repo-path)
			shift
			PATH2REPO=$1
			;;
		--verbose|-v)
			OPT_VERBOSE="YES"
			;;
		-*)
			echo "Unknown parameter '$1'"
			exit
			;;
		*)
			[[ "$do_command" != "" ]] &&
				echo "Command already given ($do_command)!" && exit 1
			for a in $ok_command; do
				if [[ $1 == $a ]]; then
					do_command=$1
					if [[ "$do_command" == "create" ]]; then
						shift
						PROJ_NAME=$1
					fi
					break;
				fi
			done
			[[ "$do_command" == "" ]] && echo "Unknown command ($1)!" && exit 1
			;;
	esac
	shift
done

# command functions

function chkgit_clean()
{
	# do the actual checking
	if [[ -d .git ]]; then
		if [[ "$($GIT_BIN status | grep "$CLEAN_MSG")" == "" ]]; then
			echo "Check: $(pwd) [unclean]"
		elif [[ "$($GIT_BIN status | grep "$AHEAD_MSG")" != "" ]]; then
			echo "Check: $(pwd) [ahead]"
		elif [[ "$OPT_VERBOSE" = "YES" ]]; then
			[[ "$OPT_VERBOSE" == "YES"  ]] && echo "GIT: $(pwd)"
		fi
	else
		[[ "$OPT_VERBOSE" == "YES"  ]] && echo "NOT: $(pwd)"
	fi
}

function chkgit_origin()
{
	local chk_origin chk_source
	local chk_path=$(pwd)
	if [[ -d .git ]]; then
		local chk_ifs=$IFS
		IFS=$'\n'
		chk_origin=($($GIT_BIN remote -v | grep origin))
		IFS=$chk_ifs
		if [[ ${#chk_origin[@]} -gt 0 ]]; then
			chk_source=${chk_origin[0]##origin	}
			chk_source=${chk_source%% (*}
			echo "$(basename $chk_path): '$chk_source'"
		else
			echo "$(basename $chk_path): No origin repo found!"
		fi
	else
		[[ "$OPT_VERBOSE" == "YES"  ]] &&
			echo "$(basename $chk_path): Not a git repo!"
	fi
}

function chkgit_remote()
{
	local chk_origin chk_source chk_label
	local chk_path=$(pwd)
	if [[ -d .git ]]; then
		local chk_ifs=$IFS
		IFS=$'\n'
		chk_origin=($($GIT_BIN remote -v | grep fetch))
		IFS=$chk_ifs
		if [[ ${#chk_origin[@]} -gt 0 ]]; then
			for (( a=0;a<${#chk_origin[@]};a++ )); do
				chk_label=${chk_origin[$a]%	*}
				chk_source=${chk_origin[$a]##$chk_label	}
				chk_source=${chk_source%% (*}
				echo "$(basename $chk_path): '$chk_source' ($chk_label)"
			done
		else
			[[ "$OPT_VERBOSE" == "YES"  ]] &&
				echo "$(basename $chk_path): No remote repo found!"
		fi
	else
		[[ "$OPT_VERBOSE" == "YES"  ]] &&
			echo "$(basename $chk_path): Not a git repo!"
	fi
}

function chkgit_update()
{
	local chk_path=$(pwd)
	if [[ -d .git ]]; then
		chkgit_clean --silent
		[[ $? -ne 0 ]] &&
			echo "$(basename $chk_path): Repo not clean! Skipped!" && return
		echo "$(basename $chk_path): Running update..."
		$GIT_BIN pull
	else
		[[ "$OPT_VERBOSE" == "YES"  ]] &&
			echo "$(basename $chk_path): Not a git repo!"
	fi
}

# do your thing!

if [[ "$do_command" == "check" ]] || [[ "$do_command" == "" ]]; then #default! 
	# browse subfolders and report dirty repo!
	for path in $(find * -maxdepth 0 -type d); do
		cd $path
		chkgit_clean
		cd $CURPATH
	done
elif [[ "$do_command" == "origin" ]]; then
	# browse subfolders and report origin url
	for path in $(find * -maxdepth 0 -type d); do
		cd $path
		chkgit_origin
		cd $CURPATH
	done
elif [[ "$do_command" == "remote" ]]; then
	# browse subfolders and report remote fetch url
	for path in $(find * -maxdepth 0 -type d); do
		cd $path
		chkgit_remote
		cd $CURPATH
	done
elif [[ "$do_command" == "create" ]]; then
	[[ ! -d "$PATH2REPO" ]] && echo "Invalid repo path '$PATH2REPO'!" && exit 1
	[[ ! -d "$PATH2PROJ" ]] &&
		echo "Invalid project path '$PATH2REPO'!" && exit 1
	[[ "$PROJ_NAME" == "" ]] && echo "No project name given!" && exit 1
	[[ "$PROJ_COPY" == "" ]] && PROJ_COPY=$PROJ_NAME
	cd $PATH2PROJ
	[[ -d "$PROJ_COPY" ]] &&
		echo "'$PROJ_COPY' exists in '$PATH2PROJ'!" && exit 1
	FULL_PATH=${PATH2REPO}/${PROJ_NAME}.git
	FULL_TEST=${PATH2REPO}/${PROJ_NAME}
	if [[ -d "$FULL_PATH" ]] ; then
		FULL_TEST=$FULL_PATH # do nothing actually!
	elif [[ -d "$FULL_TEST" ]]; then
		FULL_PATH=$FULL_TEST
	else
		echo "Repository '$FULL_PATH'/'$FULL_TEST' not found!" && exit 1
	fi
	$GIT_BIN clone file://$FULL_PATH $PROJ_COPY
elif [[ "$do_command" == "update" ]]; then
	# browse subfolders and update
	for path in $(find * -maxdepth 0 -type d); do
		cd $path
		chkgit_update
		cd $CURPATH
	done
fi

exit 0
